{
    "sourceFile": "src/tools/agent.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1767930490664,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1767931592826,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -128,9 +128,9 @@\n   },\r\n   {\r\n     agentType: 'code-analyzer',\r\n     whenToUse: 'Code analyzer agent for analyzing files and directories. Use this when you need to analyze code structure, dependencies, exports, and relationships. Returns structured JSON with semantic information.',\r\n-    tools: ['Read', 'Grep', 'Glob', 'Bash'],\r\n+    tools: ['Read', 'Grep', 'Glob', 'Bash','LSP'],\r\n     forkContext: false,\r\n     model: 'opus',  // 使用快速模型\r\n     getSystemPrompt: () => CODE_ANALYZER_PROMPT,\r\n   },\r\n"
                }
            ],
            "date": 1767930490664,
            "name": "Commit-0",
            "content": "/**\r\n * Agent 工具 (Task)\r\n * 子代理管理 - 参照官方 Claude Code CLI v2.0.76 实现\r\n */\r\n\r\nimport { BaseTool } from './base.js';\r\nimport type { AgentInput, ToolResult, ToolDefinition } from '../types/index.js';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\nimport * as os from 'os';\r\nimport { getBackgroundShell, isShellId } from './bash.js';\r\n// 使用动态导入避免循环依赖：agent.ts -> loop.ts -> tools/index.ts -> agent.ts\r\nimport type { LoopOptions } from '../core/loop.js';\r\nimport {\r\n  runSubagentStartHooks,\r\n  runSubagentStopHooks,\r\n  type HookInput\r\n} from '../hooks/index.js';\r\nimport type { Message } from '../types/index.js';\r\nimport { GENERAL_PURPOSE_AGENT_PROMPT, EXPLORE_AGENT_PROMPT, CODE_ANALYZER_PROMPT, BLUEPRINT_WORKER_PROMPT } from '../prompt/templates.js';\r\n\r\n// 代理类型定义（参照官方）\r\nexport interface AgentTypeDefinition {\r\n  agentType: string;\r\n  whenToUse: string;\r\n  tools?: string[];\r\n  forkContext?: boolean;  // 是否访问父对话上下文\r\n  permissionMode?: 'default' | 'plan' | 'acceptEdits' | 'bypassPermissions';\r\n  model?: string;         // 代理类型的默认模型\r\n  description?: string;\r\n  getSystemPrompt?: () => string;  // 系统提示词生成函数\r\n}\r\n\r\n// 模型别名类型（与官方 SDK 一致）\r\nexport type ModelAlias = 'sonnet' | 'opus' | 'haiku' | 'inherit';\r\n\r\n// 全局父模型上下文（用于 inherit 继承）\r\nlet parentModelContext: string | undefined;\r\n\r\n/**\r\n * 设置父模型上下文\r\n * 在主循环中设置，供子代理继承\r\n */\r\nexport function setParentModelContext(model: string | undefined): void {\r\n  parentModelContext = model;\r\n}\r\n\r\n/**\r\n * 获取父模型上下文\r\n */\r\nexport function getParentModelContext(): string | undefined {\r\n  return parentModelContext;\r\n}\r\n\r\n/**\r\n * 解析模型参数，处理 inherit 继承\r\n * @param modelParam 模型参数 ('sonnet', 'opus', 'haiku', 'inherit', 或 undefined)\r\n * @param agentDefaultModel 代理类型的默认模型（可选）\r\n * @returns 解析后的模型名称\r\n */\r\nexport function resolveAgentModel(\r\n  modelParam: string | undefined,\r\n  agentDefaultModel?: string\r\n): string | undefined {\r\n  // 如果指定了 inherit，使用父模型\r\n  if (modelParam === 'inherit') {\r\n    return parentModelContext || agentDefaultModel || 'sonnet';\r\n  }\r\n\r\n  // 如果明确指定了模型，使用指定的\r\n  if (modelParam && modelParam !== 'inherit') {\r\n    return modelParam;\r\n  }\r\n\r\n  // 如果代理类型有默认模型，使用代理默认模型\r\n  if (agentDefaultModel) {\r\n    return agentDefaultModel;\r\n  }\r\n\r\n  // 否则，继承父模型（如果有）\r\n  if (parentModelContext) {\r\n    return parentModelContext;\r\n  }\r\n\r\n  // 最终默认使用 sonnet\r\n  return undefined; // 让 ConversationLoop 使用它自己的默认值\r\n}\r\n\r\n// 内置代理类型\r\nexport const BUILT_IN_AGENT_TYPES: AgentTypeDefinition[] = [\r\n  {\r\n    agentType: 'general-purpose',\r\n    whenToUse: 'General-purpose agent for researching complex questions, searching for code, and executing multi-step tasks. When you are searching for a keyword or file and are not confident that you will find the right match in the first few tries use this agent to perform the search for you.',\r\n    tools: ['*'],  // 所有工具\r\n    forkContext: false,\r\n    getSystemPrompt: () => GENERAL_PURPOSE_AGENT_PROMPT,\r\n  },\r\n  {\r\n    agentType: 'Explore',\r\n    whenToUse: 'Fast agent specialized for exploring codebases. Use this when you need to quickly find files by patterns (eg. \"src/components/**/*.tsx\"), search code for keywords (eg. \"API endpoints\"), or answer questions about the codebase (eg. \"how do API endpoints work?\"). When calling this agent, specify the desired thoroughness level: \"quick\" for basic searches, \"medium\" for moderate exploration, or \"very thorough\" for comprehensive analysis across multiple locations and naming conventions.',\r\n    tools: ['Glob', 'Grep', 'Read'],\r\n    forkContext: false,\r\n    model: 'haiku',\r\n    getSystemPrompt: () => EXPLORE_AGENT_PROMPT,\r\n  },\r\n  {\r\n    agentType: 'Plan',\r\n    whenToUse: 'Software architect agent for designing implementation plans. Use this when you need to plan the implementation strategy for a task. Returns step-by-step plans, identifies critical files, and considers architectural trade-offs.',\r\n    tools: ['*'],\r\n    forkContext: false,\r\n    permissionMode: 'plan',\r\n    // Plan agent 的系统提示词待后续添加\r\n  },\r\n  {\r\n    agentType: 'claude-code-guide',\r\n    whenToUse: 'Agent for Claude Code documentation and API questions',\r\n    tools: ['Glob', 'Grep', 'Read', 'WebFetch', 'WebSearch'],\r\n    forkContext: false,\r\n    // claude-code-guide agent 的系统提示词待后续添加\r\n  },\r\n  {\r\n    agentType: 'blueprint-worker',\r\n    whenToUse: 'Worker agent for executing blueprint tasks with TDD methodology. This agent writes tests first, then implements code until tests pass. Only used by the blueprint system (Queen Agent).',\r\n    tools: ['*'],\r\n    forkContext: false,\r\n    getSystemPrompt: () => BLUEPRINT_WORKER_PROMPT,\r\n  },\r\n  {\r\n    agentType: 'code-analyzer',\r\n    whenToUse: 'Code analyzer agent for analyzing files and directories. Use this when you need to analyze code structure, dependencies, exports, and relationships. Returns structured JSON with semantic information.',\r\n    tools: ['Read', 'Grep', 'Glob', 'Bash'],\r\n    forkContext: false,\r\n    model: 'opus',  // 使用快速模型\r\n    getSystemPrompt: () => CODE_ANALYZER_PROMPT,\r\n  },\r\n];\r\n\r\n// 兼容性导出：将数组转换为对象格式（用于测试）\r\nexport const AGENT_TYPES: Record<string, { description: string; tools: string[] }> =\r\n  BUILT_IN_AGENT_TYPES.reduce((acc, agent) => {\r\n    acc[agent.agentType] = {\r\n      description: agent.whenToUse,\r\n      tools: agent.tools || ['*'],\r\n    };\r\n    return acc;\r\n  }, {} as Record<string, { description: string; tools: string[] }>);\r\n\r\n// 代理执行历史条目\r\nexport interface AgentHistoryEntry {\r\n  timestamp: Date;\r\n  type: 'started' | 'progress' | 'completed' | 'failed' | 'resumed';\r\n  message: string;\r\n  data?: any;\r\n}\r\n\r\n// 后台代理管理\r\nexport interface BackgroundAgent {\r\n  id: string;\r\n  agentType: string;\r\n  description: string;\r\n  prompt: string;\r\n  model?: string;\r\n  status: 'running' | 'completed' | 'failed' | 'paused';\r\n  startTime: Date;\r\n  endTime?: Date;\r\n  result?: ToolResult;\r\n  error?: string;\r\n  // 持久化状态\r\n  history: AgentHistoryEntry[];\r\n  intermediateResults: any[];\r\n  currentStep?: number;\r\n  totalSteps?: number;\r\n  workingDirectory?: string;\r\n  metadata?: Record<string, any>;\r\n  // 新增：对话历史\r\n  messages?: Message[];\r\n  // 新增：进度追踪（对齐官方实现）\r\n  progress?: {\r\n    toolUseCount: number;\r\n    tokenCount: number;\r\n  };\r\n  lastActivity?: {\r\n    toolName: string;\r\n    input: any;\r\n  };\r\n}\r\n\r\nconst backgroundAgents: Map<string, BackgroundAgent> = new Map();\r\n\r\n// 代理持久化目录\r\nconst getAgentsDir = (): string => {\r\n  const agentsDir = path.join(os.homedir(), '.claude', 'agents');\r\n  if (!fs.existsSync(agentsDir)) {\r\n    fs.mkdirSync(agentsDir, { recursive: true });\r\n  }\r\n  return agentsDir;\r\n};\r\n\r\nconst getAgentFilePath = (agentId: string): string => {\r\n  return path.join(getAgentsDir(), `${agentId}.json`);\r\n};\r\n\r\n// 持久化函数\r\nconst saveAgentState = (agent: BackgroundAgent): void => {\r\n  try {\r\n    const filePath = getAgentFilePath(agent.id);\r\n    const data = {\r\n      ...agent,\r\n      startTime: agent.startTime.toISOString(),\r\n      endTime: agent.endTime?.toISOString(),\r\n      history: agent.history.map(h => ({\r\n        ...h,\r\n        timestamp: h.timestamp.toISOString(),\r\n      })),\r\n    };\r\n    fs.writeFileSync(filePath, JSON.stringify(data, null, 2), 'utf-8');\r\n  } catch (error) {\r\n    console.error(`Failed to save agent state ${agent.id}:`, error);\r\n  }\r\n};\r\n\r\nconst loadAgentState = (agentId: string): BackgroundAgent | null => {\r\n  try {\r\n    const filePath = getAgentFilePath(agentId);\r\n    if (!fs.existsSync(filePath)) {\r\n      return null;\r\n    }\r\n\r\n    const data = JSON.parse(fs.readFileSync(filePath, 'utf-8'));\r\n    const agent: BackgroundAgent = {\r\n      ...data,\r\n      startTime: new Date(data.startTime),\r\n      endTime: data.endTime ? new Date(data.endTime) : undefined,\r\n      history: data.history.map((h: any) => ({\r\n        ...h,\r\n        timestamp: new Date(h.timestamp),\r\n      })),\r\n    };\r\n    return agent;\r\n  } catch (error) {\r\n    console.error(`Failed to load agent state ${agentId}:`, error);\r\n    return null;\r\n  }\r\n};\r\n\r\nconst deleteAgentState = (agentId: string): void => {\r\n  try {\r\n    const filePath = getAgentFilePath(agentId);\r\n    if (fs.existsSync(filePath)) {\r\n      fs.unlinkSync(filePath);\r\n    }\r\n  } catch (error) {\r\n    console.error(`Failed to delete agent state ${agentId}:`, error);\r\n  }\r\n};\r\n\r\n// 加载所有已保存的代理\r\nconst loadAllAgents = (): void => {\r\n  try {\r\n    const agentsDir = getAgentsDir();\r\n    const files = fs.readdirSync(agentsDir);\r\n\r\n    for (const file of files) {\r\n      if (file.endsWith('.json')) {\r\n        const agentId = file.replace('.json', '');\r\n        const agent = loadAgentState(agentId);\r\n        if (agent) {\r\n          backgroundAgents.set(agentId, agent);\r\n        }\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.error('Failed to load agents:', error);\r\n  }\r\n};\r\n\r\n// 添加历史记录\r\nconst addAgentHistory = (\r\n  agent: BackgroundAgent,\r\n  type: AgentHistoryEntry['type'],\r\n  message: string,\r\n  data?: any\r\n): void => {\r\n  agent.history.push({\r\n    timestamp: new Date(),\r\n    type,\r\n    message,\r\n    data,\r\n  });\r\n  saveAgentState(agent);\r\n};\r\n\r\n// 导出代理管理函数\r\nexport function getBackgroundAgents(): BackgroundAgent[] {\r\n  return Array.from(backgroundAgents.values());\r\n}\r\n\r\nexport function getBackgroundAgent(id: string): BackgroundAgent | undefined {\r\n  let agent = backgroundAgents.get(id);\r\n\r\n  // 如果内存中没有，尝试从磁盘加载\r\n  if (!agent) {\r\n    const loaded = loadAgentState(id);\r\n    if (loaded) {\r\n      backgroundAgents.set(id, loaded);\r\n      agent = loaded;\r\n    }\r\n  }\r\n\r\n  return agent;\r\n}\r\n\r\nexport function killBackgroundAgent(id: string): boolean {\r\n  const agent = backgroundAgents.get(id);\r\n  if (!agent) return false;\r\n\r\n  if (agent.status === 'running') {\r\n    agent.status = 'failed';\r\n    agent.error = 'Killed by user';\r\n    agent.endTime = new Date();\r\n    addAgentHistory(agent, 'failed', 'Agent killed by user');\r\n  }\r\n  return true;\r\n}\r\n\r\nexport function clearCompletedAgents(): number {\r\n  let cleared = 0;\r\n  const entries = Array.from(backgroundAgents.entries());\r\n  for (const [id, agent] of entries) {\r\n    if (agent.status === 'completed' || agent.status === 'failed') {\r\n      backgroundAgents.delete(id);\r\n      deleteAgentState(id);\r\n      cleared++;\r\n    }\r\n  }\r\n  return cleared;\r\n}\r\n\r\nexport function pauseBackgroundAgent(id: string): boolean {\r\n  const agent = backgroundAgents.get(id);\r\n  if (!agent) return false;\r\n\r\n  if (agent.status === 'running') {\r\n    agent.status = 'paused';\r\n    addAgentHistory(agent, 'progress', 'Agent paused');\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\n// 获取代理类型定义\r\nexport function getAgentTypeDefinition(agentType: string): AgentTypeDefinition | null {\r\n  return BUILT_IN_AGENT_TYPES.find(def => def.agentType === agentType) || null;\r\n}\r\n\r\n// 初始化时加载所有代理\r\nloadAllAgents();\r\n\r\nexport class TaskTool extends BaseTool<AgentInput, ToolResult> {\r\n  name = 'Task';\r\n  description = `Launch a new agent to handle complex, multi-step tasks autonomously.\r\n\r\nThe Task tool launches specialized agents (subprocesses) that autonomously handle complex tasks. Each agent type has specific capabilities and tools available to it.\r\n\r\nAvailable agent types and the tools they have access to:\r\n${BUILT_IN_AGENT_TYPES.map(def => `- ${def.agentType}: ${def.whenToUse}${def.forkContext ? ' (Properties: access to current context)' : ''}`).join('\\n')}\r\n\r\nWhen using the Task tool, you must specify a subagent_type parameter to select which agent type to use.\r\n\r\nWhen NOT to use the Task tool:\r\n- If you want to read a specific file path, use the Read or Grep tool instead of the Task tool, to find the match more quickly\r\n- If you are searching for a specific class definition like \"class Foo\", use the Grep tool instead, to find the match more quickly\r\n- If you are searching for code within a specific file or set of 2-3 files, use the Read tool instead of the Task tool, to find the match more quickly\r\n- Other tasks that are not related to the agent descriptions above\r\n\r\n\r\nUsage notes:\r\n- Always include a short description (3-5 words) summarizing what the agent will do\r\n- Launch multiple agents concurrently whenever possible, to maximize performance; to do that, use a single message with multiple tool uses\r\n- When the agent is done, it will return a single message back to you. The result returned by the agent is not visible to the user. To show the user the result, you should send a text message back to the user with a concise summary of the result.\r\n- You can optionally run agents in the background using the run_in_background parameter. When an agent runs in the background, you will need to use TaskOutput to retrieve its results once it's done. You can continue to work while background agents run - When you need their results to continue you can use TaskOutput in blocking mode to pause and wait for their results.\r\n- Agents can be resumed using the \\`resume\\` parameter by passing the agent ID from a previous invocation. When resumed, the agent continues with its full previous context preserved. When NOT resuming, each invocation starts fresh and you should provide a detailed task description with all necessary context.\r\n- When the agent is done, it will return a single message back to you along with its agent ID. You can use this ID to resume the agent later if needed for follow-up work.\r\n- Provide clear, detailed prompts so the agent can work autonomously and return exactly the information you need.\r\n- Agents with \"access to current context\" can see the full conversation history before the tool call. When using these agents, you can write concise prompts that reference earlier context (e.g., \"investigate the error discussed above\") instead of repeating information. The agent will receive all prior messages and understand the context.\r\n- The agent's outputs should generally be trusted\r\n- Clearly tell the agent whether you expect it to write code or just to do research (search, file reads, web fetches, etc.), since it is not aware of the user's intent\r\n- If the agent description mentions that it should be used proactively, then you should try your best to use it without the user having to ask for it first. Use your judgement.\r\n- If the user specifies that they want you to run agents \"in parallel\", you MUST send a single message with multiple Task tool use content blocks. For example, if you need to launch both a code-reviewer agent and a test-runner agent in parallel, send a single message with both tool calls.\r\n\r\nExample usage:\r\n\r\n<example_agent_descriptions>\r\n\"code-reviewer\": use this agent after you are done writing a signficant piece of code\r\n\"greeting-responder\": use this agent when to respond to user greetings with a friendly joke\r\n</example_agent_description>\r\n\r\n<example>\r\nuser: \"Please write a function that checks if a number is prime\"\r\nassistant: Sure let me write a function that checks if a number is prime\r\nassistant: First let me use the Write tool to write a function that checks if a number is prime\r\nassistant: I'm going to use the Write tool to write the following code:\r\n<code>\r\nfunction isPrime(n) {\r\n  if (n <= 1) return false\r\n  for (let i = 2; i * i <= n; i++) {\r\n    if (n % i === 0) return false\r\n  }\r\n  return true\r\n}\r\n</code>\r\n<commentary>\r\nSince a signficant piece of code was written and the task was completed, now use the code-reviewer agent to review the code\r\n</commentary>\r\nassistant: Now let me use the code-reviewer agent to review the code\r\nassistant: Uses the Task tool to launch the code-reviewer agent\r\n</example>\r\n\r\n<example>\r\nuser: \"Hello\"\r\n<commentary>\r\nSince the user is greeting, use the greeting-responder agent to respond with a friendly joke\r\n</commentary>\r\nassistant: \"I'm going to use the Task tool to launch the greeting-responder agent\"\r\n</example>`;\r\n\r\n  // 父对话上下文（用于 forkContext）\r\n  private parentMessages: Message[] = [];\r\n\r\n  /**\r\n   * 设置父对话上下文（在 Loop 中调用）\r\n   */\r\n  setParentContext(messages: Message[]): void {\r\n    this.parentMessages = messages;\r\n  }\r\n\r\n  getInputSchema(): ToolDefinition['inputSchema'] {\r\n    return {\r\n      type: 'object',\r\n      properties: {\r\n        description: {\r\n          type: 'string',\r\n          description: 'A short (3-5 word) description of the task',\r\n        },\r\n        prompt: {\r\n          type: 'string',\r\n          description: 'The task for the agent to perform',\r\n        },\r\n        subagent_type: {\r\n          type: 'string',\r\n          description: 'The type of specialized agent to use for this task',\r\n        },\r\n        model: {\r\n          type: 'string',\r\n          enum: ['sonnet', 'opus', 'haiku', 'inherit'],\r\n          description: 'Optional model to use for this agent. Use \"inherit\" to explicitly inherit from parent. If not specified, inherits from parent. Prefer haiku for quick, straightforward tasks to minimize cost and latency.',\r\n        },\r\n        resume: {\r\n          type: 'string',\r\n          description: 'Optional agent ID to resume from. If provided, the agent will continue from the previous execution transcript.',\r\n        },\r\n        run_in_background: {\r\n          type: 'boolean',\r\n          description: 'Set to true to run this agent in the background. Use TaskOutput to read the output later.',\r\n        },\r\n      },\r\n      required: ['description', 'prompt', 'subagent_type'],\r\n    };\r\n  }\r\n\r\n  async execute(input: AgentInput): Promise<ToolResult> {\r\n    const { description, prompt, subagent_type, model, resume, run_in_background } = input;\r\n\r\n    // 验证代理类型\r\n    const agentDef = getAgentTypeDefinition(subagent_type);\r\n    if (!agentDef) {\r\n      return {\r\n        success: false,\r\n        error: `Unknown agent type: ${subagent_type}. Available types: ${BUILT_IN_AGENT_TYPES.map(d => d.agentType).join(', ')}`,\r\n      };\r\n    }\r\n\r\n    // Resume 模式\r\n    if (resume) {\r\n      return this.resumeAgent(resume, run_in_background);\r\n    }\r\n\r\n    // 新建代理模式\r\n    const agentId = uuidv4();\r\n    const agent: BackgroundAgent = {\r\n      id: agentId,\r\n      agentType: subagent_type,\r\n      description,\r\n      prompt,\r\n      model,\r\n      status: 'running',\r\n      startTime: new Date(),\r\n      history: [],\r\n      intermediateResults: [],\r\n      currentStep: 0,\r\n      workingDirectory: process.cwd(),\r\n      metadata: {},\r\n      messages: [],\r\n    };\r\n\r\n    // 添加启动历史\r\n    addAgentHistory(agent, 'started', `Agent started with type ${subagent_type}`);\r\n\r\n    // 保存到内存和磁盘\r\n    backgroundAgents.set(agentId, agent);\r\n    saveAgentState(agent);\r\n\r\n    if (run_in_background) {\r\n      // 后台执行 - 不阻塞，立即返回\r\n      this.executeAgentInBackground(agent, agentDef);\r\n\r\n      return {\r\n        success: true,\r\n        output: `Agent started in background with ID: ${agentId}\\nUse TaskOutput tool to check progress.`,\r\n      };\r\n    }\r\n\r\n    // 同步执行 - 阻塞直到完成\r\n    const result = await this.executeAgentSync(agent, agentDef);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * 恢复已有代理\r\n   */\r\n  private async resumeAgent(agentId: string, runInBackground?: boolean): Promise<ToolResult> {\r\n    const existingAgent = getBackgroundAgent(agentId);\r\n\r\n    if (!existingAgent) {\r\n      return {\r\n        success: false,\r\n        error: `Agent ${agentId} not found. Unable to resume.`,\r\n      };\r\n    }\r\n\r\n    // 检查代理状态是否可以恢复\r\n    if (existingAgent.status === 'completed') {\r\n      return {\r\n        success: false,\r\n        error: `Agent ${agentId} has already completed. Cannot resume.`,\r\n        output: `Agent result:\\n${JSON.stringify(existingAgent.result, null, 2)}`,\r\n      };\r\n    }\r\n\r\n    if (existingAgent.status === 'running') {\r\n      return {\r\n        success: false,\r\n        error: `Agent ${agentId} is still running. Cannot resume.`,\r\n      };\r\n    }\r\n\r\n    // 恢复代理执行\r\n    existingAgent.status = 'running';\r\n    addAgentHistory(existingAgent, 'resumed', `Agent resumed from step ${existingAgent.currentStep || 0}`);\r\n\r\n    const agentDef = getAgentTypeDefinition(existingAgent.agentType);\r\n    if (!agentDef) {\r\n      return {\r\n        success: false,\r\n        error: `Agent type ${existingAgent.agentType} not found`,\r\n      };\r\n    }\r\n\r\n    const resumeInfo = [\r\n      `Resuming agent ${agentId}`,\r\n      `Type: ${existingAgent.agentType}`,\r\n      `Description: ${existingAgent.description}`,\r\n      `Original prompt: ${existingAgent.prompt}`,\r\n      `Current step: ${existingAgent.currentStep || 0}/${existingAgent.totalSteps || 'unknown'}`,\r\n      `\\nExecution history:`,\r\n      ...existingAgent.history.map(h =>\r\n        `  [${h.timestamp.toISOString()}] ${h.type}: ${h.message}`\r\n      ),\r\n    ];\r\n\r\n    if (existingAgent.intermediateResults.length > 0) {\r\n      resumeInfo.push('\\nIntermediate results:');\r\n      existingAgent.intermediateResults.forEach((result, idx) => {\r\n        resumeInfo.push(`  Step ${idx + 1}: ${JSON.stringify(result).substring(0, 100)}...`);\r\n      });\r\n    }\r\n\r\n    if (runInBackground) {\r\n      // 后台恢复执行\r\n      this.executeAgentInBackground(existingAgent, agentDef);\r\n\r\n      return {\r\n        success: true,\r\n        output: resumeInfo.join('\\n') + '\\n\\nAgent resumed in background.',\r\n      };\r\n    }\r\n\r\n    // 同步恢复执行\r\n    const result = await this.executeAgentSync(existingAgent, agentDef);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * 后台执行代理（异步，不阻塞）\r\n   */\r\n  private executeAgentInBackground(agent: BackgroundAgent, agentDef: AgentTypeDefinition): void {\r\n    // 使用 Promise 在后台执行，捕获错误\r\n    this.executeAgentLoop(agent, agentDef)\r\n      .then(() => {\r\n        // 执行完成\r\n        agent.status = 'completed';\r\n        agent.endTime = new Date();\r\n        addAgentHistory(agent, 'completed', 'Agent completed successfully');\r\n        saveAgentState(agent);\r\n      })\r\n      .catch((error) => {\r\n        // 执行失败\r\n        agent.status = 'failed';\r\n        agent.error = error instanceof Error ? error.message : String(error);\r\n        agent.endTime = new Date();\r\n        addAgentHistory(agent, 'failed', `Agent failed: ${agent.error}`);\r\n        saveAgentState(agent);\r\n      });\r\n  }\r\n\r\n  /**\r\n   * 同步执行代理（阻塞直到完成）\r\n   */\r\n  private async executeAgentSync(agent: BackgroundAgent, agentDef: AgentTypeDefinition): Promise<ToolResult> {\r\n    try {\r\n      await this.executeAgentLoop(agent, agentDef);\r\n\r\n      agent.status = 'completed';\r\n      agent.endTime = new Date();\r\n\r\n      // 构建结果输出\r\n      const duration = (agent.endTime.getTime() - agent.startTime.getTime()) / 1000;\r\n      const output = agent.result?.output || `Agent ${agent.agentType} completed: ${agent.description}`;\r\n\r\n      agent.result = {\r\n        success: true,\r\n        output: `${output}\\n\\n[Agent completed in ${duration.toFixed(1)}s]`,\r\n      };\r\n\r\n      addAgentHistory(agent, 'completed', 'Agent execution completed');\r\n      saveAgentState(agent);\r\n\r\n      return agent.result;\r\n    } catch (error) {\r\n      agent.status = 'failed';\r\n      agent.error = error instanceof Error ? error.message : String(error);\r\n      agent.endTime = new Date();\r\n\r\n      addAgentHistory(agent, 'failed', `Agent failed: ${agent.error}`);\r\n      saveAgentState(agent);\r\n\r\n      return {\r\n        success: false,\r\n        error: `Agent execution failed: ${agent.error}`,\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 真实的代理执行循环（核心逻辑）\r\n   * 参照官方 B4A 函数实现\r\n   */\r\n  private async executeAgentLoop(agent: BackgroundAgent, agentDef: AgentTypeDefinition): Promise<void> {\r\n    // 调用 SubagentStart Hook - 注意参数顺序是 (id, agentType)\r\n    await runSubagentStartHooks(agent.id, agent.agentType);\r\n\r\n    try {\r\n      // 构建代理的初始消息\r\n      let initialMessages: Message[] = [];\r\n\r\n      // 如果代理支持 forkContext，添加父对话历史\r\n      if (agentDef.forkContext && this.parentMessages.length > 0) {\r\n        // 只包含用户和助手的消息，过滤掉工具调用相关内容\r\n        initialMessages = this.parentMessages\r\n          .filter(msg => msg.role === 'user' || msg.role === 'assistant')\r\n          .map(msg => ({\r\n            role: msg.role,\r\n            content: typeof msg.content === 'string' ? msg.content :\r\n                     Array.isArray(msg.content) ? msg.content.filter(block => block.type === 'text') : [],\r\n          }));\r\n      }\r\n\r\n      // 如果是恢复模式，使用已有的消息历史\r\n      if (agent.messages && agent.messages.length > 0) {\r\n        initialMessages = agent.messages;\r\n      }\r\n\r\n      // 添加当前任务提示\r\n      initialMessages.push({\r\n        role: 'user',\r\n        content: agent.prompt,\r\n      });\r\n\r\n      // 解析模型参数，支持 inherit 继承\r\n      const resolvedModel = resolveAgentModel(agent.model, agentDef.model);\r\n\r\n      // 从配置管理器获取完整配置（包括环境变量）\r\n      const { configManager } = await import('../config/index.js');\r\n      const config = configManager.getAll();\r\n\r\n      // 类型断言：确保 TypeScript 正确识别配置类型\r\n      const fallbackModel = config.fallbackModel as string | undefined;\r\n      const debug = config.debug as boolean | undefined;\r\n\r\n      // 构建 LoopOptions\r\n      const loopOptions: LoopOptions = {\r\n        model: resolvedModel,\r\n        maxTurns: 30,  // 限制最大轮次以避免无限循环\r\n        verbose: process.env.CLAUDE_VERBOSE === 'true',\r\n        permissionMode: agentDef.permissionMode || 'default',\r\n        // 根据代理定义限制工具访问\r\n        allowedTools: agentDef.tools,\r\n        workingDir: agent.workingDirectory,\r\n        // 使用代理定义的系统提示词\r\n        systemPrompt: agentDef.getSystemPrompt?.(),\r\n        // 传递 Extended Thinking 配置\r\n        thinking: config.thinking,\r\n        // 传递回退模型配置\r\n        fallbackModel,\r\n        // 传递调试配置\r\n        debug,\r\n      };\r\n\r\n      // 创建子对话循环（动态导入避免循环依赖）\r\n      const { ConversationLoop } = await import('../core/loop.js');\r\n      const loop = new ConversationLoop(loopOptions);\r\n\r\n      // 如果有初始消息上下文（forkContext），需要注入到session中\r\n      if (initialMessages.length > 1) { // >1 因为至少会有当前任务提示\r\n        // 获取session并注入初始消息（除了最后一条当前任务提示）\r\n        const session = loop.getSession();\r\n        const contextMessages = initialMessages.slice(0, -1);\r\n        for (const msg of contextMessages) {\r\n          session.addMessage(msg);\r\n        }\r\n      }\r\n\r\n      // 执行代理任务（使用 streaming API 以支持长时间运行的操作）\r\n      // 根据 Anthropic SDK 要求，超过10分钟的操作必须使用 streaming\r\n      let response = '';\r\n\r\n      // 初始化进度追踪（对齐官方实现）\r\n      if (!agent.progress) {\r\n        agent.progress = {\r\n          toolUseCount: 0,\r\n          tokenCount: 0\r\n        };\r\n      }\r\n\r\n      for await (const event of loop.processMessageStream(agent.prompt)) {\r\n        if (event.type === 'text' && event.content) {\r\n          response += event.content;\r\n          // 更新token计数（粗略估计，1 word ≈ 1.3 tokens）\r\n          agent.progress.tokenCount += Math.ceil(event.content.split(/\\s+/).length * 1.3);\r\n          saveAgentState(agent);\r\n        } else if (event.type === 'tool_start') {\r\n          // 追踪工具使用（对齐官方实现）\r\n          agent.progress.toolUseCount++;\r\n          agent.lastActivity = {\r\n            toolName: event.toolName || 'unknown',\r\n            input: event.toolInput\r\n          };\r\n          saveAgentState(agent);\r\n        } else if (event.type === 'tool_end') {\r\n          // 工具执行完成，更新状态\r\n          saveAgentState(agent);\r\n        } else if (event.type === 'done') {\r\n          // Stream 完成\r\n          break;\r\n        } else if (event.type === 'interrupted') {\r\n          // 如果被中断，记录状态\r\n          throw new Error('Agent execution was interrupted');\r\n        }\r\n      }\r\n\r\n      // 保存结果\r\n      agent.result = {\r\n        success: true,\r\n        output: response,\r\n      };\r\n\r\n      // 保存对话历史以支持恢复\r\n      agent.messages = initialMessages;\r\n\r\n      // 调用 SubagentStop Hook - 注意参数顺序是 (id, agentType, result)\r\n      await runSubagentStopHooks(agent.id, agent.agentType);\r\n\r\n    } catch (error) {\r\n      // 即使失败也要调用 SubagentStop Hook - 注意参数顺序是 (id, agentType, result)\r\n      await runSubagentStopHooks(agent.id, agent.agentType);\r\n\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n\r\nexport class TaskOutputTool extends BaseTool<{ task_id: string; block?: boolean; timeout?: number; show_history?: boolean }, ToolResult> {\r\n  name = 'TaskOutput';\r\n  description = `Get output and status from a background task (Agent or Bash).\r\n\r\nUsage notes:\r\n- Supports both Agent tasks and Bash background shells\r\n- Use block parameter to wait for task completion\r\n- Use show_history to see detailed execution history (Agent only)\r\n- Agent state is automatically persisted and can be resumed`;\r\n\r\n  getInputSchema(): ToolDefinition['inputSchema'] {\r\n    return {\r\n      type: 'object',\r\n      properties: {\r\n        task_id: {\r\n          type: 'string',\r\n          description: 'The task ID to get output from',\r\n        },\r\n        block: {\r\n          type: 'boolean',\r\n          description: 'Whether to wait for completion',\r\n        },\r\n        timeout: {\r\n          type: 'number',\r\n          description: 'Max wait time in ms',\r\n        },\r\n        show_history: {\r\n          type: 'boolean',\r\n          description: 'Show detailed execution history (extension: not in official SDK)',\r\n        },\r\n      },\r\n      required: ['task_id'],\r\n    };\r\n  }\r\n\r\n  async execute(input: { task_id: string; block?: boolean; timeout?: number; show_history?: boolean }): Promise<ToolResult> {\r\n    // 检查是否是 Bash shell ID\r\n    if (isShellId(input.task_id)) {\r\n      const shell = getBackgroundShell(input.task_id);\r\n      if (!shell) {\r\n        return { success: false, error: `Task ${input.task_id} not found` };\r\n      }\r\n\r\n      // 委托给 Bash shell 处理逻辑\r\n      return this.handleBashTask(input.task_id, shell, input.block, input.timeout);\r\n    }\r\n\r\n    // 处理 Agent 任务\r\n    const agent = getBackgroundAgent(input.task_id);\r\n    if (!agent) {\r\n      return { success: false, error: `Task ${input.task_id} not found` };\r\n    }\r\n\r\n    if (input.block && agent.status === 'running') {\r\n      // 等待完成\r\n      const timeout = input.timeout || 5000;\r\n      const startTime = Date.now();\r\n\r\n      while (agent.status === 'running' && Date.now() - startTime < timeout) {\r\n        await new Promise(resolve => setTimeout(resolve, 100));\r\n        // 重新加载代理状态以获取最新进度\r\n        const updatedAgent = getBackgroundAgent(input.task_id);\r\n        if (updatedAgent && updatedAgent.status !== 'running') {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    // 构建输出信息\r\n    const output = [];\r\n    output.push(`=== Agent ${input.task_id} ===`);\r\n    output.push(`Type: ${agent.agentType}`);\r\n    output.push(`Status: ${agent.status}`);\r\n    output.push(`Description: ${agent.description}`);\r\n    output.push(`Started: ${agent.startTime.toISOString()}`);\r\n\r\n    if (agent.endTime) {\r\n      const duration = agent.endTime.getTime() - agent.startTime.getTime();\r\n      output.push(`Ended: ${agent.endTime.toISOString()}`);\r\n      output.push(`Duration: ${(duration / 1000).toFixed(2)}s`);\r\n    }\r\n\r\n    if (agent.currentStep !== undefined && agent.totalSteps !== undefined) {\r\n      output.push(`Progress: ${agent.currentStep}/${agent.totalSteps} steps`);\r\n    }\r\n\r\n    // 显示进度追踪（对齐官方实现）\r\n    if (agent.progress) {\r\n      output.push(`Tools used: ${agent.progress.toolUseCount}`);\r\n      output.push(`Tokens: ${agent.progress.tokenCount}`);\r\n    }\r\n\r\n    if (agent.lastActivity) {\r\n      output.push(`Last tool: ${agent.lastActivity.toolName}`);\r\n    }\r\n\r\n    if (agent.workingDirectory) {\r\n      output.push(`Working Directory: ${agent.workingDirectory}`);\r\n    }\r\n\r\n    // 显示执行历史\r\n    if (input.show_history && agent.history.length > 0) {\r\n      output.push('\\n=== Execution History ===');\r\n      agent.history.forEach((entry, idx) => {\r\n        const timestamp = entry.timestamp.toISOString();\r\n        output.push(`${idx + 1}. [${timestamp}] ${entry.type.toUpperCase()}: ${entry.message}`);\r\n        if (entry.data) {\r\n          output.push(`   Data: ${JSON.stringify(entry.data)}`);\r\n        }\r\n      });\r\n    }\r\n\r\n    // 显示中间结果\r\n    if (agent.intermediateResults.length > 0) {\r\n      output.push('\\n=== Intermediate Results ===');\r\n      agent.intermediateResults.forEach((result, idx) => {\r\n        output.push(`Step ${idx + 1}:`);\r\n        output.push(`  ${JSON.stringify(result, null, 2)}`);\r\n      });\r\n    }\r\n\r\n    // 显示最终结果或错误\r\n    if (agent.status === 'completed' && agent.result) {\r\n      output.push('\\n=== Final Result ===');\r\n      output.push(agent.result.output || 'No output');\r\n    } else if (agent.status === 'failed' && agent.error) {\r\n      output.push('\\n=== Error ===');\r\n      output.push(agent.error);\r\n    } else if (agent.status === 'running') {\r\n      output.push('\\n=== Status ===');\r\n      output.push('Agent is still running. Use block=true to wait for completion.');\r\n      output.push(`Use resume parameter with agent ID ${agent.id} to continue if interrupted.`);\r\n    } else if (agent.status === 'paused') {\r\n      output.push('\\n=== Status ===');\r\n      output.push('Agent is paused.');\r\n      output.push(`Use resume parameter with agent ID ${agent.id} to continue execution.`);\r\n    }\r\n\r\n    return {\r\n      success: true,\r\n      output: output.join('\\n'),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 处理 Bash 后台任务\r\n   */\r\n  private async handleBashTask(\r\n    taskId: string,\r\n    shell: any,\r\n    block?: boolean,\r\n    timeout?: number\r\n  ): Promise<ToolResult> {\r\n    // 如果需要阻塞等待完成\r\n    if (block && shell.status === 'running') {\r\n      const maxTimeout = timeout || 30000;\r\n      const startTime = Date.now();\r\n\r\n      while (shell.status === 'running' && Date.now() - startTime < maxTimeout) {\r\n        await new Promise((resolve) => setTimeout(resolve, 100));\r\n        // 重新获取 shell 状态\r\n        const updatedShell = getBackgroundShell(taskId);\r\n        if (updatedShell && updatedShell.status !== 'running') {\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (shell.status === 'running') {\r\n        // 超时但仍在运行\r\n        return {\r\n          success: true,\r\n          output: `Bash task ${taskId} is still running after ${maxTimeout}ms timeout.\\nUse block=false to check current output without waiting.`,\r\n        };\r\n      }\r\n    }\r\n\r\n    // 构建输出信息\r\n    const output = [];\r\n    output.push(`=== Bash Task ${taskId} ===`);\r\n    output.push(`Command: ${shell.command}`);\r\n    output.push(`Status: ${shell.status}`);\r\n    output.push(`Started: ${new Date(shell.startTime).toISOString()}`);\r\n\r\n    const duration = Date.now() - shell.startTime;\r\n    if (shell.endTime) {\r\n      output.push(`Ended: ${new Date(shell.endTime).toISOString()}`);\r\n      output.push(`Duration: ${((shell.endTime - shell.startTime) / 1000).toFixed(2)}s`);\r\n    } else {\r\n      output.push(`Duration: ${(duration / 1000).toFixed(2)}s (running)`);\r\n    }\r\n\r\n    if (shell.exitCode !== undefined) {\r\n      output.push(`Exit Code: ${shell.exitCode}`);\r\n    }\r\n\r\n    output.push(`Output File: ${shell.outputFile}`);\r\n\r\n    // 读取输出\r\n    const shellOutput = shell.output.join('');\r\n    if (shellOutput.trim()) {\r\n      output.push('\\n=== Output ===');\r\n      output.push(shellOutput);\r\n    } else {\r\n      output.push('\\n=== Output ===');\r\n      output.push('(no output yet)');\r\n    }\r\n\r\n    if (shell.status === 'completed') {\r\n      output.push('\\n=== Status ===');\r\n      output.push('Command completed successfully.');\r\n    } else if (shell.status === 'failed') {\r\n      output.push('\\n=== Status ===');\r\n      output.push(`Command failed with exit code ${shell.exitCode}.`);\r\n    } else if (shell.status === 'running') {\r\n      output.push('\\n=== Status ===');\r\n      output.push('Command is still running. Use block=true to wait for completion.');\r\n    }\r\n\r\n    return {\r\n      success: true,\r\n      output: output.join('\\n'),\r\n    };\r\n  }\r\n}\r\n\r\n"
        }
    ]
}