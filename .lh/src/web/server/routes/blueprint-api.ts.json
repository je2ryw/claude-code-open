{
    "sourceFile": "src/web/server/routes/blueprint-api.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 6,
            "patches": [
                {
                    "date": 1768364953091,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1768365008344,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4243,9 +4243,9 @@\n       undefined,\r\n       '你是一个代码教育专家，擅长用通俗易懂的语言解释复杂的代码。分析代码符号并返回结构化的 JSON 结果。只返回 JSON，不要其他内容。'\r\n     );\r\n     console.log(`[Analyze Symbol] AI 调用耗时: ${Date.now() - t1}ms`);\r\n-\r\n+    console.log(`[Analyze Symbol] AI 输入: ${prompt}`);\r\n     // 提取响应文本\r\n     let analysisText = '';\r\n     for (const block of response.content) {\r\n       if (block.type === 'text') {\r\n"
                },
                {
                    "date": 1768705365942,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,8 +11,11 @@\n \r\n import { Router, Request, Response } from 'express';\r\n import * as path from 'path';\r\n import * as fs from 'fs';\r\n+import * as crypto from 'crypto';\r\n+import * as os from 'os';\r\n+import { spawn } from 'child_process';\r\n import {\r\n   blueprintManager,\r\n   taskTreeManager,\r\n   agentCoordinator,\r\n@@ -22,12 +25,16 @@\n   requirementDialogManager,\r\n } from '../../../blueprint/index.js';\r\n import { timeTravelManager } from '../../../blueprint/time-travel.js';\r\n import { analysisCache } from '../../../blueprint/analysis-cache.js';\r\n+import { architectureGraphCache, type ArchitectureGraphCacheEntry } from '../../../blueprint/architecture-graph-cache.js';\r\n import { CallGraphBuilder } from '../../../map/call-graph-builder.js';\r\n import type { ModuleNode, CallGraphNode, CallGraphEdge } from '../../../map/types.js';\r\n import { classifySymbol, canGenerateCallGraph } from './symbol-classifier.js';\r\n import { calculateTotalLines, groupByDirectory, detectEntryPoints, getCoreSymbols } from './project-map-generator.js';\r\n+import { configManager } from '../../../config/index.js';\r\n+import { getAuth } from '../../../auth/index.js';\r\n+import { TaskManager } from '../task-manager.js';\r\n \r\n const router = Router();\r\n \r\n // ============================================================================\r\n@@ -96,10 +103,12 @@\n  * 创建新蓝图\r\n  */\r\n router.post('/blueprints', (req: Request, res: Response) => {\r\n   try {\r\n-    const { name, description } = req.body;\r\n-    const blueprint = blueprintManager.createBlueprint(name, description);\r\n+    const { name, description, projectPath } = req.body;\r\n+    // 使用请求中的 projectPath，或者当前项目路径，或者当前工作目录\r\n+    const targetPath = projectPath || blueprintManager.getCurrentProjectPath() || process.cwd();\r\n+    const blueprint = blueprintManager.createBlueprint(name, description, targetPath);\r\n     res.json({ success: true, data: blueprint });\r\n   } catch (error: any) {\r\n     res.status(500).json({ success: false, error: error.message });\r\n   }\r\n@@ -167,8 +176,120 @@\n   }\r\n });\r\n \r\n /**\r\n+ * 启动蓝图执行\r\n+ *\r\n+ * 完整的执行流程：\r\n+ * 1. 初始化蜂王 Agent（负责全局协调）\r\n+ * 2. 更新蓝图状态为 executing\r\n+ * 3. 启动主循环开始执行任务\r\n+ */\r\n+router.post('/blueprints/:id/execute', async (req: Request, res: Response) => {\r\n+  try {\r\n+    const blueprintId = req.params.id;\r\n+\r\n+    // 1. 获取蓝图并验证状态\r\n+    const blueprint = blueprintManager.getBlueprint(blueprintId);\r\n+    if (!blueprint) {\r\n+      return res.status(404).json({ success: false, error: '蓝图不存在' });\r\n+    }\r\n+\r\n+    if (blueprint.status !== 'approved') {\r\n+      return res.status(400).json({\r\n+        success: false,\r\n+        error: `无法执行状态为 \"${blueprint.status}\" 的蓝图。蓝图必须先获得批准。`,\r\n+      });\r\n+    }\r\n+\r\n+    // 2. 初始化蜂王 Agent\r\n+    const queen = await agentCoordinator.initializeQueen(blueprintId);\r\n+\r\n+    // 3. 获取或创建任务树\r\n+    let taskTreeId = blueprint.taskTreeId;\r\n+    if (!taskTreeId) {\r\n+      // 如果没有任务树，从蓝图生成一个\r\n+      const taskTree = taskTreeManager.generateFromBlueprint(blueprint);\r\n+      taskTreeId = taskTree.id;\r\n+    }\r\n+\r\n+    // 4. 更新蓝图状态为 executing\r\n+    const updatedBlueprint = blueprintManager.startExecution(blueprintId, taskTreeId);\r\n+\r\n+    // 5. 启动主循环\r\n+    agentCoordinator.startMainLoop();\r\n+\r\n+    res.json({\r\n+      success: true,\r\n+      data: {\r\n+        blueprint: updatedBlueprint,\r\n+        queen: {\r\n+          id: queen.id,\r\n+          status: queen.status,\r\n+          blueprintId: queen.blueprintId,\r\n+          taskTreeId: queen.taskTreeId,\r\n+        },\r\n+        taskTreeId,\r\n+        message: '蓝图执行已启动',\r\n+      },\r\n+    });\r\n+  } catch (error: any) {\r\n+    res.status(500).json({ success: false, error: error.message });\r\n+  }\r\n+});\r\n+\r\n+/**\r\n+ * 暂停蓝图执行\r\n+ */\r\n+router.post('/blueprints/:id/pause', (req: Request, res: Response) => {\r\n+  try {\r\n+    const blueprint = blueprintManager.pauseExecution(req.params.id);\r\n+    agentCoordinator.stopMainLoop();\r\n+    res.json({\r\n+      success: true,\r\n+      data: blueprint,\r\n+      message: '蓝图执行已暂停',\r\n+    });\r\n+  } catch (error: any) {\r\n+    res.status(500).json({ success: false, error: error.message });\r\n+  }\r\n+});\r\n+\r\n+/**\r\n+ * 恢复蓝图执行\r\n+ */\r\n+router.post('/blueprints/:id/resume', (req: Request, res: Response) => {\r\n+  try {\r\n+    const blueprint = blueprintManager.resumeExecution(req.params.id);\r\n+    agentCoordinator.startMainLoop();\r\n+    res.json({\r\n+      success: true,\r\n+      data: blueprint,\r\n+      message: '蓝图执行已恢复',\r\n+    });\r\n+  } catch (error: any) {\r\n+    res.status(500).json({ success: false, error: error.message });\r\n+  }\r\n+});\r\n+\r\n+/**\r\n+ * 停止蓝图执行（完成）\r\n+ */\r\n+router.post('/blueprints/:id/complete', (req: Request, res: Response) => {\r\n+  try {\r\n+    const blueprint = blueprintManager.completeExecution(req.params.id);\r\n+    agentCoordinator.stopMainLoop();\r\n+    res.json({\r\n+      success: true,\r\n+      data: blueprint,\r\n+      message: '蓝图执行已完成',\r\n+    });\r\n+  } catch (error: any) {\r\n+    res.status(500).json({ success: false, error: error.message });\r\n+  }\r\n+});\r\n+\r\n+/**\r\n  * 删除蓝图\r\n  */\r\n router.delete('/blueprints/:id', (req: Request, res: Response) => {\r\n   try {\r\n@@ -506,14 +627,15 @@\n     if (!filePath) {\r\n       return res.status(400).json({ success: false, error: '缺少文件路径参数' });\r\n     }\r\n \r\n-    const absolutePath = path.resolve(process.cwd(), filePath);\r\n+    // 支持绝对路径和相对路径\r\n+    const isAbsolutePath = path.isAbsolute(filePath);\r\n+    const absolutePath = isAbsolutePath ? filePath : path.resolve(process.cwd(), filePath);\r\n \r\n-    // 安全检查：确保路径在项目目录内\r\n-    const cwd = process.cwd();\r\n-    if (!absolutePath.startsWith(cwd)) {\r\n-      return res.status(403).json({ success: false, error: '禁止访问项目目录外的文件' });\r\n+    // 安全检查：使用 isPathSafeForFileTree 函数检查路径（与 file-tree API 保持一致）\r\n+    if (!isPathSafeForFileTree(absolutePath)) {\r\n+      return res.status(403).json({ success: false, error: '禁止访问系统目录' });\r\n     }\r\n \r\n     // 检查文件是否存在\r\n     if (!fs.existsSync(absolutePath)) {\r\n@@ -593,14 +715,15 @@\n     if (typeof content !== 'string') {\r\n       return res.status(400).json({ success: false, error: '内容必须是字符串' });\r\n     }\r\n \r\n-    const absolutePath = path.resolve(process.cwd(), filePath);\r\n+    // 支持绝对路径和相对路径\r\n+    const isAbsolutePath = path.isAbsolute(filePath);\r\n+    const absolutePath = isAbsolutePath ? filePath : path.resolve(process.cwd(), filePath);\r\n \r\n-    // 安全检查：确保路径在项目目录内\r\n-    const cwd = process.cwd();\r\n-    if (!absolutePath.startsWith(cwd)) {\r\n-      return res.status(403).json({ success: false, error: '禁止修改项目目录外的文件' });\r\n+    // 安全检查：使用 isPathSafeForFileTree 函数检查路径（与 file-tree API 保持一致）\r\n+    if (!isPathSafeForFileTree(absolutePath)) {\r\n+      return res.status(403).json({ success: false, error: '禁止修改系统目录文件' });\r\n     }\r\n \r\n     // 检查文件是否存在\r\n     if (!fs.existsSync(absolutePath)) {\r\n@@ -628,31 +751,63 @@\n });\r\n \r\n /**\r\n  * 获取目录树结构\r\n+ *\r\n+ * 支持两种模式：\r\n+ * 1. 相对路径模式：root=src（相对于当前工作目录）\r\n+ * 2. 绝对路径模式：root=C:\\Users\\xxx\\project 或 root=/home/user/project\r\n+ *\r\n+ * 安全检查：\r\n+ * - 禁止访问系统目录（Windows: C:\\Windows, C:\\Program Files 等；Unix: /bin, /etc 等）\r\n+ * - 禁止访问根目录\r\n  */\r\n router.get('/file-tree', (req: Request, res: Response) => {\r\n   try {\r\n     const root = (req.query.root as string) || 'src';\r\n-    const absoluteRoot = path.resolve(process.cwd(), root);\r\n \r\n+    // 判断是否是绝对路径\r\n+    const isAbsolutePath = path.isAbsolute(root);\r\n+    const absoluteRoot = isAbsolutePath ? root : path.resolve(process.cwd(), root);\r\n+\r\n+    // 安全检查：使用 isPathSafeForFileTree 函数检查路径\r\n+    if (!isPathSafeForFileTree(absoluteRoot)) {\r\n+      return res.status(403).json({\r\n+        success: false,\r\n+        error: '禁止访问系统目录或根目录',\r\n+      });\r\n+    }\r\n+\r\n     // 检查目录是否存在\r\n     if (!fs.existsSync(absoluteRoot)) {\r\n       return res.status(404).json({\r\n         success: false,\r\n         error: `目录不存在: ${root}`,\r\n       });\r\n     }\r\n \r\n+    // 检查是否是目录\r\n+    if (!fs.statSync(absoluteRoot).isDirectory()) {\r\n+      return res.status(400).json({\r\n+        success: false,\r\n+        error: `路径不是目录: ${root}`,\r\n+      });\r\n+    }\r\n+\r\n     // 递归构建文件树\r\n+    // 对于绝对路径，使用绝对路径作为 path 属性\r\n+    // 对于相对路径，使用相对路径作为 path 属性\r\n     const buildTree = (dirPath: string, relativePath: string): FileTreeNode => {\r\n       const name = path.basename(dirPath);\r\n       const stats = fs.statSync(dirPath);\r\n \r\n+      // 计算返回的路径：如果是绝对路径模式，返回绝对路径；否则返回相对路径\r\n+      const returnPath = isAbsolutePath ? dirPath : relativePath;\r\n+\r\n       if (stats.isFile()) {\r\n         return {\r\n           name,\r\n-          path: relativePath,\r\n+          path: returnPath,\r\n           type: 'file',\r\n         };\r\n       }\r\n \r\n@@ -683,9 +838,9 @@\n         });\r\n \r\n       return {\r\n         name,\r\n-        path: relativePath || name,\r\n+        path: returnPath || name,\r\n         type: 'directory',\r\n         children,\r\n       };\r\n     };\r\n@@ -694,16 +849,79 @@\n \r\n     res.json({\r\n       success: true,\r\n       data: tree,\r\n+      // 返回额外信息，方便前端判断\r\n+      meta: {\r\n+        isAbsolutePath,\r\n+        absoluteRoot,\r\n+        projectName: path.basename(absoluteRoot),\r\n+      },\r\n     });\r\n   } catch (error: any) {\r\n     console.error('[File Tree Error]', error);\r\n     res.status(500).json({ success: false, error: error.message });\r\n   }\r\n });\r\n \r\n /**\r\n+ * 检查路径是否安全（用于 file-tree API）\r\n+ * 这个函数与 isPathSafe 类似，但针对 file-tree 场景做了优化\r\n+ */\r\n+function isPathSafeForFileTree(targetPath: string): boolean {\r\n+  const normalizedPath = path.normalize(targetPath).toLowerCase();\r\n+  const homeDir = os.homedir().toLowerCase();\r\n+\r\n+  // Windows 系统目录黑名单\r\n+  const windowsUnsafePaths = [\r\n+    'c:\\\\windows',\r\n+    'c:\\\\program files',\r\n+    'c:\\\\program files (x86)',\r\n+    'c:\\\\programdata',\r\n+    'c:\\\\$recycle.bin',\r\n+    'c:\\\\system volume information',\r\n+    'c:\\\\recovery',\r\n+    'c:\\\\boot',\r\n+  ];\r\n+\r\n+  // Unix 系统目录黑名单\r\n+  const unixUnsafePaths = [\r\n+    '/bin',\r\n+    '/sbin',\r\n+    '/usr/bin',\r\n+    '/usr/sbin',\r\n+    '/usr/local/bin',\r\n+    '/usr/local/sbin',\r\n+    '/etc',\r\n+    '/var',\r\n+    '/root',\r\n+    '/boot',\r\n+    '/lib',\r\n+    '/lib64',\r\n+    '/proc',\r\n+    '/sys',\r\n+    '/dev',\r\n+    '/run',\r\n+  ];\r\n+\r\n+  // 检查是否是系统目录\r\n+  const unsafePaths = process.platform === 'win32' ? windowsUnsafePaths : unixUnsafePaths;\r\n+\r\n+  for (const unsafePath of unsafePaths) {\r\n+    if (normalizedPath === unsafePath || normalizedPath.startsWith(unsafePath + path.sep)) {\r\n+      return false;\r\n+    }\r\n+  }\r\n+\r\n+  // 不允许访问根目录\r\n+  if (normalizedPath === '/' || normalizedPath === 'c:\\\\' || /^[a-z]:\\\\?$/i.test(normalizedPath)) {\r\n+    return false;\r\n+  }\r\n+\r\n+  return true;\r\n+}\r\n+\r\n+/**\r\n  * 获取模块内部文件列表\r\n  * GET /api/blueprint/module-files?path=src/core\r\n  *\r\n  * 返回模块目录下的所有文件（带语言、行数等信息）\r\n@@ -1697,8 +1915,59 @@\n     res.status(500).json({ success: false, error: error.message });\r\n   }\r\n });\r\n \r\n+/**\r\n+ * 转换到指定阶段\r\n+ */\r\n+router.post('/tdd/:taskId/phase-transition', (req: Request, res: Response) => {\r\n+  try {\r\n+    const { taskId } = req.params;\r\n+    const { phase } = req.body;\r\n+\r\n+    if (!phase) {\r\n+      return res.status(400).json({ success: false, error: '缺少 phase 参数' });\r\n+    }\r\n+\r\n+    // 验证 phase 是否有效\r\n+    const validPhases = ['write_test', 'run_test_red', 'write_code', 'run_test_green', 'refactor'];\r\n+    if (!validPhases.includes(phase)) {\r\n+      return res.status(400).json({ success: false, error: `无效的阶段: ${phase}` });\r\n+    }\r\n+\r\n+    const state = tddExecutor.manualTransitionPhase(taskId, phase);\r\n+    res.json({ success: true, data: state });\r\n+  } catch (error: any) {\r\n+    res.status(500).json({ success: false, error: error.message });\r\n+  }\r\n+});\r\n+\r\n+/**\r\n+ * 标记当前阶段完成，自动转换到下一阶段\r\n+ */\r\n+router.post('/tdd/:taskId/mark-complete', (req: Request, res: Response) => {\r\n+  try {\r\n+    const { taskId } = req.params;\r\n+    const state = tddExecutor.markPhaseComplete(taskId);\r\n+    res.json({ success: true, data: state });\r\n+  } catch (error: any) {\r\n+    res.status(500).json({ success: false, error: error.message });\r\n+  }\r\n+});\r\n+\r\n+/**\r\n+ * 回退到上一阶段\r\n+ */\r\n+router.post('/tdd/:taskId/revert-phase', (req: Request, res: Response) => {\r\n+  try {\r\n+    const { taskId } = req.params;\r\n+    const state = tddExecutor.revertPhase(taskId);\r\n+    res.json({ success: true, data: state });\r\n+  } catch (error: any) {\r\n+    res.status(500).json({ success: false, error: error.message });\r\n+  }\r\n+});\r\n+\r\n // ============================================================================\r\n // 时光倒流 API\r\n // ============================================================================\r\n \r\n@@ -1923,8 +2192,65 @@\n     res.status(500).json({ success: false, error: error.message });\r\n   }\r\n });\r\n \r\n+/**\r\n+ * 获取对话摘要\r\n+ * GET /api/blueprint/requirement-dialog/:sessionId/summary\r\n+ */\r\n+router.get('/requirement-dialog/:sessionId/summary', (req: Request, res: Response) => {\r\n+  try {\r\n+    const { sessionId } = req.params;\r\n+    const state = requirementDialogManager.getDialogState(sessionId);\r\n+\r\n+    if (!state) {\r\n+      return res.status(404).json({\r\n+        success: false,\r\n+        error: 'Dialog session not found',\r\n+      });\r\n+    }\r\n+\r\n+    // 生成对话摘要\r\n+    const summary = {\r\n+      sessionId: state.id,\r\n+      phase: state.phase,\r\n+      projectName: state.projectName,\r\n+      projectDescription: state.projectDescription,\r\n+      targetUsers: state.targetUsers,\r\n+      problemsToSolve: state.problemsToSolve,\r\n+      businessProcessCount: state.businessProcesses.length,\r\n+      moduleCount: state.modules.length,\r\n+      nfrCount: state.nfrs.length,\r\n+      messageCount: state.history.length,\r\n+      createdAt: state.createdAt,\r\n+      updatedAt: state.updatedAt,\r\n+      // 详细数据\r\n+      businessProcesses: state.businessProcesses.map(p => ({\r\n+        name: p.name,\r\n+        type: p.type,\r\n+        stepsCount: p.steps.length,\r\n+      })),\r\n+      modules: state.modules.map(m => ({\r\n+        name: m.name,\r\n+        type: m.type,\r\n+        responsibilitiesCount: m.responsibilities.length,\r\n+      })),\r\n+      nfrs: state.nfrs.map(n => ({\r\n+        name: n.name,\r\n+        category: n.category,\r\n+        priority: n.priority,\r\n+      })),\r\n+    };\r\n+\r\n+    res.json({\r\n+      success: true,\r\n+      data: summary,\r\n+    });\r\n+  } catch (error: any) {\r\n+    res.status(500).json({ success: false, error: error.message });\r\n+  }\r\n+});\r\n+\r\n // ============================================================================\r\n // 时光倒流 API\r\n // ============================================================================\r\n \r\n@@ -2003,24 +2329,8 @@\n   }\r\n });\r\n \r\n /**\r\n- * 回滚到检查点\r\n- */\r\n-router.post('/time-travel/:treeId/rollback', (req: Request, res: Response) => {\r\n-  try {\r\n-    const { treeId } = req.params;\r\n-    const { checkpointId } = req.body;\r\n-\r\n-    timeTravelManager.rollback(treeId, checkpointId);\r\n-\r\n-    res.json({ success: true, message: 'Rollback successful' });\r\n-  } catch (error: any) {\r\n-    res.status(500).json({ success: false, error: error.message });\r\n-  }\r\n-});\r\n-\r\n-/**\r\n  * 创建分支\r\n  */\r\n router.post('/time-travel/:treeId/branches', (req: Request, res: Response) => {\r\n   try {\r\n@@ -3869,8 +4179,16 @@\n   analyzeBusinessDomains,\r\n   analyzeKeyProcesses,\r\n   analyzeImplementation,\r\n   generateAIAnnotation,\r\n+  // 带缓存状态的分析函数\r\n+  analyzeProjectIntentWithCache,\r\n+  analyzeBusinessDomainsWithCache,\r\n+  analyzeKeyProcessesWithCache,\r\n+  analyzeImplementationWithCache,\r\n+  // 标注更新函数\r\n+  updateAnnotation,\r\n+  getUserAnnotation,\r\n } from './onion-analyzer.js';\r\n import { OnionLayer } from '../../shared/onion-types.js';\r\n \r\n /**\r\n@@ -3924,31 +4242,45 @@\n     }\r\n \r\n     console.log(`[Onion API] 请求层级 ${layer}，nodeId: ${nodeId || context?.nodeId || '无'}`);\r\n \r\n+    // 使用带缓存状态的分析函数，追踪数据是否来自缓存\r\n+    let fromCache = false;\r\n \r\n     switch (layer) {\r\n-      case OnionLayer.PROJECT_INTENT:\r\n-        data = await analyzeProjectIntent(projectRoot);\r\n+      case OnionLayer.PROJECT_INTENT: {\r\n+        const result = await analyzeProjectIntentWithCache(projectRoot);\r\n+        data = result.data;\r\n+        fromCache = result.fromCache;\r\n         break;\r\n+      }\r\n \r\n-      case OnionLayer.BUSINESS_DOMAIN:\r\n-        data = await analyzeBusinessDomains(projectRoot);\r\n+      case OnionLayer.BUSINESS_DOMAIN: {\r\n+        const result = await analyzeBusinessDomainsWithCache(projectRoot);\r\n+        data = result.data;\r\n+        fromCache = result.fromCache;\r\n         break;\r\n+      }\r\n \r\n-      case OnionLayer.KEY_PROCESS:\r\n-        data = await analyzeKeyProcesses(projectRoot, context?.nodeId, forceRefresh);\r\n+      case OnionLayer.KEY_PROCESS: {\r\n+        const result = await analyzeKeyProcessesWithCache(projectRoot, context?.nodeId, forceRefresh);\r\n+        data = result.data;\r\n+        fromCache = result.fromCache;\r\n         break;\r\n+      }\r\n \r\n-      case OnionLayer.IMPLEMENTATION:\r\n+      case OnionLayer.IMPLEMENTATION: {\r\n         if (!filePath) {\r\n           return res.status(400).json({\r\n             success: false,\r\n             error: '第四层需要提供 filePath 参数',\r\n           });\r\n         }\r\n-        data = await analyzeImplementation(projectRoot, filePath, symbolId);\r\n+        const result = await analyzeImplementationWithCache(projectRoot, filePath, symbolId);\r\n+        data = result.data;\r\n+        fromCache = result.fromCache;\r\n         break;\r\n+      }\r\n     }\r\n \r\n     // 如果启用 AI 分析，且 annotation.keyPoints 包含占位符，则触发 AI 分析\r\n     if (enableAI && data?.annotation) {\r\n@@ -3996,9 +4328,9 @@\n       success: true,\r\n       layer,\r\n       data,\r\n       analysisTime,\r\n-      fromCache: false, // TODO: 从分析器返回缓存状态\r\n+      fromCache, // 从分析器返回的缓存状态\r\n     });\r\n   } catch (error: any) {\r\n     console.error('[Onion API] 层级数据获取错误:', error);\r\n     res.status(500).json({\r\n@@ -4095,15 +4427,53 @@\n   try {\r\n     const { annotationId } = req.params;\r\n     const { summary, description, keyPoints } = req.body;\r\n \r\n-    // TODO: 实现标注更新和持久化\r\n-    // 目前返回模拟成功\r\n+    // 参数校验\r\n+    if (!annotationId) {\r\n+      return res.status(400).json({\r\n+        success: false,\r\n+        error: '缺少 annotationId 参数',\r\n+      });\r\n+    }\r\n \r\n+    // 至少需要一个更新字段\r\n+    if (summary === undefined && description === undefined && keyPoints === undefined) {\r\n+      return res.status(400).json({\r\n+        success: false,\r\n+        error: '请提供至少一个要更新的字段（summary, description, keyPoints）',\r\n+      });\r\n+    }\r\n+\r\n+    // 校验 keyPoints 格式\r\n+    if (keyPoints !== undefined && !Array.isArray(keyPoints)) {\r\n+      return res.status(400).json({\r\n+        success: false,\r\n+        error: 'keyPoints 必须是字符串数组',\r\n+      });\r\n+    }\r\n+\r\n+    // 调用 updateAnnotation 更新标注并持久化到 ~/.claude/annotations.json\r\n+    const updatedAnnotation = updateAnnotation(annotationId, {\r\n+      summary,\r\n+      description,\r\n+      keyPoints,\r\n+    });\r\n+\r\n+    if (!updatedAnnotation) {\r\n+      return res.status(404).json({\r\n+        success: false,\r\n+        error: `未找到标注: ${annotationId}`,\r\n+      });\r\n+    }\r\n+\r\n+    console.log(`[Onion API] 标注更新成功: ${annotationId}`);\r\n+\r\n     res.json({\r\n       success: true,\r\n-      message: '标注已更新',\r\n+      message: '标注已更新并持久化',\r\n       annotationId,\r\n+      annotation: updatedAnnotation,\r\n     });\r\n   } catch (error: any) {\r\n     console.error('[Onion API] 标注更新错误:', error);\r\n     res.status(500).json({\r\n@@ -4197,10 +4567,10 @@\n     const externalReferences = analyzeExternalReferences(filePath, symbolName);\r\n     console.log(`[Analyze Symbol] analyzeExternalReferences 耗时: ${Date.now() - t1}ms, 找到 ${externalReferences.length} 个引用`);\r\n \r\n     // 获取 AI 客户端 - 使用 Haiku 模型加速简单分析\r\n-    const { ClaudeClient } = await import('../../../core/client.js');\r\n-    const client = new ClaudeClient({ model: 'haiku' });\r\n+    const { createClientWithModel } = await import('../../../core/client.js');\r\n+    const client = createClientWithModel('haiku');\r\n \r\n     // 构建分析提示\r\n     const prompt = `请分析以下代码符号并生成语义分析报告。\r\n \r\n@@ -4412,5 +4782,2096 @@\n \r\n   return references.slice(0, 5); // 最多返回 5 个引用\r\n }\r\n \r\n+// ============================================================================\r\n+// 项目管理 API\r\n+// ============================================================================\r\n+\r\n+/**\r\n+ * 最近打开的项目接口\r\n+ */\r\n+interface RecentProject {\r\n+  id: string;           // 唯一ID（用路径hash）\r\n+  path: string;         // 绝对路径\r\n+  name: string;         // 项目名（目录名）\r\n+  lastOpenedAt: string; // 最后打开时间\r\n+}\r\n+\r\n+/**\r\n+ * 获取 Claude 配置目录路径\r\n+ * 支持 Windows 和 Unix 系统\r\n+ */\r\n+function getClaudeConfigDir(): string {\r\n+  const homeDir = os.homedir();\r\n+  return path.join(homeDir, '.claude');\r\n+}\r\n+\r\n+/**\r\n+ * 获取最近项目列表的存储路径\r\n+ */\r\n+function getRecentProjectsPath(): string {\r\n+  return path.join(getClaudeConfigDir(), 'recent-projects.json');\r\n+}\r\n+\r\n+/**\r\n+ * 生成路径的唯一 ID（使用 MD5 hash）\r\n+ */\r\n+function generateProjectId(projectPath: string): string {\r\n+  const normalizedPath = path.normalize(projectPath).toLowerCase();\r\n+  return crypto.createHash('md5').update(normalizedPath).digest('hex').substring(0, 12);\r\n+}\r\n+\r\n+/**\r\n+ * 读取最近打开的项目列表\r\n+ */\r\n+function loadRecentProjects(): RecentProject[] {\r\n+  try {\r\n+    const filePath = getRecentProjectsPath();\r\n+    if (!fs.existsSync(filePath)) {\r\n+      return [];\r\n+    }\r\n+    const content = fs.readFileSync(filePath, 'utf-8');\r\n+    return JSON.parse(content) as RecentProject[];\r\n+  } catch (error) {\r\n+    console.error('[Recent Projects] 读取失败:', error);\r\n+    return [];\r\n+  }\r\n+}\r\n+\r\n+/**\r\n+ * 保存最近打开的项目列表\r\n+ */\r\n+function saveRecentProjects(projects: RecentProject[]): void {\r\n+  try {\r\n+    const configDir = getClaudeConfigDir();\r\n+    // 确保配置目录存在\r\n+    if (!fs.existsSync(configDir)) {\r\n+      fs.mkdirSync(configDir, { recursive: true });\r\n+    }\r\n+    const filePath = getRecentProjectsPath();\r\n+    fs.writeFileSync(filePath, JSON.stringify(projects, null, 2), 'utf-8');\r\n+  } catch (error) {\r\n+    console.error('[Recent Projects] 保存失败:', error);\r\n+    throw error;\r\n+  }\r\n+}\r\n+\r\n+/**\r\n+ * GET /api/blueprint/projects\r\n+ * 获取最近打开的项目列表\r\n+ */\r\n+router.get('/projects', (req: Request, res: Response) => {\r\n+  try {\r\n+    const projects = loadRecentProjects();\r\n+    // 按最后打开时间倒序排列\r\n+    projects.sort((a, b) => new Date(b.lastOpenedAt).getTime() - new Date(a.lastOpenedAt).getTime());\r\n+    res.json({\r\n+      success: true,\r\n+      data: projects,\r\n+      total: projects.length,\r\n+    });\r\n+  } catch (error: any) {\r\n+    console.error('[GET /projects]', error);\r\n+    res.status(500).json({ success: false, error: error.message });\r\n+  }\r\n+});\r\n+\r\n+/**\r\n+ * POST /api/blueprint/projects/open\r\n+ * 打开项目（添加到最近项目列表）\r\n+ *\r\n+ * 关键变更：同时切换蓝图上下文，实现蓝图与项目 1:1 绑定\r\n+ */\r\n+router.post('/projects/open', (req: Request, res: Response) => {\r\n+  try {\r\n+    const { path: projectPath } = req.body;\r\n+\r\n+    if (!projectPath) {\r\n+      return res.status(400).json({\r\n+        success: false,\r\n+        error: '缺少 path 参数',\r\n+      });\r\n+    }\r\n+\r\n+    // 验证路径是绝对路径\r\n+    if (!path.isAbsolute(projectPath)) {\r\n+      return res.status(400).json({\r\n+        success: false,\r\n+        error: '必须提供绝对路径',\r\n+      });\r\n+    }\r\n+\r\n+    // 检查路径是否存在\r\n+    if (!fs.existsSync(projectPath)) {\r\n+      return res.status(404).json({\r\n+        success: false,\r\n+        error: `路径不存在: ${projectPath}`,\r\n+      });\r\n+    }\r\n+\r\n+    // 检查是否是目录\r\n+    if (!fs.statSync(projectPath).isDirectory()) {\r\n+      return res.status(400).json({\r\n+        success: false,\r\n+        error: '路径必须是目录',\r\n+      });\r\n+    }\r\n+\r\n+    // 安全检查：禁止打开系统目录\r\n+    if (!isPathSafe(projectPath)) {\r\n+      return res.status(403).json({\r\n+        success: false,\r\n+        error: '禁止访问系统目录',\r\n+      });\r\n+    }\r\n+\r\n+    const projects = loadRecentProjects();\r\n+    const projectId = generateProjectId(projectPath);\r\n+\r\n+    // 检查是否已存在\r\n+    const existingIndex = projects.findIndex(p => p.id === projectId);\r\n+    const newProject: RecentProject = {\r\n+      id: projectId,\r\n+      path: projectPath,\r\n+      name: path.basename(projectPath),\r\n+      lastOpenedAt: new Date().toISOString(),\r\n+    };\r\n+\r\n+    if (existingIndex >= 0) {\r\n+      // 更新现有项目的最后打开时间\r\n+      projects[existingIndex] = newProject;\r\n+    } else {\r\n+      // 添加新项目到列表开头\r\n+      projects.unshift(newProject);\r\n+      // 限制最多保存 50 个最近项目\r\n+      if (projects.length > 50) {\r\n+        projects.pop();\r\n+      }\r\n+    }\r\n+\r\n+    saveRecentProjects(projects);\r\n+\r\n+    // 切换蓝图上下文：实现蓝图与项目 1:1 绑定\r\n+    const currentBlueprint = blueprintManager.setProject(projectPath);\r\n+\r\n+    res.json({\r\n+      success: true,\r\n+      data: {\r\n+        ...newProject,\r\n+        // 返回该项目关联的蓝图信息（如果有）\r\n+        blueprint: currentBlueprint ? {\r\n+          id: currentBlueprint.id,\r\n+          name: currentBlueprint.name,\r\n+          status: currentBlueprint.status,\r\n+          version: currentBlueprint.version,\r\n+        } : null,\r\n+      },\r\n+    });\r\n+  } catch (error: any) {\r\n+    console.error('[POST /projects/open]', error);\r\n+    res.status(500).json({ success: false, error: error.message });\r\n+  }\r\n+});\r\n+\r\n+/**\r\n+ * POST /api/blueprint/projects/browse\r\n+ * 打开系统原生的文件夹选择对话框\r\n+ */\r\n+router.post('/projects/browse', async (req: Request, res: Response) => {\r\n+  try {\r\n+    const platform = os.platform();\r\n+    let cmd: string;\r\n+    let args: string[];\r\n+\r\n+    if (platform === 'win32') {\r\n+      // Windows: 使用 PowerShell 打开文件夹选择对话框\r\n+      const psScript = `\r\n+Add-Type -AssemblyName System.Windows.Forms\r\n+$dialog = New-Object System.Windows.Forms.FolderBrowserDialog\r\n+$dialog.Description = \"选择项目文件夹\"\r\n+$dialog.ShowNewFolderButton = $true\r\n+if ($dialog.ShowDialog() -eq [System.Windows.Forms.DialogResult]::OK) {\r\n+  Write-Output $dialog.SelectedPath\r\n+}\r\n+`;\r\n+      cmd = 'powershell';\r\n+      args = ['-NoProfile', '-NonInteractive', '-Command', psScript];\r\n+    } else if (platform === 'darwin') {\r\n+      // macOS: 使用 osascript 打开文件夹选择对话框\r\n+      cmd = 'osascript';\r\n+      args = ['-e', 'POSIX path of (choose folder with prompt \"选择项目文件夹\")'];\r\n+    } else {\r\n+      // Linux: 使用 zenity\r\n+      cmd = 'zenity';\r\n+      args = ['--file-selection', '--directory', '--title=选择项目文件夹'];\r\n+    }\r\n+\r\n+    const child = spawn(cmd, args, { stdio: ['ignore', 'pipe', 'pipe'] });\r\n+\r\n+    let stdout = '';\r\n+    let stderr = '';\r\n+\r\n+    child.stdout.on('data', (data) => {\r\n+      stdout += data.toString();\r\n+    });\r\n+\r\n+    child.stderr.on('data', (data) => {\r\n+      stderr += data.toString();\r\n+    });\r\n+\r\n+    child.on('close', (code) => {\r\n+      // 用户取消选择（code 1 或空输出）\r\n+      if (code === 1 || !stdout.trim()) {\r\n+        return res.json({\r\n+          success: true,\r\n+          data: { path: null, cancelled: true },\r\n+        });\r\n+      }\r\n+\r\n+      if (code !== 0) {\r\n+        console.error('[POST /projects/browse] process error:', stderr);\r\n+        return res.status(500).json({\r\n+          success: false,\r\n+          error: '无法打开文件夹选择对话框',\r\n+        });\r\n+      }\r\n+\r\n+      const selectedPath = stdout.trim();\r\n+\r\n+      // 验证路径是否存在且是目录\r\n+      if (!fs.existsSync(selectedPath) || !fs.statSync(selectedPath).isDirectory()) {\r\n+        return res.status(400).json({\r\n+          success: false,\r\n+          error: '选择的路径无效',\r\n+        });\r\n+      }\r\n+\r\n+      res.json({\r\n+        success: true,\r\n+        data: { path: selectedPath, cancelled: false },\r\n+      });\r\n+    });\r\n+\r\n+    child.on('error', (error) => {\r\n+      console.error('[POST /projects/browse] spawn error:', error);\r\n+      res.status(500).json({\r\n+        success: false,\r\n+        error: '无法启动文件夹选择对话框',\r\n+      });\r\n+    });\r\n+  } catch (error: any) {\r\n+    console.error('[POST /projects/browse]', error);\r\n+    res.status(500).json({ success: false, error: error.message });\r\n+  }\r\n+});\r\n+\r\n+/**\r\n+ * DELETE /api/blueprint/projects/:id\r\n+ * 从最近项目列表中移除\r\n+ */\r\n+router.delete('/projects/:id', (req: Request, res: Response) => {\r\n+  try {\r\n+    const { id } = req.params;\r\n+    const projects = loadRecentProjects();\r\n+    const index = projects.findIndex(p => p.id === id);\r\n+\r\n+    if (index < 0) {\r\n+      return res.status(404).json({\r\n+        success: false,\r\n+        error: '项目不存在',\r\n+      });\r\n+    }\r\n+\r\n+    const removedProject = projects.splice(index, 1)[0];\r\n+    saveRecentProjects(projects);\r\n+\r\n+    res.json({\r\n+      success: true,\r\n+      message: `项目 \"${removedProject.name}\" 已从列表中移除`,\r\n+      data: removedProject,\r\n+    });\r\n+  } catch (error: any) {\r\n+    console.error('[DELETE /projects/:id]', error);\r\n+    res.status(500).json({ success: false, error: error.message });\r\n+  }\r\n+});\r\n+\r\n+/**\r\n+ * GET /api/blueprint/projects/current\r\n+ * 获取当前工作目录的项目信息\r\n+ */\r\n+router.get('/projects/current', (req: Request, res: Response) => {\r\n+  try {\r\n+    const currentPath = process.cwd();\r\n+    const projects = loadRecentProjects();\r\n+    const currentProject = projects.find(p => p.path === currentPath);\r\n+\r\n+    if (currentProject) {\r\n+      res.json({ success: true, data: currentProject });\r\n+    } else {\r\n+      // 如果不在列表中，创建一个临时项目信息\r\n+      const projectId = generateProjectId(currentPath);\r\n+      res.json({\r\n+        success: true,\r\n+        data: {\r\n+          id: projectId,\r\n+          name: path.basename(currentPath),\r\n+          path: currentPath,\r\n+          lastOpenedAt: new Date().toISOString(),\r\n+        },\r\n+      });\r\n+    }\r\n+  } catch (error: any) {\r\n+    console.error('[GET /projects/current]', error);\r\n+    res.status(500).json({ success: false, error: error.message });\r\n+  }\r\n+});\r\n+\r\n+/**\r\n+ * GET /api/blueprint/projects/cwd\r\n+ * 获取当前工作目录（/projects/current 的别名）\r\n+ */\r\n+router.get('/projects/cwd', (req: Request, res: Response) => {\r\n+  try {\r\n+    const currentPath = process.cwd();\r\n+    res.json({\r\n+      success: true,\r\n+      data: {\r\n+        path: currentPath,\r\n+        name: path.basename(currentPath),\r\n+      },\r\n+    });\r\n+  } catch (error: any) {\r\n+    console.error('[GET /projects/cwd]', error);\r\n+    res.status(500).json({ success: false, error: error.message });\r\n+  }\r\n+});\r\n+\r\n+// ============================================================================\r\n+// 安全检查函数\r\n+// ============================================================================\r\n+\r\n+/**\r\n+ * 检查路径是否安全（不是系统目录）\r\n+ * 返回 true 表示安全，可以访问\r\n+ */\r\n+function isPathSafe(targetPath: string): boolean {\r\n+  const normalizedPath = path.normalize(targetPath).toLowerCase();\r\n+  const homeDir = os.homedir().toLowerCase();\r\n+\r\n+  // Windows 系统目录黑名单\r\n+  const windowsUnsafePaths = [\r\n+    'c:\\\\windows',\r\n+    'c:\\\\program files',\r\n+    'c:\\\\program files (x86)',\r\n+    'c:\\\\programdata',\r\n+    'c:\\\\$recycle.bin',\r\n+    'c:\\\\system volume information',\r\n+    'c:\\\\recovery',\r\n+    'c:\\\\boot',\r\n+  ];\r\n+\r\n+  // Unix 系统目录黑名单\r\n+  const unixUnsafePaths = [\r\n+    '/bin',\r\n+    '/sbin',\r\n+    '/usr/bin',\r\n+    '/usr/sbin',\r\n+    '/usr/local/bin',\r\n+    '/usr/local/sbin',\r\n+    '/etc',\r\n+    '/var',\r\n+    '/root',\r\n+    '/boot',\r\n+    '/lib',\r\n+    '/lib64',\r\n+    '/proc',\r\n+    '/sys',\r\n+    '/dev',\r\n+    '/run',\r\n+  ];\r\n+\r\n+  // 检查是否是系统目录\r\n+  const unsafePaths = process.platform === 'win32' ? windowsUnsafePaths : unixUnsafePaths;\r\n+\r\n+  for (const unsafePath of unsafePaths) {\r\n+    if (normalizedPath === unsafePath || normalizedPath.startsWith(unsafePath + path.sep)) {\r\n+      return false;\r\n+    }\r\n+  }\r\n+\r\n+  // 不允许访问根目录\r\n+  if (normalizedPath === '/' || normalizedPath === 'c:\\\\' || /^[a-z]:\\\\?$/i.test(normalizedPath)) {\r\n+    return false;\r\n+  }\r\n+\r\n+  // 允许访问用户主目录及其子目录\r\n+  if (normalizedPath.startsWith(homeDir)) {\r\n+    return true;\r\n+  }\r\n+\r\n+  // 允许访问其他非系统目录（如 D:\\projects, E:\\work 等）\r\n+  return true;\r\n+}\r\n+\r\n+/**\r\n+ * 检查路径是否在允许的项目范围内\r\n+ * 用于文件操作的额外安全检查\r\n+ */\r\n+function isPathWithinProject(targetPath: string, projectRoot: string): boolean {\r\n+  const normalizedTarget = path.normalize(path.resolve(targetPath));\r\n+  const normalizedRoot = path.normalize(path.resolve(projectRoot));\r\n+\r\n+  // 目标路径必须在项目根目录下\r\n+  return normalizedTarget.startsWith(normalizedRoot + path.sep) || normalizedTarget === normalizedRoot;\r\n+}\r\n+\r\n+// ============================================================================\r\n+// 文件操作 API\r\n+// ============================================================================\r\n+\r\n+/**\r\n+ * POST /api/blueprint/files/create\r\n+ * 创建文件或文件夹\r\n+ */\r\n+router.post('/files/create', (req: Request, res: Response) => {\r\n+  try {\r\n+    const { path: filePath, type, content } = req.body;\r\n+\r\n+    if (!filePath) {\r\n+      return res.status(400).json({\r\n+        success: false,\r\n+        error: '缺少 path 参数',\r\n+      });\r\n+    }\r\n+\r\n+    if (!type || !['file', 'directory'].includes(type)) {\r\n+      return res.status(400).json({\r\n+        success: false,\r\n+        error: 'type 参数必须是 \"file\" 或 \"directory\"',\r\n+      });\r\n+    }\r\n+\r\n+    // 转换为绝对路径\r\n+    const absolutePath = path.isAbsolute(filePath) ? filePath : path.resolve(process.cwd(), filePath);\r\n+\r\n+    // 安全检查\r\n+    if (!isPathSafe(absolutePath)) {\r\n+      return res.status(403).json({\r\n+        success: false,\r\n+        error: '禁止在系统目录中创建文件',\r\n+      });\r\n+    }\r\n+\r\n+    // 检查路径是否已存在\r\n+    if (fs.existsSync(absolutePath)) {\r\n+      return res.status(409).json({\r\n+        success: false,\r\n+        error: `路径已存在: ${filePath}`,\r\n+      });\r\n+    }\r\n+\r\n+    // 确保父目录存在\r\n+    const parentDir = path.dirname(absolutePath);\r\n+    if (!fs.existsSync(parentDir)) {\r\n+      fs.mkdirSync(parentDir, { recursive: true });\r\n+    }\r\n+\r\n+    if (type === 'directory') {\r\n+      fs.mkdirSync(absolutePath, { recursive: true });\r\n+    } else {\r\n+      fs.writeFileSync(absolutePath, content || '', 'utf-8');\r\n+    }\r\n+\r\n+    res.json({\r\n+      success: true,\r\n+      message: `${type === 'directory' ? '文件夹' : '文件'} 创建成功`,\r\n+      data: {\r\n+        path: absolutePath,\r\n+        type,\r\n+        name: path.basename(absolutePath),\r\n+      },\r\n+    });\r\n+  } catch (error: any) {\r\n+    console.error('[POST /files/create]', error);\r\n+    res.status(500).json({ success: false, error: error.message });\r\n+  }\r\n+});\r\n+\r\n+/**\r\n+ * DELETE /api/blueprint/files\r\n+ * 删除文件或文件夹（移到回收站概念 - 实际是重命名到 .trash 目录）\r\n+ */\r\n+router.delete('/files', (req: Request, res: Response) => {\r\n+  try {\r\n+    const { path: filePath, permanent } = req.body;\r\n+\r\n+    if (!filePath) {\r\n+      return res.status(400).json({\r\n+        success: false,\r\n+        error: '缺少 path 参数',\r\n+      });\r\n+    }\r\n+\r\n+    // 转换为绝对路径\r\n+    const absolutePath = path.isAbsolute(filePath) ? filePath : path.resolve(process.cwd(), filePath);\r\n+\r\n+    // 安全检查\r\n+    if (!isPathSafe(absolutePath)) {\r\n+      return res.status(403).json({\r\n+        success: false,\r\n+        error: '禁止删除系统目录中的文件',\r\n+      });\r\n+    }\r\n+\r\n+    // 检查路径是否存在\r\n+    if (!fs.existsSync(absolutePath)) {\r\n+      return res.status(404).json({\r\n+        success: false,\r\n+        error: `路径不存在: ${filePath}`,\r\n+      });\r\n+    }\r\n+\r\n+    const stats = fs.statSync(absolutePath);\r\n+    const isDirectory = stats.isDirectory();\r\n+    const fileName = path.basename(absolutePath);\r\n+\r\n+    if (permanent) {\r\n+      // 永久删除\r\n+      if (isDirectory) {\r\n+        fs.rmSync(absolutePath, { recursive: true, force: true });\r\n+      } else {\r\n+        fs.unlinkSync(absolutePath);\r\n+      }\r\n+\r\n+      res.json({\r\n+        success: true,\r\n+        message: `${isDirectory ? '文件夹' : '文件'} \"${fileName}\" 已永久删除`,\r\n+      });\r\n+    } else {\r\n+      // 移到项目内的 .trash 目录（模拟回收站）\r\n+      const projectRoot = process.cwd();\r\n+      const trashDir = path.join(projectRoot, '.trash');\r\n+      const timestamp = Date.now();\r\n+      const trashPath = path.join(trashDir, `${fileName}_${timestamp}`);\r\n+\r\n+      // 确保 .trash 目录存在\r\n+      if (!fs.existsSync(trashDir)) {\r\n+        fs.mkdirSync(trashDir, { recursive: true });\r\n+      }\r\n+\r\n+      // 移动文件到回收站\r\n+      fs.renameSync(absolutePath, trashPath);\r\n+\r\n+      res.json({\r\n+        success: true,\r\n+        message: `${isDirectory ? '文件夹' : '文件'} \"${fileName}\" 已移到回收站`,\r\n+        data: {\r\n+          originalPath: absolutePath,\r\n+          trashPath,\r\n+        },\r\n+      });\r\n+    }\r\n+  } catch (error: any) {\r\n+    console.error('[DELETE /files]', error);\r\n+    res.status(500).json({ success: false, error: error.message });\r\n+  }\r\n+});\r\n+\r\n+/**\r\n+ * POST /api/blueprint/files/rename\r\n+ * 重命名文件或文件夹\r\n+ */\r\n+router.post('/files/rename', (req: Request, res: Response) => {\r\n+  try {\r\n+    const { oldPath, newPath } = req.body;\r\n+\r\n+    if (!oldPath || !newPath) {\r\n+      return res.status(400).json({\r\n+        success: false,\r\n+        error: '缺少 oldPath 或 newPath 参数',\r\n+      });\r\n+    }\r\n+\r\n+    // 转换为绝对路径\r\n+    const absoluteOldPath = path.isAbsolute(oldPath) ? oldPath : path.resolve(process.cwd(), oldPath);\r\n+    const absoluteNewPath = path.isAbsolute(newPath) ? newPath : path.resolve(process.cwd(), newPath);\r\n+\r\n+    // 安全检查\r\n+    if (!isPathSafe(absoluteOldPath) || !isPathSafe(absoluteNewPath)) {\r\n+      return res.status(403).json({\r\n+        success: false,\r\n+        error: '禁止操作系统目录中的文件',\r\n+      });\r\n+    }\r\n+\r\n+    // 检查源路径是否存在\r\n+    if (!fs.existsSync(absoluteOldPath)) {\r\n+      return res.status(404).json({\r\n+        success: false,\r\n+        error: `源路径不存在: ${oldPath}`,\r\n+      });\r\n+    }\r\n+\r\n+    // 检查目标路径是否已存在\r\n+    if (fs.existsSync(absoluteNewPath)) {\r\n+      return res.status(409).json({\r\n+        success: false,\r\n+        error: `目标路径已存在: ${newPath}`,\r\n+      });\r\n+    }\r\n+\r\n+    // 确保目标目录存在\r\n+    const newParentDir = path.dirname(absoluteNewPath);\r\n+    if (!fs.existsSync(newParentDir)) {\r\n+      fs.mkdirSync(newParentDir, { recursive: true });\r\n+    }\r\n+\r\n+    fs.renameSync(absoluteOldPath, absoluteNewPath);\r\n+\r\n+    res.json({\r\n+      success: true,\r\n+      message: '重命名成功',\r\n+      data: {\r\n+        oldPath: absoluteOldPath,\r\n+        newPath: absoluteNewPath,\r\n+        name: path.basename(absoluteNewPath),\r\n+      },\r\n+    });\r\n+  } catch (error: any) {\r\n+    console.error('[POST /files/rename]', error);\r\n+    res.status(500).json({ success: false, error: error.message });\r\n+  }\r\n+});\r\n+\r\n+/**\r\n+ * POST /api/blueprint/files/copy\r\n+ * 复制文件或文件夹\r\n+ */\r\n+router.post('/files/copy', (req: Request, res: Response) => {\r\n+  try {\r\n+    const { sourcePath, destPath } = req.body;\r\n+\r\n+    if (!sourcePath || !destPath) {\r\n+      return res.status(400).json({\r\n+        success: false,\r\n+        error: '缺少 sourcePath 或 destPath 参数',\r\n+      });\r\n+    }\r\n+\r\n+    // 转换为绝对路径\r\n+    const absoluteSourcePath = path.isAbsolute(sourcePath) ? sourcePath : path.resolve(process.cwd(), sourcePath);\r\n+    const absoluteDestPath = path.isAbsolute(destPath) ? destPath : path.resolve(process.cwd(), destPath);\r\n+\r\n+    // 安全检查\r\n+    if (!isPathSafe(absoluteSourcePath) || !isPathSafe(absoluteDestPath)) {\r\n+      return res.status(403).json({\r\n+        success: false,\r\n+        error: '禁止操作系统目录中的文件',\r\n+      });\r\n+    }\r\n+\r\n+    // 检查源路径是否存在\r\n+    if (!fs.existsSync(absoluteSourcePath)) {\r\n+      return res.status(404).json({\r\n+        success: false,\r\n+        error: `源路径不存在: ${sourcePath}`,\r\n+      });\r\n+    }\r\n+\r\n+    // 检查目标路径是否已存在\r\n+    if (fs.existsSync(absoluteDestPath)) {\r\n+      return res.status(409).json({\r\n+        success: false,\r\n+        error: `目标路径已存在: ${destPath}`,\r\n+      });\r\n+    }\r\n+\r\n+    // 确保目标目录存在\r\n+    const destParentDir = path.dirname(absoluteDestPath);\r\n+    if (!fs.existsSync(destParentDir)) {\r\n+      fs.mkdirSync(destParentDir, { recursive: true });\r\n+    }\r\n+\r\n+    const stats = fs.statSync(absoluteSourcePath);\r\n+\r\n+    if (stats.isDirectory()) {\r\n+      // 递归复制目录\r\n+      copyDirectoryRecursive(absoluteSourcePath, absoluteDestPath);\r\n+    } else {\r\n+      // 复制文件\r\n+      fs.copyFileSync(absoluteSourcePath, absoluteDestPath);\r\n+    }\r\n+\r\n+    res.json({\r\n+      success: true,\r\n+      message: '复制成功',\r\n+      data: {\r\n+        sourcePath: absoluteSourcePath,\r\n+        destPath: absoluteDestPath,\r\n+        name: path.basename(absoluteDestPath),\r\n+      },\r\n+    });\r\n+  } catch (error: any) {\r\n+    console.error('[POST /files/copy]', error);\r\n+    res.status(500).json({ success: false, error: error.message });\r\n+  }\r\n+});\r\n+\r\n+/**\r\n+ * 递归复制目录\r\n+ */\r\n+function copyDirectoryRecursive(source: string, destination: string): void {\r\n+  fs.mkdirSync(destination, { recursive: true });\r\n+\r\n+  const entries = fs.readdirSync(source, { withFileTypes: true });\r\n+\r\n+  for (const entry of entries) {\r\n+    const srcPath = path.join(source, entry.name);\r\n+    const destPath = path.join(destination, entry.name);\r\n+\r\n+    if (entry.isDirectory()) {\r\n+      copyDirectoryRecursive(srcPath, destPath);\r\n+    } else {\r\n+      fs.copyFileSync(srcPath, destPath);\r\n+    }\r\n+  }\r\n+}\r\n+\r\n+/**\r\n+ * POST /api/blueprint/files/move\r\n+ * 移动文件或文件夹\r\n+ */\r\n+router.post('/files/move', (req: Request, res: Response) => {\r\n+  try {\r\n+    const { sourcePath, destPath } = req.body;\r\n+\r\n+    if (!sourcePath || !destPath) {\r\n+      return res.status(400).json({\r\n+        success: false,\r\n+        error: '缺少 sourcePath 或 destPath 参数',\r\n+      });\r\n+    }\r\n+\r\n+    // 转换为绝对路径\r\n+    const absoluteSourcePath = path.isAbsolute(sourcePath) ? sourcePath : path.resolve(process.cwd(), sourcePath);\r\n+    const absoluteDestPath = path.isAbsolute(destPath) ? destPath : path.resolve(process.cwd(), destPath);\r\n+\r\n+    // 安全检查\r\n+    if (!isPathSafe(absoluteSourcePath) || !isPathSafe(absoluteDestPath)) {\r\n+      return res.status(403).json({\r\n+        success: false,\r\n+        error: '禁止操作系统目录中的文件',\r\n+      });\r\n+    }\r\n+\r\n+    // 检查源路径是否存在\r\n+    if (!fs.existsSync(absoluteSourcePath)) {\r\n+      return res.status(404).json({\r\n+        success: false,\r\n+        error: `源路径不存在: ${sourcePath}`,\r\n+      });\r\n+    }\r\n+\r\n+    // 检查目标路径是否已存在\r\n+    if (fs.existsSync(absoluteDestPath)) {\r\n+      return res.status(409).json({\r\n+        success: false,\r\n+        error: `目标路径已存在: ${destPath}`,\r\n+      });\r\n+    }\r\n+\r\n+    // 确保目标目录存在\r\n+    const destParentDir = path.dirname(absoluteDestPath);\r\n+    if (!fs.existsSync(destParentDir)) {\r\n+      fs.mkdirSync(destParentDir, { recursive: true });\r\n+    }\r\n+\r\n+    // 尝试直接重命名（同一文件系统内）\r\n+    try {\r\n+      fs.renameSync(absoluteSourcePath, absoluteDestPath);\r\n+    } catch (renameError: any) {\r\n+      // 如果跨文件系统，则先复制再删除\r\n+      if (renameError.code === 'EXDEV') {\r\n+        const stats = fs.statSync(absoluteSourcePath);\r\n+        if (stats.isDirectory()) {\r\n+          copyDirectoryRecursive(absoluteSourcePath, absoluteDestPath);\r\n+          fs.rmSync(absoluteSourcePath, { recursive: true, force: true });\r\n+        } else {\r\n+          fs.copyFileSync(absoluteSourcePath, absoluteDestPath);\r\n+          fs.unlinkSync(absoluteSourcePath);\r\n+        }\r\n+      } else {\r\n+        throw renameError;\r\n+      }\r\n+    }\r\n+\r\n+    res.json({\r\n+      success: true,\r\n+      message: '移动成功',\r\n+      data: {\r\n+        sourcePath: absoluteSourcePath,\r\n+        destPath: absoluteDestPath,\r\n+        name: path.basename(absoluteDestPath),\r\n+      },\r\n+    });\r\n+  } catch (error: any) {\r\n+    console.error('[POST /files/move]', error);\r\n+    res.status(500).json({ success: false, error: error.message });\r\n+  }\r\n+});\r\n+\r\n+/**\r\n+ * GET /api/blueprint/files/exists\r\n+ * 检查路径是否存在\r\n+ */\r\n+router.get('/files/exists', (req: Request, res: Response) => {\r\n+  try {\r\n+    const targetPath = req.query.path as string;\r\n+\r\n+    if (!targetPath) {\r\n+      return res.status(400).json({\r\n+        success: false,\r\n+        error: '缺少 path 参数',\r\n+      });\r\n+    }\r\n+\r\n+    // 获取当前工作目录\r\n+    const cwd = process.cwd();\r\n+    const absolutePath = path.isAbsolute(targetPath)\r\n+      ? targetPath\r\n+      : path.join(cwd, targetPath);\r\n+\r\n+    // 安全检查：确保路径在工作目录内\r\n+    const normalizedPath = path.normalize(absolutePath);\r\n+    const normalizedCwd = path.normalize(cwd);\r\n+    if (!normalizedPath.startsWith(normalizedCwd)) {\r\n+      return res.status(403).json({\r\n+        success: false,\r\n+        error: '禁止访问工作目录外的路径',\r\n+      });\r\n+    }\r\n+\r\n+    // 检查路径是否存在\r\n+    const exists = fs.existsSync(absolutePath);\r\n+    let isFile = false;\r\n+    let isDirectory = false;\r\n+\r\n+    if (exists) {\r\n+      const stat = fs.statSync(absolutePath);\r\n+      isFile = stat.isFile();\r\n+      isDirectory = stat.isDirectory();\r\n+    }\r\n+\r\n+    res.json({\r\n+      success: true,\r\n+      data: {\r\n+        exists,\r\n+        isFile,\r\n+        isDirectory,\r\n+        path: absolutePath,\r\n+      },\r\n+    });\r\n+  } catch (error: any) {\r\n+    console.error('[GET /files/exists]', error);\r\n+    res.status(500).json({ success: false, error: error.message });\r\n+  }\r\n+});\r\n+\r\n+/**\r\n+ * AI 代码问答 - 回答用户关于代码的问题\r\n+ * POST /api/blueprint/ai/ask\r\n+ */\r\n+router.post('/ai/ask', async (req, res) => {\r\n+  try {\r\n+    const { code, question, filePath, context } = req.body;\r\n+\r\n+    if (!code || !question) {\r\n+      return res.status(400).json({ success: false, error: '缺少代码或问题' });\r\n+    }\r\n+\r\n+    // 获取 AI 客户端\r\n+    const { getDefaultClient } = await import('../../../core/client.js');\r\n+    const client = getDefaultClient();\r\n+\r\n+    const language = context?.language || 'typescript';\r\n+    const lineCount = code.split('\\n').length;\r\n+\r\n+    const prompt = `请回答以下关于代码的问题。\r\n+\r\n+**文件**: ${filePath || '未知'}\r\n+**语言**: ${language}\r\n+**代码行数**: ${lineCount}\r\n+\r\n+**代码片段**:\r\n+\\`\\`\\`${language}\r\n+${code.substring(0, 3000)}\r\n+\\`\\`\\`\r\n+\r\n+**用户问题**: ${question}\r\n+\r\n+请用中文回答，要求：\r\n+1. 直接回答问题，不要废话\r\n+2. 如果是关于代码作用的问题，具体说明这段代码做了什么\r\n+3. 如果是关于优化的问题，给出具体、可执行的建议\r\n+4. 如果是关于问题/bug的问题，指出具体的潜在问题和位置\r\n+5. 回答控制在 200 字以内，言简意赅`;\r\n+\r\n+    console.log(`[AI Ask] 回答问题: \"${question.substring(0, 50)}...\"`);\r\n+    const startTime = Date.now();\r\n+\r\n+    const response = await client.createMessage(\r\n+      [{ role: 'user', content: prompt }],\r\n+      undefined,\r\n+      '你是一个代码专家。直接、具体地回答用户关于代码的问题，不要使用模板化的废话。'\r\n+    );\r\n+\r\n+    console.log(`[AI Ask] AI 调用耗时: ${Date.now() - startTime}ms`);\r\n+\r\n+    // 提取回答\r\n+    let answer = '暂时无法回答这个问题';\r\n+    const textContent = response.content?.find((c: any) => c.type === 'text');\r\n+    if (textContent && 'text' in textContent) {\r\n+      answer = textContent.text;\r\n+    }\r\n+\r\n+    res.json({\r\n+      success: true,\r\n+      answer,\r\n+    });\r\n+  } catch (error: any) {\r\n+    console.error('[AI Ask] 错误:', error);\r\n+    res.status(500).json({\r\n+      success: false,\r\n+      error: error.message || 'AI 回答失败',\r\n+    });\r\n+  }\r\n+});\r\n+\r\n+/**\r\n+ * AI 代码导游 - 为代码生成智能导览\r\n+ * POST /api/blueprint/ai/tour\r\n+ */\r\n+router.post('/ai/tour', async (req, res) => {\r\n+  try {\r\n+    const { filePath, content } = req.body;\r\n+\r\n+    if (!content) {\r\n+      return res.status(400).json({ success: false, error: '缺少文件内容' });\r\n+    }\r\n+\r\n+    // 获取 AI 客户端\r\n+    const { getDefaultClient } = await import('../../../core/client.js');\r\n+    const client = getDefaultClient();\r\n+\r\n+    // 提取代码中的关键符号\r\n+    const symbols: Array<{ type: string; name: string; line: number; code: string }> = [];\r\n+    const lines = content.split('\\n');\r\n+\r\n+    // 提取类\r\n+    const classMatches = content.matchAll(/(?:export\\s+)?(?:abstract\\s+)?class\\s+(\\w+)[^{]*\\{/g);\r\n+    for (const match of classMatches) {\r\n+      const lineNum = content.substring(0, match.index).split('\\n').length;\r\n+      // 提取类的前 50 行代码作为上下文\r\n+      const endLine = Math.min(lineNum + 50, lines.length);\r\n+      const classCode = lines.slice(lineNum - 1, endLine).join('\\n');\r\n+      symbols.push({\r\n+        type: 'class',\r\n+        name: match[1],\r\n+        line: lineNum,\r\n+        code: classCode.substring(0, 2000), // 限制长度\r\n+      });\r\n+    }\r\n+\r\n+    // 提取函数\r\n+    const funcMatches = content.matchAll(/(?:export\\s+)?(?:async\\s+)?function\\s+(\\w+)[^{]*\\{/g);\r\n+    for (const match of funcMatches) {\r\n+      const lineNum = content.substring(0, match.index).split('\\n').length;\r\n+      const endLine = Math.min(lineNum + 30, lines.length);\r\n+      const funcCode = lines.slice(lineNum - 1, endLine).join('\\n');\r\n+      symbols.push({\r\n+        type: 'function',\r\n+        name: match[1],\r\n+        line: lineNum,\r\n+        code: funcCode.substring(0, 1500),\r\n+      });\r\n+    }\r\n+\r\n+    // 提取 React 组件\r\n+    const componentMatches = content.matchAll(/(?:export\\s+)?(?:const|function)\\s+(\\w+)[\\s\\S]*?(?:React\\.FC|JSX\\.Element|=>[\\s\\S]*?<)/g);\r\n+    for (const match of componentMatches) {\r\n+      // 避免与函数重复\r\n+      if (symbols.some(s => s.name === match[1])) continue;\r\n+      const lineNum = content.substring(0, match.index).split('\\n').length;\r\n+      const endLine = Math.min(lineNum + 40, lines.length);\r\n+      const componentCode = lines.slice(lineNum - 1, endLine).join('\\n');\r\n+      symbols.push({\r\n+        type: 'component',\r\n+        name: match[1],\r\n+        line: lineNum,\r\n+        code: componentCode.substring(0, 1500),\r\n+      });\r\n+    }\r\n+\r\n+    if (symbols.length === 0) {\r\n+      return res.json({\r\n+        success: true,\r\n+        data: { steps: [] },\r\n+      });\r\n+    }\r\n+\r\n+    // 构建 AI prompt\r\n+    const symbolsInfo = symbols.map((s, i) => `\r\n+### 符号 ${i + 1}: ${s.type} \"${s.name}\" (行 ${s.line})\r\n+\\`\\`\\`typescript\r\n+${s.code}\r\n+\\`\\`\\`\r\n+`).join('\\n');\r\n+\r\n+    const prompt = `分析以下代码文件中的符号，为每个符号生成一个简洁、有信息量的中文描述。\r\n+\r\n+文件路径: ${filePath || '未知'}\r\n+\r\n+${symbolsInfo}\r\n+\r\n+要求：\r\n+1. 描述要具体，说明这个符号\"做什么\"、\"为什么存在\"\r\n+2. 如果是类，说明其职责、关键方法、继承关系\r\n+3. 如果是函数，说明其输入输出、核心逻辑\r\n+4. 如果是组件，说明其渲染的UI、使用的状态\r\n+5. 描述控制在 50-100 字以内\r\n+6. 不要使用\"这是一个...\"这样的废话开头\r\n+\r\n+返回 JSON 格式：\r\n+{\r\n+  \"descriptions\": [\r\n+    { \"name\": \"符号名\", \"description\": \"具体描述\" }\r\n+  ]\r\n+}\r\n+\r\n+只返回 JSON，不要其他内容。`;\r\n+\r\n+    console.log(`[AI Tour] 分析 ${symbols.length} 个符号...`);\r\n+    const startTime = Date.now();\r\n+\r\n+    const response = await client.createMessage(\r\n+      [{ role: 'user', content: prompt }],\r\n+      undefined,\r\n+      '你是一个代码分析专家。用简洁、专业的中文描述代码符号的功能和职责。'\r\n+    );\r\n+\r\n+    console.log(`[AI Tour] AI 调用耗时: ${Date.now() - startTime}ms`);\r\n+\r\n+    // 解析 AI 响应\r\n+    let descriptions: Array<{ name: string; description: string }> = [];\r\n+    const textContent = response.content?.find((c: any) => c.type === 'text');\r\n+    if (textContent && 'text' in textContent) {\r\n+      try {\r\n+        // 提取 JSON\r\n+        const jsonMatch = textContent.text.match(/\\{[\\s\\S]*\\}/);\r\n+        if (jsonMatch) {\r\n+          const parsed = JSON.parse(jsonMatch[0]);\r\n+          descriptions = parsed.descriptions || [];\r\n+        }\r\n+      } catch (parseError) {\r\n+        console.error('[AI Tour] JSON 解析失败:', parseError);\r\n+      }\r\n+    }\r\n+\r\n+    // 构建导游步骤\r\n+    const steps = symbols.map(symbol => {\r\n+      const desc = descriptions.find(d => d.name === symbol.name);\r\n+      return {\r\n+        type: symbol.type,\r\n+        name: symbol.name,\r\n+        line: symbol.line,\r\n+        description: desc?.description || `${symbol.type} ${symbol.name}`,\r\n+        importance: 'high' as 'high' | 'medium' | 'low',\r\n+      };\r\n+    });\r\n+\r\n+    // 添加导入区域描述\r\n+    let importEndLine = 0;\r\n+    const importSources: string[] = [];\r\n+    for (let i = 0; i < lines.length; i++) {\r\n+      const importMatch = lines[i].match(/^import\\s.*from\\s+['\"]([^'\"]+)['\"]/);\r\n+      if (importMatch) {\r\n+        importEndLine = i + 1;\r\n+        const source = importMatch[1];\r\n+        if (!source.startsWith('.') && !source.startsWith('@/') && importSources.length < 5) {\r\n+          importSources.push(source.split('/')[0]);\r\n+        }\r\n+      }\r\n+    }\r\n+\r\n+    if (importEndLine > 0) {\r\n+      const uniqueSources = [...new Set(importSources)];\r\n+      steps.unshift({\r\n+        type: 'block',\r\n+        name: '导入声明',\r\n+        line: 1,\r\n+        description: uniqueSources.length > 0\r\n+          ? `引入 ${uniqueSources.join(', ')} 等外部依赖，以及本地模块。`\r\n+          : '引入本地模块依赖。',\r\n+        importance: 'medium' as const,\r\n+      });\r\n+    }\r\n+\r\n+    // 按行号排序\r\n+    steps.sort((a, b) => a.line - b.line);\r\n+\r\n+    res.json({\r\n+      success: true,\r\n+      data: { steps },\r\n+    });\r\n+  } catch (error: any) {\r\n+    console.error('[AI Tour] 错误:', error);\r\n+    res.status(500).json({\r\n+      success: false,\r\n+      error: error.message || 'AI 分析失败',\r\n+    });\r\n+  }\r\n+});\r\n+\r\n+// ============================================================================\r\n+// AI 气泡 API - 为新手生成代码解释\r\n+// ============================================================================\r\n+\r\n+/**\r\n+ * AI 气泡缓存\r\n+ * key: filePath:contentHash\r\n+ * value: { bubbles, timestamp }\r\n+ */\r\n+const aiBubblesCache = new Map<string, { bubbles: any[]; timestamp: number; contentHash: string }>();\r\n+const BUBBLES_CACHE_TTL = 30 * 60 * 1000; // 30分钟缓存\r\n+\r\n+/**\r\n+ * POST /api/blueprint/analyze-bubbles\r\n+ * 使用AI为代码生成新手友好的解释气泡\r\n+ */\r\n+router.post('/analyze-bubbles', async (req: Request, res: Response) => {\r\n+  try {\r\n+    const { filePath, content, language } = req.body;\r\n+\r\n+    if (!filePath || !content) {\r\n+      return res.status(400).json({\r\n+        success: false,\r\n+        error: '缺少必要参数: filePath, content',\r\n+      });\r\n+    }\r\n+\r\n+    // 计算内容hash用于缓存\r\n+    const contentHash = crypto.createHash('md5').update(content).digest('hex').slice(0, 16);\r\n+    const cacheKey = `${filePath}:${contentHash}`;\r\n+\r\n+    // 检查缓存\r\n+    const cached = aiBubblesCache.get(cacheKey);\r\n+    if (cached && Date.now() - cached.timestamp < BUBBLES_CACHE_TTL) {\r\n+      console.log(`[AI Bubbles] 使用缓存: ${filePath}`);\r\n+      return res.json({\r\n+        success: true,\r\n+        data: { bubbles: cached.bubbles, fromCache: true },\r\n+      });\r\n+    }\r\n+\r\n+    console.log(`[AI Bubbles] 开始分析: ${filePath}, 语言: ${language || '未知'}`);\r\n+\r\n+    // 限制内容长度，避免 token 过大\r\n+    const lines = content.split('\\n');\r\n+    const truncatedContent = lines.length > 200\r\n+      ? lines.slice(0, 200).join('\\n') + '\\n// ... 文件过长，已截断 ...'\r\n+      : content;\r\n+\r\n+    // 获取 AI 客户端 - 使用 Haiku 模型加速\r\n+    const { createClientWithModel } = await import('../../../core/client.js');\r\n+    const client = createClientWithModel('haiku');\r\n+\r\n+    // 构建分析提示\r\n+    const prompt = `你是一个代码教育专家，专门帮助编程新手理解代码。请分析以下代码，找出对新手最有帮助的关键点，生成解释气泡。\r\n+\r\n+## 文件信息\r\n+- 文件路径: ${filePath}\r\n+- 编程语言: ${language || '未知'}\r\n+\r\n+## 代码内容\r\n+\\`\\`\\`${language || ''}\r\n+${truncatedContent}\r\n+\\`\\`\\`\r\n+\r\n+## 生成要求\r\n+1. 找出代码中新手最需要理解的 5-10 个关键点\r\n+2. 每个气泡必须有具体的教育价值，不要生成废话\r\n+3. 解释必须通俗易懂，假设读者是刚学编程的新手\r\n+4. 解释要具体，结合这段代码的上下文，不要泛泛而谈\r\n+5. 气泡类型: info(解释概念), tip(最佳实践), warning(注意事项)\r\n+\r\n+## 好的气泡示例\r\n+- \"这个函数接收用户名和密码，验证后返回登录状态。第3行的await表示需要等待服务器响应\"\r\n+- \"useState(false) 创建了一个开关变量，初始值是关闭。点击按钮时会切换这个开关\"\r\n+- \"这里用 try-catch 包裹是因为网络请求可能失败，catch 里处理失败的情况\"\r\n+\r\n+## 不好的气泡示例（禁止生成这类废话）\r\n+- \"这是一个函数定义\"\r\n+- \"useEffect 是 React 的副作用钩子\"\r\n+- \"async 表示异步操作\"\r\n+\r\n+请返回以下 JSON 格式（只返回 JSON，不要其他内容）：\r\n+{\r\n+  \"bubbles\": [\r\n+    {\r\n+      \"line\": 行号（从1开始）,\r\n+      \"message\": \"具体的解释内容，要有教育价值\",\r\n+      \"type\": \"info|tip|warning\"\r\n+    }\r\n+  ]\r\n+}`;\r\n+\r\n+    // 调用 AI 分析\r\n+    const startTime = Date.now();\r\n+    const response = await client.createMessage(\r\n+      [{ role: 'user', content: prompt }],\r\n+      undefined,\r\n+      '你是一个代码教育专家，专门帮助编程新手理解代码。你的解释必须具体、实用、有教育价值。只返回 JSON，不要其他内容。'\r\n+    );\r\n+    console.log(`[AI Bubbles] AI 调用耗时: ${Date.now() - startTime}ms`);\r\n+\r\n+    // 提取响应文本\r\n+    let responseText = '';\r\n+    for (const block of response.content) {\r\n+      if (block.type === 'text') {\r\n+        responseText += block.text;\r\n+      }\r\n+    }\r\n+\r\n+    // 解析 JSON\r\n+    let result: { bubbles: any[] };\r\n+    try {\r\n+      result = JSON.parse(responseText.trim());\r\n+    } catch {\r\n+      const jsonMatch = responseText.match(/```json\\s*([\\s\\S]*?)\\s*```/);\r\n+      if (jsonMatch) {\r\n+        result = JSON.parse(jsonMatch[1]);\r\n+      } else {\r\n+        const bareJsonMatch = responseText.match(/\\{[\\s\\S]*\\}/);\r\n+        if (bareJsonMatch) {\r\n+          result = JSON.parse(bareJsonMatch[0]);\r\n+        } else {\r\n+          throw new Error('无法解析 AI 返回的 JSON');\r\n+        }\r\n+      }\r\n+    }\r\n+\r\n+    // 验证和过滤气泡\r\n+    const validBubbles = (result.bubbles || [])\r\n+      .filter((b: any) => {\r\n+        // 验证必要字段\r\n+        if (!b.line || !b.message || !b.type) return false;\r\n+        // 过滤废话（太短或太通用的解释）\r\n+        if (b.message.length < 10) return false;\r\n+        // 验证行号在有效范围内\r\n+        if (b.line < 1 || b.line > lines.length) return false;\r\n+        return true;\r\n+      })\r\n+      .slice(0, 15); // 最多15个气泡\r\n+\r\n+    // 保存到缓存\r\n+    aiBubblesCache.set(cacheKey, {\r\n+      bubbles: validBubbles,\r\n+      timestamp: Date.now(),\r\n+      contentHash,\r\n+    });\r\n+\r\n+    console.log(`[AI Bubbles] 生成 ${validBubbles.length} 个气泡`);\r\n+\r\n+    res.json({\r\n+      success: true,\r\n+      data: { bubbles: validBubbles, fromCache: false },\r\n+    });\r\n+  } catch (error: any) {\r\n+    console.error('[AI Bubbles] 错误:', error);\r\n+    res.status(500).json({\r\n+      success: false,\r\n+      error: error.message || 'AI 气泡生成失败',\r\n+    });\r\n+  }\r\n+});\r\n+\r\n+// ============================================================================\r\n+// AI 热力图 API - 智能分析代码复杂度\r\n+// ============================================================================\r\n+\r\n+/**\r\n+ * AI 热力图缓存\r\n+ */\r\n+const aiHeatmapCache = new Map<string, { heatmap: any[]; timestamp: number; contentHash: string }>();\r\n+const HEATMAP_CACHE_TTL = 30 * 60 * 1000; // 30分钟缓存\r\n+\r\n+/**\r\n+ * POST /api/blueprint/analyze-heatmap\r\n+ * 使用AI分析代码复杂度，生成热力图数据\r\n+ */\r\n+router.post('/analyze-heatmap', async (req: Request, res: Response) => {\r\n+  try {\r\n+    const { filePath, content, language } = req.body;\r\n+\r\n+    if (!filePath || !content) {\r\n+      return res.status(400).json({\r\n+        success: false,\r\n+        error: '缺少必要参数: filePath, content',\r\n+      });\r\n+    }\r\n+\r\n+    // 计算内容hash用于缓存\r\n+    const contentHash = crypto.createHash('md5').update(content).digest('hex').slice(0, 16);\r\n+    const cacheKey = `heatmap:${filePath}:${contentHash}`;\r\n+\r\n+    // 检查缓存\r\n+    const cached = aiHeatmapCache.get(cacheKey);\r\n+    if (cached && Date.now() - cached.timestamp < HEATMAP_CACHE_TTL) {\r\n+      console.log(`[AI Heatmap] 使用缓存: ${filePath}`);\r\n+      return res.json({\r\n+        success: true,\r\n+        data: { heatmap: cached.heatmap, fromCache: true },\r\n+      });\r\n+    }\r\n+\r\n+    console.log(`[AI Heatmap] 开始分析: ${filePath}, 语言: ${language || '未知'}`);\r\n+\r\n+    // 限制内容长度\r\n+    const lines = content.split('\\n');\r\n+    const truncatedContent = lines.length > 300\r\n+      ? lines.slice(0, 300).join('\\n') + '\\n// ... 文件过长，已截断 ...'\r\n+      : content;\r\n+\r\n+    // 获取 AI 客户端\r\n+    const { createClientWithModel } = await import('../../../core/client.js');\r\n+    const client = createClientWithModel('haiku');\r\n+\r\n+    const prompt = `你是一个代码复杂度分析专家。请分析以下代码，识别出复杂度较高的代码行。\r\n+\r\n+## 文件信息\r\n+- 文件路径: ${filePath}\r\n+- 编程语言: ${language || '未知'}\r\n+- 总行数: ${lines.length}\r\n+\r\n+## 代码内容\r\n+\\`\\`\\`${language || ''}\r\n+${truncatedContent}\r\n+\\`\\`\\`\r\n+\r\n+## 分析要求\r\n+1. 找出代码中复杂度较高的行（不是每一行都要标记）\r\n+2. 只标记真正复杂、难以理解或需要重点关注的代码\r\n+3. 复杂度评分 0-100：\r\n+   - 0-30: 简单，不需要标记\r\n+   - 31-50: 中等复杂度，可能需要注意\r\n+   - 51-70: 较复杂，需要仔细理解\r\n+   - 71-100: 非常复杂，可能需要重构\r\n+\r\n+## 复杂度标准\r\n+- 深层嵌套（3层以上的 if/for/while）\r\n+- 复杂的条件表达式（多个 && || 组合）\r\n+- 回调地狱或 Promise 链过长\r\n+- 正则表达式（尤其是复杂的）\r\n+- 一行代码做太多事（超过120字符的复杂逻辑）\r\n+- 难以理解的算法逻辑\r\n+- 魔法数字或不清晰的变量\r\n+\r\n+## 不应该标记的内容\r\n+- 普通的变量声明\r\n+- 简单的 import/export\r\n+- 简单的函数调用\r\n+- 注释和空行\r\n+- 简单的类型定义\r\n+\r\n+请返回以下 JSON 格式（只返回 JSON，不要其他内容）：\r\n+{\r\n+  \"heatmap\": [\r\n+    {\r\n+      \"line\": 行号（从1开始）,\r\n+      \"complexity\": 复杂度评分（31-100，低于31的不要返回）,\r\n+      \"reason\": \"简短说明为什么复杂（10-30字）\"\r\n+    }\r\n+  ]\r\n+}`;\r\n+\r\n+    const startTime = Date.now();\r\n+    const response = await client.createMessage(\r\n+      [{ role: 'user', content: prompt }],\r\n+      undefined,\r\n+      '你是一个代码复杂度分析专家。只标记真正复杂的代码，不要过度标记。只返回 JSON。'\r\n+    );\r\n+    console.log(`[AI Heatmap] AI 调用耗时: ${Date.now() - startTime}ms`);\r\n+\r\n+    // 提取响应\r\n+    let responseText = '';\r\n+    for (const block of response.content) {\r\n+      if (block.type === 'text') {\r\n+        responseText += block.text;\r\n+      }\r\n+    }\r\n+\r\n+    // 解析 JSON\r\n+    let result: { heatmap: any[] };\r\n+    try {\r\n+      result = JSON.parse(responseText.trim());\r\n+    } catch {\r\n+      const jsonMatch = responseText.match(/```json\\s*([\\s\\S]*?)\\s*```/);\r\n+      if (jsonMatch) {\r\n+        result = JSON.parse(jsonMatch[1]);\r\n+      } else {\r\n+        const bareJsonMatch = responseText.match(/\\{[\\s\\S]*\\}/);\r\n+        if (bareJsonMatch) {\r\n+          result = JSON.parse(bareJsonMatch[0]);\r\n+        } else {\r\n+          throw new Error('无法解析 AI 返回的 JSON');\r\n+        }\r\n+      }\r\n+    }\r\n+\r\n+    // 验证和过滤\r\n+    const validHeatmap = (result.heatmap || [])\r\n+      .filter((h: any) => {\r\n+        if (!h.line || typeof h.complexity !== 'number') return false;\r\n+        if (h.complexity < 31 || h.complexity > 100) return false;\r\n+        if (h.line < 1 || h.line > lines.length) return false;\r\n+        return true;\r\n+      })\r\n+      .map((h: any) => ({\r\n+        line: h.line,\r\n+        complexity: Math.min(100, Math.max(0, h.complexity)),\r\n+        reason: h.reason || '复杂代码',\r\n+      }));\r\n+\r\n+    // 保存缓存\r\n+    aiHeatmapCache.set(cacheKey, {\r\n+      heatmap: validHeatmap,\r\n+      timestamp: Date.now(),\r\n+      contentHash,\r\n+    });\r\n+\r\n+    console.log(`[AI Heatmap] 标记 ${validHeatmap.length} 个复杂行`);\r\n+\r\n+    res.json({\r\n+      success: true,\r\n+      data: { heatmap: validHeatmap, fromCache: false },\r\n+    });\r\n+  } catch (error: any) {\r\n+    console.error('[AI Heatmap] 错误:', error);\r\n+    res.status(500).json({\r\n+      success: false,\r\n+      error: error.message || 'AI 热力图分析失败',\r\n+    });\r\n+  }\r\n+});\r\n+\r\n+// ============================================================================\r\n+// AI 重构建议 API - 智能分析代码质量并提供改进建议\r\n+// ============================================================================\r\n+\r\n+/**\r\n+ * AI 重构建议缓存\r\n+ */\r\n+const aiRefactorCache = new Map<string, { suggestions: any[]; timestamp: number; contentHash: string }>();\r\n+const REFACTOR_CACHE_TTL = 30 * 60 * 1000; // 30分钟缓存\r\n+\r\n+/**\r\n+ * POST /api/blueprint/analyze-refactoring\r\n+ * 使用AI分析代码并提供重构建议\r\n+ */\r\n+router.post('/analyze-refactoring', async (req: Request, res: Response) => {\r\n+  try {\r\n+    const { filePath, content, language } = req.body;\r\n+\r\n+    if (!filePath || !content) {\r\n+      return res.status(400).json({\r\n+        success: false,\r\n+        error: '缺少必要参数: filePath, content',\r\n+      });\r\n+    }\r\n+\r\n+    // 计算内容hash用于缓存\r\n+    const contentHash = crypto.createHash('md5').update(content).digest('hex').slice(0, 16);\r\n+    const cacheKey = `refactor:${filePath}:${contentHash}`;\r\n+\r\n+    // 检查缓存\r\n+    const cached = aiRefactorCache.get(cacheKey);\r\n+    if (cached && Date.now() - cached.timestamp < REFACTOR_CACHE_TTL) {\r\n+      console.log(`[AI Refactor] 使用缓存: ${filePath}`);\r\n+      return res.json({\r\n+        success: true,\r\n+        data: { suggestions: cached.suggestions, fromCache: true },\r\n+      });\r\n+    }\r\n+\r\n+    console.log(`[AI Refactor] 开始分析: ${filePath}, 语言: ${language || '未知'}`);\r\n+\r\n+    // 限制内容长度\r\n+    const lines = content.split('\\n');\r\n+    const truncatedContent = lines.length > 400\r\n+      ? lines.slice(0, 400).join('\\n') + '\\n// ... 文件过长，已截断 ...'\r\n+      : content;\r\n+\r\n+    // 获取 AI 客户端\r\n+    const { createClientWithModel } = await import('../../../core/client.js');\r\n+    const client = createClientWithModel('haiku');\r\n+\r\n+    const prompt = `你是一个高级代码审查专家和重构顾问。请分析以下代码，提供专业的重构建议。\r\n+\r\n+## 文件信息\r\n+- 文件路径: ${filePath}\r\n+- 编程语言: ${language || '未知'}\r\n+- 总行数: ${lines.length}\r\n+\r\n+## 代码内容\r\n+\\`\\`\\`${language || ''}\r\n+${truncatedContent}\r\n+\\`\\`\\`\r\n+\r\n+## 分析重点\r\n+1. **代码异味（Code Smells）**\r\n+   - 过长的函数（超过50行应该拆分）\r\n+   - 过深的嵌套（超过3层应该重构）\r\n+   - 重复代码（类似逻辑应该提取）\r\n+   - 过长的参数列表\r\n+   - 过大的类或模块\r\n+\r\n+2. **可维护性问题**\r\n+   - 魔法数字（应该定义为常量）\r\n+   - 不清晰的命名\r\n+   - 缺少错误处理\r\n+   - 过于复杂的条件逻辑\r\n+\r\n+3. **性能隐患**\r\n+   - 不必要的重复计算\r\n+   - 内存泄漏风险（未清理的订阅、定时器等）\r\n+   - 低效的循环或查找\r\n+\r\n+4. **最佳实践**\r\n+   - 可以使用更现代的语法\r\n+   - 可以利用框架特性简化代码\r\n+   - 可以提升类型安全性\r\n+\r\n+## 输出要求\r\n+- 只提供有价值的、可操作的建议\r\n+- 每个建议都要具体说明问题和解决方案\r\n+- 优先级：high（必须修复）、medium（建议修复）、low（可以考虑）\r\n+- 类型：extract（提取函数/组件）、simplify（简化逻辑）、rename（重命名）、duplicate（消除重复）、performance（性能优化）、safety（安全性）\r\n+\r\n+请返回以下 JSON 格式（只返回 JSON，不要其他内容）：\r\n+{\r\n+  \"suggestions\": [\r\n+    {\r\n+      \"line\": 起始行号,\r\n+      \"endLine\": 结束行号,\r\n+      \"type\": \"extract|simplify|rename|duplicate|performance|safety\",\r\n+      \"message\": \"具体的问题描述和解决建议（30-80字）\",\r\n+      \"priority\": \"high|medium|low\",\r\n+      \"codeContext\": \"问题代码的一小段原文（15-40字符，必须是代码中真实存在的片段）\"\r\n+    }\r\n+  ]\r\n+}\r\n+\r\n+**重要**: codeContext 必须是代码中真实存在的原文片段，用于精确定位问题代码的位置。例如：\r\n+- 对于接口定义问题：使用 \"interface Message {\" 或 \"to: string | string[]\"\r\n+- 对于函数问题：使用 \"function calculateTotal(\" 或 \"const handleSubmit =\"\r\n+- 对于变量问题：使用 \"let counter = 0\" 或 \"const config: Config\"`;\r\n+\r\n+    const startTime = Date.now();\r\n+    const response = await client.createMessage(\r\n+      [{ role: 'user', content: prompt }],\r\n+      undefined,\r\n+      '你是一个代码审查专家。提供专业、可操作的重构建议。只返回 JSON。'\r\n+    );\r\n+    console.log(`[AI Refactor] AI 调用耗时: ${Date.now() - startTime}ms`);\r\n+\r\n+    // 提取响应\r\n+    let responseText = '';\r\n+    for (const block of response.content) {\r\n+      if (block.type === 'text') {\r\n+        responseText += block.text;\r\n+      }\r\n+    }\r\n+\r\n+    // 解析 JSON\r\n+    let result: { suggestions: any[] };\r\n+    try {\r\n+      result = JSON.parse(responseText.trim());\r\n+    } catch {\r\n+      const jsonMatch = responseText.match(/```json\\s*([\\s\\S]*?)\\s*```/);\r\n+      if (jsonMatch) {\r\n+        result = JSON.parse(jsonMatch[1]);\r\n+      } else {\r\n+        const bareJsonMatch = responseText.match(/\\{[\\s\\S]*\\}/);\r\n+        if (bareJsonMatch) {\r\n+          result = JSON.parse(bareJsonMatch[0]);\r\n+        } else {\r\n+          throw new Error('无法解析 AI 返回的 JSON');\r\n+        }\r\n+      }\r\n+    }\r\n+\r\n+    // 验证和过滤\r\n+    const validTypes = ['extract', 'simplify', 'rename', 'duplicate', 'performance', 'safety'];\r\n+    const validPriorities = ['high', 'medium', 'low'];\r\n+\r\n+    /**\r\n+     * 使用 codeContext 校正行号\r\n+     * AI返回的行号可能不准确，通过搜索代码片段来找到正确位置\r\n+     * 参考 Edit 工具的字符串匹配方式\r\n+     */\r\n+    const correctLineNumber = (suggestion: any): { line: number; endLine: number } => {\r\n+      const originalLine = suggestion.line;\r\n+      const originalEndLine = suggestion.endLine || suggestion.line;\r\n+      const codeContext = suggestion.codeContext;\r\n+\r\n+      // 如果没有提供代码上下文，使用原始行号\r\n+      if (!codeContext || typeof codeContext !== 'string' || codeContext.length < 5) {\r\n+        return { line: originalLine, endLine: originalEndLine };\r\n+      }\r\n+\r\n+      // 清理代码上下文（移除首尾空白，但保留内部格式）\r\n+      const cleanContext = codeContext.trim();\r\n+\r\n+      // 在原始行号附近搜索（优先），找距离最近的匹配\r\n+      let bestMatch: number | null = null;\r\n+      let bestDistance = Infinity;\r\n+\r\n+      // 第一轮：在原始行号附近50行内搜索\r\n+      const searchRadius = 50;\r\n+      const startLine = Math.max(0, originalLine - searchRadius - 1);\r\n+      const endLine = Math.min(lines.length, originalLine + searchRadius);\r\n+\r\n+      for (let i = startLine; i < endLine; i++) {\r\n+        if (lines[i].includes(cleanContext)) {\r\n+          const distance = Math.abs(i + 1 - originalLine);\r\n+          if (distance < bestDistance) {\r\n+            bestDistance = distance;\r\n+            bestMatch = i + 1;\r\n+          }\r\n+        }\r\n+      }\r\n+\r\n+      if (bestMatch !== null) {\r\n+        const lineOffset = bestMatch - originalLine;\r\n+        const correctedEndLine = Math.max(bestMatch, originalEndLine + lineOffset);\r\n+        console.log(`[AI Refactor] 行号校正: \"${cleanContext.slice(0, 30)}...\" 从 ${originalLine} 校正到 ${bestMatch} (范围内匹配)`);\r\n+        return {\r\n+          line: bestMatch,\r\n+          endLine: Math.min(correctedEndLine, lines.length),\r\n+        };\r\n+      }\r\n+\r\n+      // 第二轮：全文搜索\r\n+      for (let i = 0; i < lines.length; i++) {\r\n+        if (lines[i].includes(cleanContext)) {\r\n+          const correctedLine = i + 1;\r\n+          const lineOffset = correctedLine - originalLine;\r\n+          const correctedEndLine = Math.max(correctedLine, originalEndLine + lineOffset);\r\n+          console.log(`[AI Refactor] 行号校正: \"${cleanContext.slice(0, 30)}...\" 从 ${originalLine} 校正到 ${correctedLine} (全文匹配)`);\r\n+          return {\r\n+            line: correctedLine,\r\n+            endLine: Math.min(correctedEndLine, lines.length),\r\n+          };\r\n+        }\r\n+      }\r\n+\r\n+      // 第三轮：尝试模糊匹配（移除空格后匹配）\r\n+      const compactContext = cleanContext.replace(/\\s+/g, '');\r\n+      for (let i = 0; i < lines.length; i++) {\r\n+        const compactLine = lines[i].replace(/\\s+/g, '');\r\n+        if (compactLine.includes(compactContext)) {\r\n+          const correctedLine = i + 1;\r\n+          const lineOffset = correctedLine - originalLine;\r\n+          const correctedEndLine = Math.max(correctedLine, originalEndLine + lineOffset);\r\n+          console.log(`[AI Refactor] 行号校正: \"${cleanContext.slice(0, 30)}...\" 从 ${originalLine} 校正到 ${correctedLine} (模糊匹配)`);\r\n+          return {\r\n+            line: correctedLine,\r\n+            endLine: Math.min(correctedEndLine, lines.length),\r\n+          };\r\n+        }\r\n+      }\r\n+\r\n+      // 如果找不到，使用原始行号\r\n+      console.log(`[AI Refactor] 无法校正行号: \"${cleanContext.slice(0, 30)}...\" 未找到，保持原始行号 ${originalLine}`);\r\n+      return { line: originalLine, endLine: originalEndLine };\r\n+    };\r\n+\r\n+    const validSuggestions = (result.suggestions || [])\r\n+      .filter((s: any) => {\r\n+        if (!s.line || !s.message || !s.type || !s.priority) return false;\r\n+        if (!validTypes.includes(s.type)) return false;\r\n+        if (!validPriorities.includes(s.priority)) return false;\r\n+        if (s.line < 1 || s.line > lines.length) return false;\r\n+        if (s.message.length < 10) return false;\r\n+        return true;\r\n+      })\r\n+      .map((s: any) => {\r\n+        const corrected = correctLineNumber(s);\r\n+        return {\r\n+          line: corrected.line,\r\n+          endLine: corrected.endLine,\r\n+          type: s.type,\r\n+          message: s.message,\r\n+          priority: s.priority,\r\n+        };\r\n+      })\r\n+      .slice(0, 20); // 最多20个建议\r\n+\r\n+    // 保存缓存\r\n+    aiRefactorCache.set(cacheKey, {\r\n+      suggestions: validSuggestions,\r\n+      timestamp: Date.now(),\r\n+      contentHash,\r\n+    });\r\n+\r\n+    console.log(`[AI Refactor] 生成 ${validSuggestions.length} 个建议`);\r\n+\r\n+    res.json({\r\n+      success: true,\r\n+      data: { suggestions: validSuggestions, fromCache: false },\r\n+    });\r\n+  } catch (error: any) {\r\n+    console.error('[AI Refactor] 错误:', error);\r\n+    res.status(500).json({\r\n+      success: false,\r\n+      error: error.message || 'AI 重构分析失败',\r\n+    });\r\n+  }\r\n+});\r\n+\r\n+// ============================================================================\r\n+// 架构流程图 API（AI 生成）\r\n+// ============================================================================\r\n+\r\n+/** 架构图类型 */\r\n+type ArchitectureGraphType = 'dataflow' | 'sequence' | 'toolflow' | 'modulerelation' | 'full';\r\n+\r\n+// 架构图缓存已移至持久化模块: src/blueprint/architecture-graph-cache.ts\r\n+\r\n+/** 架构图 Prompt 模板 */\r\n+const ARCHITECTURE_GRAPH_PROMPTS: Record<ArchitectureGraphType, string> = {\r\n+  dataflow: `分析代码库，生成**数据流图**的 Mermaid 代码。\r\n+\r\n+要求：\r\n+1. 使用 flowchart TB（从上到下）\r\n+2. 展示从用户输入到最终输出的完整数据流\r\n+3. 包含主要模块：入口层、核心引擎、工具系统、API层、持久化层\r\n+4. 使用 subgraph 分组相关模块\r\n+5. 用不同颜色区分不同类型的模块（使用 classDef）\r\n+6. 箭头标注数据流向\r\n+\r\n+只返回 Mermaid 代码，不要其他解释。`,\r\n+\r\n+  sequence: `分析代码库，生成**流式处理序列图**的 Mermaid 代码。\r\n+\r\n+要求：\r\n+1. 使用 sequenceDiagram\r\n+2. 展示 API 调用的完整序列：用户(User) -> 主循环(MainLoop) -> API客户端(Client) -> Claude API(API) -> 流式解析(Parser)\r\n+3. 包含流式事件：message_start, content_block_start, content_block_delta, content_block_stop, message_stop\r\n+4. 展示工具调用的分支流程\r\n+5. 使用 rect 标注关键阶段\r\n+6. 使用 Note 添加重要说明\r\n+7. **重要**：participant 标识符禁止使用 loop、alt、opt、par、rect、note 等 Mermaid 保留关键字！请使用 MainLoop 代替 Loop\r\n+\r\n+只返回 Mermaid 代码，不要其他解释。`,\r\n+\r\n+  toolflow: `分析代码库，生成**工具调用流程图**的 Mermaid 代码。\r\n+\r\n+要求：\r\n+1. 使用 flowchart TB\r\n+2. 展示工具调用的完整流程：接收 -> 权限检查 -> 执行 -> 结果处理\r\n+3. 包含权限检查的三步流程\r\n+4. 展示不同权限模式的分支\r\n+5. 包含错误处理和重试逻辑\r\n+6. 使用菱形节点表示判断\r\n+\r\n+只返回 Mermaid 代码，不要其他解释。`,\r\n+\r\n+  modulerelation: `分析代码库，生成**模块关系图**的 Mermaid 代码。\r\n+\r\n+要求：\r\n+1. 使用 flowchart TB\r\n+2. 展示核心模块之间的依赖关系\r\n+3. 分组显示：核心引擎、工具系统、Agent系统、支持系统\r\n+4. 用箭头标注调用关系\r\n+5. 使用不同颜色区分模块类型\r\n+6. 包含主要类/函数名称\r\n+\r\n+只返回 Mermaid 代码，不要其他解释。`,\r\n+\r\n+  full: `分析代码库，生成**完整系统架构图**的 Mermaid 代码。\r\n+\r\n+要求：\r\n+1. 使用 flowchart TB\r\n+2. 分层展示：用户层 -> 入口层 -> 核心引擎层 -> 工具系统层 -> 支持系统 -> 持久化层\r\n+3. 每层使用 subgraph 包裹\r\n+4. 展示层与层之间的数据流\r\n+5. 包含关键模块：CLI、MainLoop(核心循环)、ClaudeClient、Session、ToolRegistry、压缩系统\r\n+6. 使用 classDef 定义不同层的颜色\r\n+7. 标注关键流程：用户输入 -> 消息处理 -> API调用 -> 响应解析 -> 工具执行 -> 返回结果\r\n+8. **注意**：节点 ID 禁止使用 loop、end、subgraph 等 Mermaid 保留关键字\r\n+\r\n+只返回 Mermaid 代码，不要其他解释。`,\r\n+};\r\n+\r\n+/** 架构图标题和描述 */\r\n+const ARCHITECTURE_GRAPH_META: Record<ArchitectureGraphType, { title: string; description: string }> = {\r\n+  dataflow: { title: '系统数据流图', description: '展示从用户输入到最终输出的完整数据流' },\r\n+  sequence: { title: '流式处理序列图', description: 'API 调用和流式事件的时序关系' },\r\n+  toolflow: { title: '工具调用流程图', description: '工具执行的权限检查和处理流程' },\r\n+  modulerelation: { title: '模块关系图', description: '核心模块之间的依赖和调用关系' },\r\n+  full: { title: '完整系统架构图', description: '分层展示整体系统架构' },\r\n+};\r\n+\r\n+/**\r\n+ * 获取蓝图架构流程图（AI 生成）\r\n+ */\r\n+router.get('/blueprints/:id/architecture-graph', async (req: Request, res: Response) => {\r\n+  try {\r\n+    const { id } = req.params;\r\n+    const graphType = (req.query.type as ArchitectureGraphType) || 'full';\r\n+    const forceRefresh = req.query.forceRefresh === 'true';\r\n+\r\n+    // 验证图表类型\r\n+    if (!ARCHITECTURE_GRAPH_PROMPTS[graphType]) {\r\n+      return res.status(400).json({\r\n+        success: false,\r\n+        error: `无效的图表类型: ${graphType}`,\r\n+      });\r\n+    }\r\n+\r\n+    // 检查缓存（1小时内有效），除非强制刷新\r\n+    const cached = architectureGraphCache.get(id, graphType);\r\n+    if (!forceRefresh && cached) {\r\n+      console.log(`[Architecture Graph] 使用缓存: ${id}-${graphType}`);\r\n+      return res.json({\r\n+        success: true,\r\n+        data: {\r\n+          type: cached.type,\r\n+          title: cached.title,\r\n+          description: cached.description,\r\n+          mermaidCode: cached.mermaidCode,\r\n+          generatedAt: cached.generatedAt,\r\n+        },\r\n+        fromCache: true,\r\n+      });\r\n+    }\r\n+\r\n+    // 获取蓝图信息\r\n+    const blueprint = blueprintManager.getBlueprint(id);\r\n+    if (!blueprint) {\r\n+      return res.status(404).json({ success: false, error: 'Blueprint not found' });\r\n+    }\r\n+\r\n+    // mode=direct 时，使用直接转换逻辑，不消耗 Token 也不等待\r\n+    if (req.query.mode === 'direct') {\r\n+       const directGraph = convertBlueprintToMermaid(blueprint, graphType);\r\n+       \r\n+       // 更新缓存\r\n+       const graphData: ArchitectureGraphData = {\r\n+         type: graphType,\r\n+         title: directGraph.title,\r\n+         description: directGraph.description,\r\n+         mermaidCode: directGraph.mermaidCode,\r\n+         generatedAt: new Date().toISOString(),\r\n+         nodePathMap: {} // 直接模式暂不支持复杂跳转，或者后续实现\r\n+       };\r\n+       architectureGraphCache.set(id, graphType, graphData);\r\n+\r\n+       return res.json({\r\n+         success: true,\r\n+         data: graphData\r\n+       });\r\n+    }\r\n+\r\n+    // 获取项目根目录\r\n+    const projectRoot = blueprint.projectPath || process.cwd();\r\n+\r\n+    console.log(`[Architecture Graph] 生成 ${graphType} 类型架构图...`);\r\n+    console.log(`[Architecture Graph] 项目根目录: ${projectRoot}`);\r\n+\r\n+    // 先从蓝图提取已有的结构化信息\r\n+    const modules = blueprint.modules || [];\r\n+    const processes = blueprint.businessProcesses || [];\r\n+\r\n+    // 构建蓝图上下文（结构化的已分析信息）\r\n+    const blueprintContext = `\r\n+【项目基本信息】\r\n+名称: ${blueprint.name}\r\n+描述: ${blueprint.description || '无'}\r\n+状态: ${blueprint.status}\r\n+\r\n+【已识别的系统模块】(${modules.length}个):\r\n+${modules.map(m => `- ${m.name} (类型: ${m.type})\r\n+  路径: ${m.rootPath || '未指定'}\r\n+  描述: ${m.description || '无'}\r\n+  依赖: ${(m.dependencies || []).slice(0, 5).join(', ') || '无'}`).join('\\n') || '暂无模块信息'}\r\n+\r\n+【业务流程】(${processes.length}个):\r\n+${processes.map(p => `- ${p.name} (${p.type}): ${p.description || '无描述'}`).join('\\n') || '暂无业务流程'}\r\n+\r\n+【模块依赖关系】:\r\n+${modules.flatMap(m =>\r\n+  (m.dependencies || []).slice(0, 3).map(dep => `  ${m.name} --> ${dep}`)\r\n+).join('\\n') || '暂无依赖关系'}\r\n+`;\r\n+\r\n+    // Step 1: 使用 Explore Agent 基于蓝图信息深入分析代码\r\n+    console.log(`[Architecture Graph] Step 1: 启动 Explore Agent (基于蓝图信息补充分析)...`);\r\n+\r\n+    const explorePrompt = `我已经有了这个项目的蓝图分析结果，请基于这些信息深入代码库验证和补充实现细节：\r\n+\r\n+${blueprintContext}\r\n+\r\n+请针对上述蓝图信息，深入分析代码：\r\n+\r\n+1. **验证模块实现**：\r\n+   - 检查上述模块的实际代码文件\r\n+   - 找出每个模块的入口函数/类\r\n+   - 确认模块间的真实调用关系\r\n+\r\n+2. **补充数据流细节**：\r\n+   - 请求从哪个入口进入？\r\n+   - 核心处理流程是什么？\r\n+   - 响应如何组装返回？\r\n+\r\n+3. **发现关键实现**：\r\n+   - 核心类和函数有哪些？\r\n+   - 重要的数据结构？\r\n+   - 配置和常量定义？\r\n+\r\n+请使用 Glob、Grep、Read 工具深入代码，基于蓝图信息补充实现细节。\r\n+返回增强版的架构分析报告，要能用于生成准确的 Mermaid 架构图。`;\r\n+\r\n+    const taskManager = new TaskManager();\r\n+    const exploreResult = await taskManager.executeTaskSync(\r\n+      '基于蓝图分析代码架构',\r\n+      explorePrompt,\r\n+      'Explore',\r\n+      {\r\n+        workingDirectory: projectRoot,\r\n+      }\r\n+    );\r\n+\r\n+    console.log(`[Architecture Graph] Explore Agent 完成: ${exploreResult.success}`);\r\n+\r\n+    // 组合蓝图信息 + 探索结果\r\n+    let combinedAnalysis = blueprintContext;\r\n+    if (exploreResult.success && exploreResult.output) {\r\n+      combinedAnalysis += `\\n\\n【Explore Agent 补充的实现细节】:\\n${exploreResult.output}`;\r\n+      console.log(`[Architecture Graph] 获得补充分析: ${exploreResult.output.length} 字符`);\r\n+    } else {\r\n+      console.log(`[Architecture Graph] Explore Agent 失败: ${exploreResult.error}，将仅使用蓝图信息`);\r\n+    }\r\n+\r\n+    // Step 2: 基于组合信息生成 Mermaid 架构图\r\n+    console.log(`[Architecture Graph] Step 2: 基于蓝图+代码分析生成 Mermaid 图...`);\r\n+\r\n+    const prompt = `${ARCHITECTURE_GRAPH_PROMPTS[graphType]}\r\n+\r\n+=== 项目架构分析（蓝图 + 代码分析）===\r\n+${combinedAnalysis}\r\n+\r\n+请基于以上蓝图信息和代码分析结果，生成准确反映项目实际架构的 Mermaid 图表代码。\r\n+确保图表中的模块名称和关系与分析结果一致。\r\n+只返回 Mermaid 代码，不要其他解释。`;\r\n+\r\n+    // 获取认证信息（支持 API Key 和 OAuth）\r\n+    const auth = getAuth();\r\n+    const apiKey = auth?.apiKey || configManager.getApiKey();\r\n+    const authToken = auth?.type === 'oauth' ? (auth.accessToken || auth.authToken) : undefined;\r\n+\r\n+    if (!apiKey && !authToken) {\r\n+      return res.status(401).json({\r\n+        success: false,\r\n+        error: 'API 未认证，请先登录或配置 API Key',\r\n+      });\r\n+    }\r\n+\r\n+    // 使用 ClaudeClient 调用 AI 生成 Mermaid 图\r\n+    const { ClaudeClient } = await import('../../../core/client.js');\r\n+    const client = new ClaudeClient({\r\n+      apiKey,\r\n+      authToken,\r\n+      baseUrl: process.env.ANTHROPIC_BASE_URL,\r\n+    });\r\n+\r\n+    const response = await client.createMessage(\r\n+      [{ role: 'user', content: prompt }],\r\n+      undefined,\r\n+      '你是一个专业的软件架构师，擅长使用 Mermaid 绘制架构图。基于代码分析结果生成准确的架构图。只返回 Mermaid 代码，不要其他解释。'\r\n+    );\r\n+\r\n+    // 提取 Mermaid 代码\r\n+    let mermaidCode = '';\r\n+    for (const block of response.content) {\r\n+      if (block.type === 'text') {\r\n+        mermaidCode = block.text;\r\n+        break;\r\n+      }\r\n+    }\r\n+\r\n+    // 清理代码（移除 markdown 代码块标记）\r\n+    mermaidCode = mermaidCode\r\n+      .replace(/```mermaid\\n?/g, '')\r\n+      .replace(/```\\n?/g, '')\r\n+      .trim();\r\n+\r\n+    // 修复 Mermaid 保留关键字冲突\r\n+    // 在 sequenceDiagram 中，loop/alt/opt/par/rect/note 是保留关键字\r\n+    // 将这些作为参与者 ID 使用时会导致解析错误\r\n+    mermaidCode = mermaidCode\r\n+      // 修复 participant Loop -> participant MainLoop\r\n+      .replace(/participant\\s+Loop\\b/gi, 'participant MainLoop')\r\n+      .replace(/actor\\s+Loop\\b/gi, 'actor MainLoop')\r\n+      // 修复消息中的 Loop 引用 (如 User->>Loop: 改为 User->>MainLoop:)\r\n+      .replace(/->>Loop\\s*:/g, '->>MainLoop:')\r\n+      .replace(/-->>Loop\\s*:/g, '-->>MainLoop:')\r\n+      .replace(/Loop\\s*->>/g, 'MainLoop->>')\r\n+      .replace(/Loop\\s*-->>/g, 'MainLoop-->>');\r\n+\r\n+    // 修复方括号内包含斜杠的节点标签（Mermaid 词法错误）\r\n+    // 例如: ChatAPI[/api/chat] -> ChatAPI[\"/api/chat\"]\r\n+    // 方括号内的斜杠会导致 Mermaid 词法解析失败\r\n+    mermaidCode = mermaidCode\r\n+      .replace(/(\\w+)\\[([^\\]\"]*\\/[^\\]\"]*)\\]/g, '$1[\"$2\"]');\r\n+\r\n+    console.log(`[Architecture Graph] Mermaid 代码已清理，长度: ${mermaidCode.length}`);\r\n+\r\n+    const meta = ARCHITECTURE_GRAPH_META[graphType];\r\n+    const generatedAt = new Date().toLocaleString('zh-CN');\r\n+\r\n+    // 保存缓存\r\n+    architectureGraphCache.set(id, graphType, {\r\n+      type: graphType,\r\n+      title: meta.title,\r\n+      description: meta.description,\r\n+      mermaidCode,\r\n+      generatedAt,\r\n+      timestamp: Date.now(),\r\n+    });\r\n+\r\n+    console.log(`[Architecture Graph] 生成完成: ${mermaidCode.length} 字符`);\r\n+\r\n+    res.json({\r\n+      success: true,\r\n+      data: {\r\n+        type: graphType,\r\n+        title: meta.title,\r\n+        description: meta.description,\r\n+        mermaidCode,\r\n+        generatedAt,\r\n+      },\r\n+      fromCache: false,\r\n+    });\r\n+  } catch (error: any) {\r\n+    console.error('[Architecture Graph] 错误:', error);\r\n+    res.status(500).json({\r\n+      success: false,\r\n+      error: error.message || 'AI 生成架构图失败',\r\n+    });\r\n+  }\r\n+});\r\n+\r\n export default router;\r\n"
                },
                {
                    "date": 1768705554325,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6873,5 +6873,127 @@\n     });\r\n   }\r\n });\r\n \r\n+// ============================================================================\r\n+// 辅助函数\r\n+// ============================================================================\r\n+\r\n+/**\r\n+ * 将蓝图直接转换为 Mermaid 格式（确定性生成，无需 AI）\r\n+ */\r\n+function convertBlueprintToMermaid(blueprint: any, type: string): { title: string; description: string; mermaidCode: string } {\r\n+  const result = {\r\n+    title: '',\r\n+    description: '',\r\n+    mermaidCode: ''\r\n+  };\r\n+\r\n+  if (type === 'sequence' || type === 'dataflow') {\r\n+    // 1. 业务流程 -> 时序图\r\n+    const process = blueprint.businessProcesses?.[0]; // 默认取第一个，或者可以根据 query 参数指定\r\n+    if (!process) {\r\n+      result.title = '无业务流程';\r\n+      result.description = '蓝图中没有定义业务流程';\r\n+      result.mermaidCode = 'sequenceDiagram\\nNote over User: 无业务流程数据';\r\n+      return result;\r\n+    }\r\n+\r\n+    result.title = process.name;\r\n+    result.description = process.description || '业务流程时序图';\r\n+    \r\n+    let mermaid = 'sequenceDiagram\\n';\r\n+    mermaid += '    autonumber\\n';\r\n+    \r\n+    // 参与者定义（可选，美化用）\r\n+    const actors = process.actors || [];\r\n+    actors.forEach((actor: string) => {\r\n+       // 简单的名字清理，避免特殊字符\r\n+       const safeActor = actor.replace(/[^a-zA-Z0-9\\u4e00-\\u9fa5]/g, '_');\r\n+       mermaid += `    participant ${safeActor} as ${actor}\\n`;\r\n+    });\r\n+    \r\n+    // 步骤\r\n+    (process.steps || []).sort((a: any, b: any) => a.order - b.order).forEach((step: any) => {\r\n+      // 假设默认交互是从 User 到 System，或者根据 Actor 判断\r\n+      // 这里简化处理：如果 step.actor 是系统，则 System->System，或者是 User->System\r\n+      // 为了直观，我们尝试解析 \"actor\" 字段。\r\n+      \r\n+      const actorName = step.actor || 'System';\r\n+      const safeActor = actorName.replace(/[^a-zA-Z0-9\\u4e00-\\u9fa5]/g, '_');\r\n+      \r\n+      // 如果是第一步，通常是 User 发起\r\n+      if (step.order === 1) {\r\n+          mermaid += `    User->>${safeActor}: ${step.name}\\n`;\r\n+      } else {\r\n+          mermaid += `    ${safeActor}->>${safeActor}: ${step.name}\\n`;\r\n+      }\r\n+      \r\n+      if (step.description && step.description !== step.name) {\r\n+          mermaid += `    Note right of ${safeActor}: ${step.description}\\n`;\r\n+      }\r\n+    });\r\n+    \r\n+    result.mermaidCode = mermaid;\r\n+  } else if (type === 'modulerelation' || type === 'full') {\r\n+    // 2. 模块 -> 依赖关系图/类图\r\n+    // 使用 graph TD 或 classDiagram\r\n+    \r\n+    result.title = '系统模块依赖图';\r\n+    result.description = '基于蓝图定义的模块依赖关系';\r\n+    \r\n+    let chart = 'graph TD\\n';\r\n+    \r\n+    // 样式定义\r\n+    chart += '    %% 样式定义\\n';\r\n+    chart += '    classDef service fill:#f9f,stroke:#333,stroke-width:2px,color:black;\\n';\r\n+    chart += '    classDef backend fill:#bbf,stroke:#333,stroke-width:2px,color:black;\\n';\r\n+    chart += '    classDef frontend fill:#bfb,stroke:#333,stroke-width:2px,color:black;\\n';\r\n+    chart += '    classDef infrastructure fill:#ddd,stroke:#333,stroke-width:2px,color:black;\\n';\r\n+    \r\n+    const modules = blueprint.modules || [];\r\n+    \r\n+    if (modules.length === 0) {\r\n+        chart += '    Start[暂无模块] --> End[结束]\\n';\r\n+    }\r\n+    \r\n+    // 节点定义\r\n+    modules.forEach((mod: any) => {\r\n+        const safeId = mod.name.replace(/[^a-zA-Z0-9]/g, '_');\r\n+        const label = `${mod.name}\\\\n(${mod.type})`;\r\n+        chart += `    ${safeId}[\"${label}\"]\\n`;\r\n+        \r\n+        // 应用样式\r\n+        if (mod.type) {\r\n+            chart += `    class ${safeId} ${mod.type}\\n`;\r\n+        }\r\n+    });\r\n+    \r\n+    // 边定义 (依赖关系)\r\n+    modules.forEach((mod: any) => {\r\n+        const sourceId = mod.name.replace(/[^a-zA-Z0-9]/g, '_');\r\n+        \r\n+        if (mod.dependencies && mod.dependencies.length > 0) {\r\n+            mod.dependencies.forEach((depId: string) => {\r\n+                // depId 可能是 UUID，需要找到对应的 names\r\n+                const depMod = modules.find((m: any) => m.id === depId || m.name === depId);\r\n+                if (depMod) {\r\n+                    const targetId = depMod.name.replace(/[^a-zA-Z0-9]/g, '_');\r\n+                    chart += `    ${sourceId} --> ${targetId}\\n`;\r\n+                }\r\n+            });\r\n+        }\r\n+    });\r\n+\r\n+    // 如果类型是 'full'，可以尝试加入更多细节，这里暂时保持一致\r\n+    result.mermaidCode = chart;\r\n+  } else {\r\n+     // 默认回退\r\n+     result.title = '未支持的直接渲染类型';\r\n+     result.description = '请使用 AI 生成模式';\r\n+     result.mermaidCode = 'graph TD\\nA[不支持的图表类型] --> B[请切换模式]';\r\n+  }\r\n+\r\n+  return result;\r\n+}\r\n+\r\n export default router;\r\n"
                },
                {
                    "date": 1768705568929,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6663,29 +6663,8 @@\n     if (!blueprint) {\r\n       return res.status(404).json({ success: false, error: 'Blueprint not found' });\r\n     }\r\n \r\n-    // mode=direct 时，使用直接转换逻辑，不消耗 Token 也不等待\r\n-    if (req.query.mode === 'direct') {\r\n-       const directGraph = convertBlueprintToMermaid(blueprint, graphType);\r\n-       \r\n-       // 更新缓存\r\n-       const graphData: ArchitectureGraphData = {\r\n-         type: graphType,\r\n-         title: directGraph.title,\r\n-         description: directGraph.description,\r\n-         mermaidCode: directGraph.mermaidCode,\r\n-         generatedAt: new Date().toISOString(),\r\n-         nodePathMap: {} // 直接模式暂不支持复杂跳转，或者后续实现\r\n-       };\r\n-       architectureGraphCache.set(id, graphType, graphData);\r\n-\r\n-       return res.json({\r\n-         success: true,\r\n-         data: graphData\r\n-       });\r\n-    }\r\n-\r\n     // 获取项目根目录\r\n     const projectRoot = blueprint.projectPath || process.cwd();\r\n \r\n     console.log(`[Architecture Graph] 生成 ${graphType} 类型架构图...`);\r\n@@ -6873,127 +6852,5 @@\n     });\r\n   }\r\n });\r\n \r\n-// ============================================================================\r\n-// 辅助函数\r\n-// ============================================================================\r\n-\r\n-/**\r\n- * 将蓝图直接转换为 Mermaid 格式（确定性生成，无需 AI）\r\n- */\r\n-function convertBlueprintToMermaid(blueprint: any, type: string): { title: string; description: string; mermaidCode: string } {\r\n-  const result = {\r\n-    title: '',\r\n-    description: '',\r\n-    mermaidCode: ''\r\n-  };\r\n-\r\n-  if (type === 'sequence' || type === 'dataflow') {\r\n-    // 1. 业务流程 -> 时序图\r\n-    const process = blueprint.businessProcesses?.[0]; // 默认取第一个，或者可以根据 query 参数指定\r\n-    if (!process) {\r\n-      result.title = '无业务流程';\r\n-      result.description = '蓝图中没有定义业务流程';\r\n-      result.mermaidCode = 'sequenceDiagram\\nNote over User: 无业务流程数据';\r\n-      return result;\r\n-    }\r\n-\r\n-    result.title = process.name;\r\n-    result.description = process.description || '业务流程时序图';\r\n-    \r\n-    let mermaid = 'sequenceDiagram\\n';\r\n-    mermaid += '    autonumber\\n';\r\n-    \r\n-    // 参与者定义（可选，美化用）\r\n-    const actors = process.actors || [];\r\n-    actors.forEach((actor: string) => {\r\n-       // 简单的名字清理，避免特殊字符\r\n-       const safeActor = actor.replace(/[^a-zA-Z0-9\\u4e00-\\u9fa5]/g, '_');\r\n-       mermaid += `    participant ${safeActor} as ${actor}\\n`;\r\n-    });\r\n-    \r\n-    // 步骤\r\n-    (process.steps || []).sort((a: any, b: any) => a.order - b.order).forEach((step: any) => {\r\n-      // 假设默认交互是从 User 到 System，或者根据 Actor 判断\r\n-      // 这里简化处理：如果 step.actor 是系统，则 System->System，或者是 User->System\r\n-      // 为了直观，我们尝试解析 \"actor\" 字段。\r\n-      \r\n-      const actorName = step.actor || 'System';\r\n-      const safeActor = actorName.replace(/[^a-zA-Z0-9\\u4e00-\\u9fa5]/g, '_');\r\n-      \r\n-      // 如果是第一步，通常是 User 发起\r\n-      if (step.order === 1) {\r\n-          mermaid += `    User->>${safeActor}: ${step.name}\\n`;\r\n-      } else {\r\n-          mermaid += `    ${safeActor}->>${safeActor}: ${step.name}\\n`;\r\n-      }\r\n-      \r\n-      if (step.description && step.description !== step.name) {\r\n-          mermaid += `    Note right of ${safeActor}: ${step.description}\\n`;\r\n-      }\r\n-    });\r\n-    \r\n-    result.mermaidCode = mermaid;\r\n-  } else if (type === 'modulerelation' || type === 'full') {\r\n-    // 2. 模块 -> 依赖关系图/类图\r\n-    // 使用 graph TD 或 classDiagram\r\n-    \r\n-    result.title = '系统模块依赖图';\r\n-    result.description = '基于蓝图定义的模块依赖关系';\r\n-    \r\n-    let chart = 'graph TD\\n';\r\n-    \r\n-    // 样式定义\r\n-    chart += '    %% 样式定义\\n';\r\n-    chart += '    classDef service fill:#f9f,stroke:#333,stroke-width:2px,color:black;\\n';\r\n-    chart += '    classDef backend fill:#bbf,stroke:#333,stroke-width:2px,color:black;\\n';\r\n-    chart += '    classDef frontend fill:#bfb,stroke:#333,stroke-width:2px,color:black;\\n';\r\n-    chart += '    classDef infrastructure fill:#ddd,stroke:#333,stroke-width:2px,color:black;\\n';\r\n-    \r\n-    const modules = blueprint.modules || [];\r\n-    \r\n-    if (modules.length === 0) {\r\n-        chart += '    Start[暂无模块] --> End[结束]\\n';\r\n-    }\r\n-    \r\n-    // 节点定义\r\n-    modules.forEach((mod: any) => {\r\n-        const safeId = mod.name.replace(/[^a-zA-Z0-9]/g, '_');\r\n-        const label = `${mod.name}\\\\n(${mod.type})`;\r\n-        chart += `    ${safeId}[\"${label}\"]\\n`;\r\n-        \r\n-        // 应用样式\r\n-        if (mod.type) {\r\n-            chart += `    class ${safeId} ${mod.type}\\n`;\r\n-        }\r\n-    });\r\n-    \r\n-    // 边定义 (依赖关系)\r\n-    modules.forEach((mod: any) => {\r\n-        const sourceId = mod.name.replace(/[^a-zA-Z0-9]/g, '_');\r\n-        \r\n-        if (mod.dependencies && mod.dependencies.length > 0) {\r\n-            mod.dependencies.forEach((depId: string) => {\r\n-                // depId 可能是 UUID，需要找到对应的 names\r\n-                const depMod = modules.find((m: any) => m.id === depId || m.name === depId);\r\n-                if (depMod) {\r\n-                    const targetId = depMod.name.replace(/[^a-zA-Z0-9]/g, '_');\r\n-                    chart += `    ${sourceId} --> ${targetId}\\n`;\r\n-                }\r\n-            });\r\n-        }\r\n-    });\r\n-\r\n-    // 如果类型是 'full'，可以尝试加入更多细节，这里暂时保持一致\r\n-    result.mermaidCode = chart;\r\n-  } else {\r\n-     // 默认回退\r\n-     result.title = '未支持的直接渲染类型';\r\n-     result.description = '请使用 AI 生成模式';\r\n-     result.mermaidCode = 'graph TD\\nA[不支持的图表类型] --> B[请切换模式]';\r\n-  }\r\n-\r\n-  return result;\r\n-}\r\n-\r\n export default router;\r\n"
                },
                {
                    "date": 1768706398080,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6817,8 +6817,29 @@\n       .replace(/(\\w+)\\[([^\\]\"]*\\/[^\\]\"]*)\\]/g, '$1[\"$2\"]');\r\n \r\n     console.log(`[Architecture Graph] Mermaid 代码已清理，长度: ${mermaidCode.length}`);\r\n \r\n+    // mode=direct 时，使用直接转换逻辑，不消耗 Token 也不等待\r\n+    if (req.query.mode === 'direct') {\r\n+       const directGraph = convertBlueprintToMermaid(blueprint, graphType);\r\n+       \r\n+       // 更新缓存\r\n+       const graphData: ArchitectureGraphCacheEntry = {\r\n+         type: graphType as ArchitectureGraphType,\r\n+         title: directGraph.title,\r\n+         description: directGraph.description,\r\n+         mermaidCode: directGraph.mermaidCode,\r\n+         generatedAt: new Date().toISOString(),\r\n+         timestamp: Date.now(),\r\n+         nodePathMap: {} // 直接模式暂不支持复杂跳转，或者后续实现\r\n+       };\r\n+       architectureGraphCache.set(id, graphType as ArchitectureGraphType, graphData);\r\n+\r\n+       return res.json({\r\n+         success: true,\r\n+         data: graphData\r\n+       });\r\n+    }\r\n     const meta = ARCHITECTURE_GRAPH_META[graphType];\r\n     const generatedAt = new Date().toLocaleString('zh-CN');\r\n \r\n     // 保存缓存\r\n"
                },
                {
                    "date": 1768706439122,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6663,8 +6663,30 @@\n     if (!blueprint) {\r\n       return res.status(404).json({ success: false, error: 'Blueprint not found' });\r\n     }\r\n \r\n+    // mode=direct 时，使用直接转换逻辑，不消耗 Token 也不等待\r\n+    if (req.query.mode === 'direct') {\r\n+       const directGraph = convertBlueprintToMermaid(blueprint, graphType);\r\n+       \r\n+       // 更新缓存\r\n+       const graphData: ArchitectureGraphCacheEntry = {\r\n+         type: graphType as ArchitectureGraphType,\r\n+         title: directGraph.title,\r\n+         description: directGraph.description,\r\n+         mermaidCode: directGraph.mermaidCode,\r\n+         generatedAt: new Date().toISOString(),\r\n+         timestamp: Date.now(),\r\n+         nodePathMap: {} // 直接模式暂不支持复杂跳转，或者后续实现\r\n+       };\r\n+       architectureGraphCache.set(id, graphType as ArchitectureGraphType, graphData);\r\n+\r\n+       return res.json({\r\n+         success: true,\r\n+         data: graphData\r\n+       });\r\n+    }\r\n+\r\n     // 获取项目根目录\r\n     const projectRoot = blueprint.projectPath || process.cwd();\r\n \r\n     console.log(`[Architecture Graph] 生成 ${graphType} 类型架构图...`);\r\n@@ -6817,29 +6839,9 @@\n       .replace(/(\\w+)\\[([^\\]\"]*\\/[^\\]\"]*)\\]/g, '$1[\"$2\"]');\r\n \r\n     console.log(`[Architecture Graph] Mermaid 代码已清理，长度: ${mermaidCode.length}`);\r\n \r\n-    // mode=direct 时，使用直接转换逻辑，不消耗 Token 也不等待\r\n-    if (req.query.mode === 'direct') {\r\n-       const directGraph = convertBlueprintToMermaid(blueprint, graphType);\r\n-       \r\n-       // 更新缓存\r\n-       const graphData: ArchitectureGraphCacheEntry = {\r\n-         type: graphType as ArchitectureGraphType,\r\n-         title: directGraph.title,\r\n-         description: directGraph.description,\r\n-         mermaidCode: directGraph.mermaidCode,\r\n-         generatedAt: new Date().toISOString(),\r\n-         timestamp: Date.now(),\r\n-         nodePathMap: {} // 直接模式暂不支持复杂跳转，或者后续实现\r\n-       };\r\n-       architectureGraphCache.set(id, graphType as ArchitectureGraphType, graphData);\r\n \r\n-       return res.json({\r\n-         success: true,\r\n-         data: graphData\r\n-       });\r\n-    }\r\n     const meta = ARCHITECTURE_GRAPH_META[graphType];\r\n     const generatedAt = new Date().toLocaleString('zh-CN');\r\n \r\n     // 保存缓存\r\n@@ -6874,4 +6876,120 @@\n   }\r\n });\r\n \r\n export default router;\r\n+\r\n+// ============================================================================\r\n+// 辅助函数\r\n+// ============================================================================\r\n+\r\n+/**\r\n+ * 将蓝图直接转换为 Mermaid 格式（确定性生成，无需 AI）\r\n+ */\r\n+function convertBlueprintToMermaid(blueprint: any, type: string): { title: string; description: string; mermaidCode: string } {\r\n+  const result = {\r\n+    title: '',\r\n+    description: '',\r\n+    mermaidCode: ''\r\n+  };\r\n+\r\n+  if (type === 'sequence' || type === 'dataflow') {\r\n+    // 1. 业务流程 -> 时序图\r\n+    const process = blueprint.businessProcesses?.[0]; // 默认取第一个，或者可以根据 query 参数指定\r\n+    if (!process) {\r\n+      result.title = '无业务流程';\r\n+      result.description = '蓝图中没有定义业务流程';\r\n+      result.mermaidCode = 'sequenceDiagram\\nNote over User: 无业务流程数据';\r\n+      return result;\r\n+    }\r\n+\r\n+    result.title = process.name;\r\n+    result.description = process.description || '业务流程时序图';\r\n+    \r\n+    let mermaid = 'sequenceDiagram\\n';\r\n+    mermaid += '    autonumber\\n';\r\n+    \r\n+    // 参与者定义（可选，美化用）\r\n+    const actors = process.actors || [];\r\n+    actors.forEach((actor: string) => {\r\n+       // 简单的名字清理，避免特殊字符\r\n+       const safeActor = actor.replace(/[^a-zA-Z0-9\\u4e00-\\u9fa5]/g, '_');\r\n+       mermaid += `    participant ${safeActor} as ${actor}\\n`;\r\n+    });\r\n+    \r\n+    // 步骤\r\n+    (process.steps || []).sort((a: any, b: any) => a.order - b.order).forEach((step: any) => {\r\n+      const actorName = step.actor || 'System';\r\n+      const safeActor = actorName.replace(/[^a-zA-Z0-9\\u4e00-\\u9fa5]/g, '_');\r\n+      \r\n+      // 如果是第一步，通常是 User 发起\r\n+      if (step.order === 1) {\r\n+          mermaid += `    User->>${safeActor}: ${step.name}\\n`;\r\n+      } else {\r\n+          mermaid += `    ${safeActor}->>${safeActor}: ${step.name}\\n`;\r\n+      }\r\n+      \r\n+      if (step.description && step.description !== step.name) {\r\n+          mermaid += `    Note right of ${safeActor}: ${step.description}\\n`;\r\n+      }\r\n+    });\r\n+    \r\n+    result.mermaidCode = mermaid;\r\n+  } else if (type === 'modulerelation' || type === 'full') {\r\n+    // 2. 模块 -> 依赖关系图/类图\r\n+    // 使用 graph TD 或 classDiagram\r\n+    \r\n+    result.title = '系统模块依赖图';\r\n+    result.description = '基于蓝图定义的模块依赖关系';\r\n+    \r\n+    let chart = 'graph TD\\n';\r\n+    \r\n+    // 样式定义\r\n+    chart += '    %% 样式定义\\n';\r\n+    chart += '    classDef service fill:#f9f,stroke:#333,stroke-width:2px,color:black;\\n';\r\n+    chart += '    classDef backend fill:#bbf,stroke:#333,stroke-width:2px,color:black;\\n';\r\n+    chart += '    classDef frontend fill:#bfb,stroke:#333,stroke-width:2px,color:black;\\n';\r\n+    chart += '    classDef infrastructure fill:#ddd,stroke:#333,stroke-width:2px,color:black;\\n';\r\n+    \r\n+    const modules = blueprint.modules || [];\r\n+    \r\n+    if (modules.length === 0) {\r\n+        chart += '    Start[暂无模块] --> End[结束]\\n';\r\n+    }\r\n+    \r\n+    // 节点定义\r\n+    modules.forEach((mod: any) => {\r\n+        const safeId = mod.name.replace(/[^a-zA-Z0-9]/g, '_');\r\n+        const label = `${mod.name}\\\\n(${mod.type})`;\r\n+        chart += `    ${safeId}[\"${label}\"]\\n`;\r\n+        \r\n+        // 应用样式\r\n+        if (mod.type) {\r\n+            chart += `    class ${safeId} ${mod.type}\\n`;\r\n+        }\r\n+    });\r\n+    \r\n+    // 边定义 (依赖关系)\r\n+    modules.forEach((mod: any) => {\r\n+        const sourceId = mod.name.replace(/[^a-zA-Z0-9]/g, '_');\r\n+        \r\n+        if (mod.dependencies && mod.dependencies.length > 0) {\r\n+            mod.dependencies.forEach((depId: string) => {\r\n+                const depMod = modules.find((m: any) => m.id === depId || m.name === depId);\r\n+                if (depMod) {\r\n+                    const targetId = depMod.name.replace(/[^a-zA-Z0-9]/g, '_');\r\n+                    chart += `    ${sourceId} --> ${targetId}\\n`;\r\n+                }\r\n+            });\r\n+        }\r\n+    });\r\n+\r\n+    result.mermaidCode = chart;\r\n+  } else {\r\n+     // 默认回退\r\n+     result.title = '未支持的直接渲染类型';\r\n+     result.description = '请使用 AI 生成模式';\r\n+     result.mermaidCode = 'graph TD\\nA[不支持的图表类型] --> B[请切换模式]';\r\n+  }\r\n+\r\n+  return result;\r\n+}\r\n"
                }
            ],
            "date": 1768364953091,
            "name": "Commit-0",
            "content": "/**\r\n * 蓝图系统 API 路由\r\n *\r\n * 提供：\r\n * 1. 蓝图管理 API\r\n * 2. 任务树管理 API\r\n * 3. Agent 协调 API\r\n * 4. 时光倒流 API\r\n * 5. 实时事件推送（WebSocket）\r\n */\r\n\r\nimport { Router, Request, Response } from 'express';\r\nimport * as path from 'path';\r\nimport * as fs from 'fs';\r\nimport {\r\n  blueprintManager,\r\n  taskTreeManager,\r\n  agentCoordinator,\r\n  tddExecutor,\r\n  generateBlueprintSummary,\r\n  codebaseAnalyzer,\r\n  requirementDialogManager,\r\n} from '../../../blueprint/index.js';\r\nimport { timeTravelManager } from '../../../blueprint/time-travel.js';\r\nimport { analysisCache } from '../../../blueprint/analysis-cache.js';\r\nimport { CallGraphBuilder } from '../../../map/call-graph-builder.js';\r\nimport type { ModuleNode, CallGraphNode, CallGraphEdge } from '../../../map/types.js';\r\nimport { classifySymbol, canGenerateCallGraph } from './symbol-classifier.js';\r\nimport { calculateTotalLines, groupByDirectory, detectEntryPoints, getCoreSymbols } from './project-map-generator.js';\r\n\r\nconst router = Router();\r\n\r\n// ============================================================================\r\n// 蓝图 API\r\n// ============================================================================\r\n\r\n/**\r\n * 获取所有蓝图\r\n */\r\nrouter.get('/blueprints', (req: Request, res: Response) => {\r\n  try {\r\n    const blueprints = blueprintManager.getAllBlueprints();\r\n    res.json({\r\n      success: true,\r\n      data: blueprints.map(b => ({\r\n        id: b.id,\r\n        name: b.name,\r\n        description: b.description,\r\n        version: b.version,\r\n        status: b.status,\r\n        createdAt: b.createdAt,\r\n        updatedAt: b.updatedAt,\r\n        moduleCount: b.modules?.length || 0,\r\n        processCount: b.businessProcesses?.length || 0,\r\n        nfrCount: b.nfrs?.length || 0,\r\n      })),\r\n      total: blueprints.length,\r\n    });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 获取单个蓝图详情\r\n */\r\nrouter.get('/blueprints/:id', (req: Request, res: Response) => {\r\n  try {\r\n    const blueprint = blueprintManager.getBlueprint(req.params.id);\r\n    if (!blueprint) {\r\n      return res.status(404).json({ success: false, error: 'Blueprint not found' });\r\n    }\r\n    res.json({ success: true, data: blueprint });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 获取蓝图摘要（Markdown 格式）\r\n */\r\nrouter.get('/blueprints/:id/summary', (req: Request, res: Response) => {\r\n  try {\r\n    const blueprint = blueprintManager.getBlueprint(req.params.id);\r\n    if (!blueprint) {\r\n      return res.status(404).json({ success: false, error: 'Blueprint not found' });\r\n    }\r\n    const summary = generateBlueprintSummary(blueprint);\r\n    res.json({ success: true, data: summary });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 创建新蓝图\r\n */\r\nrouter.post('/blueprints', (req: Request, res: Response) => {\r\n  try {\r\n    const { name, description } = req.body;\r\n    const blueprint = blueprintManager.createBlueprint(name, description);\r\n    res.json({ success: true, data: blueprint });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 添加系统模块\r\n */\r\nrouter.post('/blueprints/:id/modules', (req: Request, res: Response) => {\r\n  try {\r\n    const module = blueprintManager.addModule(req.params.id, req.body);\r\n    res.json({ success: true, data: module });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 添加业务流程\r\n */\r\nrouter.post('/blueprints/:id/processes', (req: Request, res: Response) => {\r\n  try {\r\n    const process = blueprintManager.addBusinessProcess(req.params.id, req.body);\r\n    res.json({ success: true, data: process });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 提交审核\r\n */\r\nrouter.post('/blueprints/:id/submit', (req: Request, res: Response) => {\r\n  try {\r\n    const blueprint = blueprintManager.submitForReview(req.params.id);\r\n    res.json({ success: true, data: blueprint });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 批准蓝图\r\n */\r\nrouter.post('/blueprints/:id/approve', (req: Request, res: Response) => {\r\n  try {\r\n    const { approvedBy } = req.body;\r\n    const blueprint = blueprintManager.approveBlueprint(req.params.id, approvedBy);\r\n    res.json({ success: true, data: blueprint });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 拒绝蓝图\r\n */\r\nrouter.post('/blueprints/:id/reject', (req: Request, res: Response) => {\r\n  try {\r\n    const { reason } = req.body;\r\n    const blueprint = blueprintManager.rejectBlueprint(req.params.id, reason);\r\n    res.json({ success: true, data: blueprint });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 删除蓝图\r\n */\r\nrouter.delete('/blueprints/:id', (req: Request, res: Response) => {\r\n  try {\r\n    const success = blueprintManager.deleteBlueprint(req.params.id);\r\n    if (!success) {\r\n      return res.status(404).json({ success: false, error: 'Blueprint not found' });\r\n    }\r\n    res.json({ success: true, message: '蓝图已删除' });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n// ============================================================================\r\n// 项目地图 API\r\n// ============================================================================\r\n\r\n/**\r\n * GET /api/blueprint/project-map\r\n *\r\n * 返回项目概览信息\r\n */\r\nrouter.get('/project-map', async (req: Request, res: Response) => {\r\n  try {\r\n    const projectRoot = process.cwd();\r\n    console.log('[Project Map] 开始生成项目地图...');\r\n\r\n    // 1. 扫描 TypeScript 文件\r\n    const tsFiles: string[] = [];\r\n    const srcPath = path.join(projectRoot, 'src');\r\n\r\n    const scanDir = (dir: string) => {\r\n      if (!fs.existsSync(dir)) return;\r\n      const entries = fs.readdirSync(dir, { withFileTypes: true });\r\n\r\n      for (const entry of entries) {\r\n        const fullPath = path.join(dir, entry.name);\r\n        if (entry.isDirectory()) {\r\n          if (['node_modules', 'dist', '.git', '.lh', 'coverage'].includes(entry.name)) continue;\r\n          scanDir(fullPath);\r\n        } else if (entry.isFile()) {\r\n          const ext = path.extname(entry.name);\r\n          if (['.ts', '.tsx'].includes(ext)) {\r\n            tsFiles.push(fullPath);\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    scanDir(srcPath);\r\n    console.log(`[Project Map] 扫描到 ${tsFiles.length} 个 TypeScript 文件`);\r\n\r\n    // 2. 模块统计\r\n    const totalLines = await calculateTotalLines(tsFiles);\r\n    const byDirectory = groupByDirectory(tsFiles);\r\n\r\n    const moduleStats = {\r\n      totalFiles: tsFiles.length,\r\n      totalLines,\r\n      byDirectory,\r\n      languages: { typescript: tsFiles.length },\r\n    };\r\n\r\n    console.log(`[Project Map] 模块统计: ${moduleStats.totalFiles} 文件, ${moduleStats.totalLines} 行代码`);\r\n\r\n    // 3. 架构分层（如果存在 layer-classifier）\r\n    let layers = null;\r\n    try {\r\n      const { LayerClassifier } = await import('../../../map/layer-classifier.js');\r\n      const { CodeMapAnalyzer } = await import('../../../map/analyzer.js');\r\n\r\n      // 使用 analyzer 提取模块信息\r\n      const modules: ModuleNode[] = [];\r\n      const analyzer = new CodeMapAnalyzer(projectRoot);\r\n\r\n      for (const file of tsFiles.slice(0, 100)) { // 限制数量避免太慢\r\n        try {\r\n          const module = await analyzer.analyzeFile(file);\r\n          if (module) {\r\n            modules.push(module);\r\n          }\r\n        } catch (err) {\r\n          // 忽略分析失败的文件\r\n        }\r\n      }\r\n\r\n      // 分类\r\n      const classifier = new LayerClassifier();\r\n      const classifications = classifier.classifyAll(modules);\r\n\r\n      // 统计每层的模块数\r\n      const layerStats: Record<string, number> = {};\r\n      for (const [, result] of classifications) {\r\n        layerStats[result.layer] = (layerStats[result.layer] || 0) + 1;\r\n      }\r\n\r\n      layers = {\r\n        total: classifications.size,\r\n        distribution: layerStats,\r\n      };\r\n\r\n      console.log(`[Project Map] 架构分层: ${JSON.stringify(layerStats)}`);\r\n    } catch (err) {\r\n      console.log(`[Project Map] 架构分层分析跳过: ${err}`);\r\n      // Layer classifier 不存在或分析失败时跳过\r\n    }\r\n\r\n    // 4. 入口点检测\r\n    const entryPoints = await detectEntryPoints(tsFiles);\r\n    console.log(`[Project Map] 检测到 ${entryPoints.length} 个入口点`);\r\n\r\n    // 5. 核心符号 (简化版本，从文件中提取符号)\r\n    const allSymbols: any[] = [];\r\n    try {\r\n      // 使用 LSP 分析器提取符号\r\n      const { TypeScriptLSPAnalyzer } = await import('./lsp-analyzer.js');\r\n      const lspAnalyzer = new TypeScriptLSPAnalyzer();\r\n      lspAnalyzer.initProgram(tsFiles.slice(0, 50), projectRoot); // 限制数量\r\n\r\n      for (const file of tsFiles.slice(0, 50)) {\r\n        try {\r\n          const { functions, classes } = lspAnalyzer.analyzeFile(file);\r\n          const relativePath = path.relative(projectRoot, file);\r\n\r\n          for (const func of functions) {\r\n            allSymbols.push({\r\n              name: func.name,\r\n              kind: 'function',\r\n              moduleId: relativePath,\r\n            });\r\n          }\r\n\r\n          for (const cls of classes) {\r\n            allSymbols.push({\r\n              name: cls.name,\r\n              kind: 'class',\r\n              moduleId: relativePath,\r\n            });\r\n\r\n            for (const method of cls.methods) {\r\n              allSymbols.push({\r\n                name: method.name,\r\n                kind: 'method',\r\n                moduleId: relativePath,\r\n              });\r\n            }\r\n          }\r\n        } catch (err) {\r\n          // 忽略分析失败的文件\r\n        }\r\n      }\r\n    } catch (err) {\r\n      console.log(`[Project Map] LSP 符号提取失败: ${err}`);\r\n      // LSP 分析器不存在时跳过\r\n    }\r\n\r\n    const coreSymbols = await getCoreSymbols(allSymbols);\r\n    console.log(`[Project Map] 核心符号: ${coreSymbols.classes.length} 类, ${coreSymbols.functions.length} 函数`);\r\n\r\n    console.log('[Project Map] 项目地图生成完成!');\r\n\r\n    res.json({\r\n      success: true,\r\n      data: { moduleStats, layers, entryPoints, coreSymbols },\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[Project Map] 错误:', error);\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * GET /api/blueprint/treemap\r\n *\r\n * 返回项目 Treemap 数据（矩形树图）\r\n *\r\n * 查询参数:\r\n * - maxDepth: 最大深度 (默认 4)\r\n */\r\nrouter.get('/treemap', async (req: Request, res: Response) => {\r\n  try {\r\n    const { maxDepth = '4', includeSymbols = 'false' } = req.query;\r\n    const projectRoot = process.cwd();\r\n    const withSymbols = includeSymbols === 'true';\r\n\r\n    console.log(`[Treemap] 开始生成 Treemap 数据... (符号级别: ${withSymbols})`);\r\n\r\n    // 动态导入 treemap 生成函数\r\n    const { generateTreemapDataAsync } = await import('./project-map-generator.js');\r\n\r\n    const treemapData = await generateTreemapDataAsync(\r\n      projectRoot,\r\n      parseInt(maxDepth as string, 10),\r\n      ['node_modules', '.git', 'dist', 'build', '.next', 'coverage', '__pycache__'],\r\n      withSymbols\r\n    );\r\n\r\n    console.log('[Treemap] Treemap 数据生成完成!');\r\n\r\n    res.json({\r\n      success: true,\r\n      data: treemapData,\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[Treemap] 错误:', error);\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * GET /api/blueprint/layered-treemap\r\n *\r\n * 分层加载 Treemap 数据（地图模式）\r\n *\r\n * 查询参数:\r\n * - level: 缩放级别 0-4 (PROJECT/MODULE/FILE/SYMBOL/CODE)\r\n * - path: 聚焦路径（可选）\r\n * - depth: 加载深度，默认 1\r\n */\r\nrouter.get('/layered-treemap', async (req: Request, res: Response) => {\r\n  try {\r\n    const {\r\n      level = '0',\r\n      path: focusPath = '',\r\n      depth = '1'\r\n    } = req.query;\r\n\r\n    const projectRoot = process.cwd();\r\n    const zoomLevel = parseInt(level as string, 10);\r\n    const loadDepth = parseInt(depth as string, 10);\r\n\r\n    console.log(`[LayeredTreemap] 加载数据: level=${zoomLevel}, path=${focusPath}, depth=${loadDepth}`);\r\n\r\n    // 动态导入分层加载函数\r\n    const { generateLayeredTreemapData, ZoomLevel } = await import('./project-map-generator.js');\r\n\r\n    // 验证缩放级别\r\n    if (zoomLevel < ZoomLevel.PROJECT || zoomLevel > ZoomLevel.CODE) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: `无效的缩放级别: ${zoomLevel}，应为 0-4`\r\n      });\r\n    }\r\n\r\n    const result = await generateLayeredTreemapData(\r\n      projectRoot,\r\n      zoomLevel as typeof ZoomLevel[keyof typeof ZoomLevel],\r\n      focusPath as string,\r\n      loadDepth,\r\n      ['node_modules', '.git', 'dist', 'build', '.next', 'coverage', '__pycache__']\r\n    );\r\n\r\n    console.log(`[LayeredTreemap] 数据加载完成: ${result.stats.childCount} 个子节点`);\r\n\r\n    res.json({\r\n      success: true,\r\n      data: result,\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[LayeredTreemap] 错误:', error);\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * GET /api/blueprint/layered-treemap/children\r\n *\r\n * 懒加载特定节点的子节点\r\n *\r\n * 查询参数:\r\n * - path: 节点路径\r\n * - level: 当前缩放级别\r\n */\r\nrouter.get('/layered-treemap/children', async (req: Request, res: Response) => {\r\n  try {\r\n    const {\r\n      path: nodePath,\r\n      level = '1'\r\n    } = req.query;\r\n\r\n    if (!nodePath) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: '缺少节点路径参数'\r\n      });\r\n    }\r\n\r\n    const projectRoot = process.cwd();\r\n    const zoomLevel = parseInt(level as string, 10);\r\n\r\n    console.log(`[LayeredTreemap] 懒加载子节点: path=${nodePath}, level=${zoomLevel}`);\r\n\r\n    // 动态导入懒加载函数\r\n    const { loadNodeChildren, ZoomLevel } = await import('./project-map-generator.js');\r\n\r\n    const children = await loadNodeChildren(\r\n      projectRoot,\r\n      nodePath as string,\r\n      zoomLevel as typeof ZoomLevel[keyof typeof ZoomLevel],\r\n      ['node_modules', '.git', 'dist', 'build', '.next', 'coverage', '__pycache__']\r\n    );\r\n\r\n    console.log(`[LayeredTreemap] 加载完成: ${children.length} 个子节点`);\r\n\r\n    res.json({\r\n      success: true,\r\n      data: children,\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[LayeredTreemap] 懒加载错误:', error);\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n// ============================================================================\r\n// 文件树 & 节点分析 API\r\n// ============================================================================\r\n\r\n/**\r\n * 文件树节点接口\r\n */\r\ninterface FileTreeNode {\r\n  name: string;\r\n  path: string;\r\n  type: 'file' | 'directory';\r\n  children?: FileTreeNode[];\r\n}\r\n\r\n/**\r\n * 读取文件内容\r\n */\r\nrouter.get('/file-content', (req: Request, res: Response) => {\r\n  try {\r\n    const filePath = req.query.path as string;\r\n    if (!filePath) {\r\n      return res.status(400).json({ success: false, error: '缺少文件路径参数' });\r\n    }\r\n\r\n    const absolutePath = path.resolve(process.cwd(), filePath);\r\n\r\n    // 安全检查：确保路径在项目目录内\r\n    const cwd = process.cwd();\r\n    if (!absolutePath.startsWith(cwd)) {\r\n      return res.status(403).json({ success: false, error: '禁止访问项目目录外的文件' });\r\n    }\r\n\r\n    // 检查文件是否存在\r\n    if (!fs.existsSync(absolutePath)) {\r\n      return res.status(404).json({ success: false, error: `文件不存在: ${filePath}` });\r\n    }\r\n\r\n    const stats = fs.statSync(absolutePath);\r\n    if (!stats.isFile()) {\r\n      return res.status(400).json({ success: false, error: '路径不是文件' });\r\n    }\r\n\r\n    // 检查文件大小（限制 1MB）\r\n    if (stats.size > 1024 * 1024) {\r\n      return res.status(413).json({ success: false, error: '文件过大，超过 1MB 限制' });\r\n    }\r\n\r\n    // 读取文件内容\r\n    const content = fs.readFileSync(absolutePath, 'utf-8');\r\n\r\n    // 获取文件扩展名用于语法高亮\r\n    const ext = path.extname(filePath).toLowerCase();\r\n    const languageMap: Record<string, string> = {\r\n      '.ts': 'typescript',\r\n      '.tsx': 'typescript',\r\n      '.js': 'javascript',\r\n      '.jsx': 'javascript',\r\n      '.json': 'json',\r\n      '.css': 'css',\r\n      '.scss': 'scss',\r\n      '.less': 'less',\r\n      '.html': 'html',\r\n      '.md': 'markdown',\r\n      '.py': 'python',\r\n      '.go': 'go',\r\n      '.rs': 'rust',\r\n      '.java': 'java',\r\n      '.c': 'c',\r\n      '.cpp': 'cpp',\r\n      '.h': 'c',\r\n      '.hpp': 'cpp',\r\n      '.yaml': 'yaml',\r\n      '.yml': 'yaml',\r\n      '.xml': 'xml',\r\n      '.sh': 'bash',\r\n      '.bat': 'batch',\r\n      '.ps1': 'powershell',\r\n      '.sql': 'sql',\r\n    };\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        path: filePath,\r\n        content,\r\n        language: languageMap[ext] || 'plaintext',\r\n        size: stats.size,\r\n        modifiedAt: stats.mtime.toISOString(),\r\n      },\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[File Content Error]', error);\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 保存文件内容\r\n */\r\nrouter.put('/file-content', (req: Request, res: Response) => {\r\n  try {\r\n    const { path: filePath, content } = req.body;\r\n\r\n    if (!filePath) {\r\n      return res.status(400).json({ success: false, error: '缺少文件路径参数' });\r\n    }\r\n\r\n    if (typeof content !== 'string') {\r\n      return res.status(400).json({ success: false, error: '内容必须是字符串' });\r\n    }\r\n\r\n    const absolutePath = path.resolve(process.cwd(), filePath);\r\n\r\n    // 安全检查：确保路径在项目目录内\r\n    const cwd = process.cwd();\r\n    if (!absolutePath.startsWith(cwd)) {\r\n      return res.status(403).json({ success: false, error: '禁止修改项目目录外的文件' });\r\n    }\r\n\r\n    // 检查文件是否存在\r\n    if (!fs.existsSync(absolutePath)) {\r\n      return res.status(404).json({ success: false, error: `文件不存在: ${filePath}` });\r\n    }\r\n\r\n    // 写入文件\r\n    fs.writeFileSync(absolutePath, content, 'utf-8');\r\n\r\n    const stats = fs.statSync(absolutePath);\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        path: filePath,\r\n        size: stats.size,\r\n        modifiedAt: stats.mtime.toISOString(),\r\n      },\r\n      message: '文件保存成功',\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[File Save Error]', error);\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 获取目录树结构\r\n */\r\nrouter.get('/file-tree', (req: Request, res: Response) => {\r\n  try {\r\n    const root = (req.query.root as string) || 'src';\r\n    const absoluteRoot = path.resolve(process.cwd(), root);\r\n\r\n    // 检查目录是否存在\r\n    if (!fs.existsSync(absoluteRoot)) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        error: `目录不存在: ${root}`,\r\n      });\r\n    }\r\n\r\n    // 递归构建文件树\r\n    const buildTree = (dirPath: string, relativePath: string): FileTreeNode => {\r\n      const name = path.basename(dirPath);\r\n      const stats = fs.statSync(dirPath);\r\n\r\n      if (stats.isFile()) {\r\n        return {\r\n          name,\r\n          path: relativePath,\r\n          type: 'file',\r\n        };\r\n      }\r\n\r\n      // 读取目录内容\r\n      const entries = fs.readdirSync(dirPath);\r\n\r\n      // 过滤掉不需要的文件和目录\r\n      const filteredEntries = entries.filter(entry => {\r\n        // 排除隐藏文件、node_modules、dist 等\r\n        if (entry.startsWith('.')) return false;\r\n        if (entry === 'node_modules') return false;\r\n        if (entry === 'dist') return false;\r\n        if (entry === 'coverage') return false;\r\n        if (entry === '__pycache__') return false;\r\n        return true;\r\n      });\r\n\r\n      // 排序：目录在前，文件在后\r\n      const children = filteredEntries\r\n        .map(entry => {\r\n          const entryPath = path.join(dirPath, entry);\r\n          const entryRelativePath = relativePath ? `${relativePath}/${entry}` : entry;\r\n          return buildTree(entryPath, entryRelativePath);\r\n        })\r\n        .sort((a, b) => {\r\n          if (a.type === b.type) return a.name.localeCompare(b.name);\r\n          return a.type === 'directory' ? -1 : 1;\r\n        });\r\n\r\n      return {\r\n        name,\r\n        path: relativePath || name,\r\n        type: 'directory',\r\n        children,\r\n      };\r\n    };\r\n\r\n    const tree = buildTree(absoluteRoot, root);\r\n\r\n    res.json({\r\n      success: true,\r\n      data: tree,\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[File Tree Error]', error);\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 获取模块内部文件列表\r\n * GET /api/blueprint/module-files?path=src/core\r\n *\r\n * 返回模块目录下的所有文件（带语言、行数等信息）\r\n */\r\nrouter.get('/module-files', (req: Request, res: Response) => {\r\n  try {\r\n    const modulePath = req.query.path as string;\r\n\r\n    if (!modulePath) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: '缺少 path 参数',\r\n      });\r\n    }\r\n\r\n    const absolutePath = path.resolve(process.cwd(), modulePath);\r\n\r\n    // 检查目录是否存在\r\n    if (!fs.existsSync(absolutePath)) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        error: `目录不存在: ${modulePath}`,\r\n      });\r\n    }\r\n\r\n    // 检查是否是目录\r\n    if (!fs.statSync(absolutePath).isDirectory()) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: `路径不是目录: ${modulePath}`,\r\n      });\r\n    }\r\n\r\n    interface ModuleFileInfo {\r\n      id: string;\r\n      name: string;\r\n      path: string;\r\n      type: 'file' | 'directory';\r\n      language?: string;\r\n      lineCount?: number;\r\n      symbolCount?: number;\r\n    }\r\n\r\n    // 语言检测映射\r\n    const EXT_TO_LANGUAGE: Record<string, string> = {\r\n      '.ts': 'TypeScript',\r\n      '.tsx': 'TypeScript',\r\n      '.js': 'JavaScript',\r\n      '.jsx': 'JavaScript',\r\n      '.css': 'CSS',\r\n      '.scss': 'SCSS',\r\n      '.json': 'JSON',\r\n      '.md': 'Markdown',\r\n      '.html': 'HTML',\r\n      '.yml': 'YAML',\r\n      '.yaml': 'YAML',\r\n    };\r\n\r\n    // 递归读取文件列表\r\n    const files: ModuleFileInfo[] = [];\r\n\r\n    const readFiles = (dirPath: string, relativePath: string) => {\r\n      const entries = fs.readdirSync(dirPath, { withFileTypes: true });\r\n\r\n      for (const entry of entries) {\r\n        // 跳过隐藏文件和 node_modules\r\n        if (entry.name.startsWith('.')) continue;\r\n        if (entry.name === 'node_modules') continue;\r\n        if (entry.name === 'dist') continue;\r\n        if (entry.name === '__pycache__') continue;\r\n\r\n        const fullPath = path.join(dirPath, entry.name);\r\n        const fileRelativePath = relativePath\r\n          ? `${relativePath}/${entry.name}`\r\n          : entry.name;\r\n\r\n        if (entry.isDirectory()) {\r\n          // 递归读取子目录\r\n          readFiles(fullPath, fileRelativePath);\r\n        } else if (entry.isFile()) {\r\n          const ext = path.extname(entry.name);\r\n\r\n          // 只处理源代码文件\r\n          if (!['.ts', '.tsx', '.js', '.jsx', '.css', '.scss', '.json', '.md', '.html', '.yml', '.yaml'].includes(ext)) {\r\n            continue;\r\n          }\r\n\r\n          let lineCount: number | undefined;\r\n          let symbolCount: number | undefined;\r\n\r\n          try {\r\n            const content = fs.readFileSync(fullPath, 'utf-8');\r\n            lineCount = content.split('\\n').length;\r\n\r\n            // 简单统计符号数量\r\n            if (['.ts', '.tsx', '.js', '.jsx'].includes(ext)) {\r\n              const matches = content.match(\r\n                /(?:export\\s+)?(?:async\\s+)?(?:function|class|interface|type|const|let|var)\\s+\\w+/g\r\n              );\r\n              symbolCount = matches?.length || 0;\r\n            }\r\n          } catch (e) {\r\n            // 忽略读取错误\r\n          }\r\n\r\n          files.push({\r\n            id: `file:${fileRelativePath}`,\r\n            name: entry.name,\r\n            path: path.join(modulePath, fileRelativePath).replace(/\\\\/g, '/'),\r\n            type: 'file',\r\n            language: EXT_TO_LANGUAGE[ext] || 'Other',\r\n            lineCount,\r\n            symbolCount,\r\n          });\r\n        }\r\n      }\r\n    };\r\n\r\n    readFiles(absolutePath, '');\r\n\r\n    // 按文件名排序\r\n    files.sort((a, b) => a.name.localeCompare(b.name));\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        modulePath,\r\n        files,\r\n        total: files.length,\r\n      },\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[Module Files Error]', error);\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 获取单个文件的详情信息\r\n * GET /api/blueprint/file-detail?path=xxx\r\n */\r\nrouter.get('/file-detail', (req: Request, res: Response) => {\r\n  try {\r\n    const filePath = req.query.path as string;\r\n\r\n    if (!filePath) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: '缺少 path 参数',\r\n      });\r\n    }\r\n\r\n    const absolutePath = path.resolve(process.cwd(), filePath);\r\n\r\n    // 检查文件是否存在\r\n    if (!fs.existsSync(absolutePath)) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        error: `文件不存在: ${filePath}`,\r\n      });\r\n    }\r\n\r\n    // 检查是否是文件\r\n    const stat = fs.statSync(absolutePath);\r\n    if (!stat.isFile()) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: `路径不是文件: ${filePath}`,\r\n      });\r\n    }\r\n\r\n    // 语言检测映射\r\n    const EXT_TO_LANGUAGE: Record<string, string> = {\r\n      '.ts': 'TypeScript',\r\n      '.tsx': 'TypeScript',\r\n      '.js': 'JavaScript',\r\n      '.jsx': 'JavaScript',\r\n      '.css': 'CSS',\r\n      '.scss': 'SCSS',\r\n      '.json': 'JSON',\r\n      '.md': 'Markdown',\r\n      '.html': 'HTML',\r\n      '.yml': 'YAML',\r\n      '.yaml': 'YAML',\r\n      '.py': 'Python',\r\n      '.java': 'Java',\r\n      '.go': 'Go',\r\n      '.rs': 'Rust',\r\n    };\r\n\r\n    const fileName = path.basename(filePath);\r\n    const ext = path.extname(fileName);\r\n    const language = EXT_TO_LANGUAGE[ext] || 'Other';\r\n\r\n    let lineCount = 0;\r\n    let symbolCount = 0;\r\n    let imports: string[] = [];\r\n    let exports: string[] = [];\r\n    let summary = '';\r\n    let description = '';\r\n    let keyPoints: string[] = [];\r\n\r\n    try {\r\n      const content = fs.readFileSync(absolutePath, 'utf-8');\r\n      lineCount = content.split('\\n').length;\r\n\r\n      // 分析 TypeScript/JavaScript 文件\r\n      if (['.ts', '.tsx', '.js', '.jsx'].includes(ext)) {\r\n        // 统计符号数量\r\n        const symbolMatches = content.match(\r\n          /(?:export\\s+)?(?:async\\s+)?(?:function|class|interface|type|const|let|var)\\s+\\w+/g\r\n        );\r\n        symbolCount = symbolMatches?.length || 0;\r\n\r\n        // 提取 import 语句\r\n        const importMatches = content.match(/import\\s+.*?from\\s+['\"](.+?)['\"]/g);\r\n        if (importMatches) {\r\n          imports = importMatches.slice(0, 10).map((imp) => {\r\n            const match = imp.match(/from\\s+['\"](.+?)['\"]/);\r\n            return match ? match[1] : imp;\r\n          });\r\n        }\r\n\r\n        // 提取 export 语句\r\n        const exportMatches = content.match(/export\\s+(?:default\\s+)?(?:async\\s+)?(?:function|class|interface|type|const|let|var)\\s+(\\w+)/g);\r\n        if (exportMatches) {\r\n          exports = exportMatches.slice(0, 10).map((exp) => {\r\n            const match = exp.match(/(?:function|class|interface|type|const|let|var)\\s+(\\w+)/);\r\n            return match ? match[1] : exp;\r\n          });\r\n        }\r\n\r\n        // 基于文件内容生成简单描述\r\n        const hasReact = content.includes('React') || content.includes('useState') || content.includes('useEffect');\r\n        const hasExpress = content.includes('express') || content.includes('router.') || content.includes('Request');\r\n        const isTest = fileName.includes('.test.') || fileName.includes('.spec.');\r\n        const isComponent = hasReact && (fileName.endsWith('.tsx') || fileName.endsWith('.jsx'));\r\n        const isHook = hasReact && fileName.startsWith('use');\r\n        const isApi = hasExpress || fileName.includes('api') || fileName.includes('route');\r\n\r\n        if (isTest) {\r\n          summary = `${fileName.replace(/\\.(test|spec)\\.(ts|tsx|js|jsx)$/, '')} 的测试文件`;\r\n          description = `包含针对相关模块的单元测试或集成测试`;\r\n          keyPoints = ['测试用例', '待 AI 分析详细内容'];\r\n        } else if (isHook) {\r\n          summary = `${fileName.replace(/\\.(ts|tsx)$/, '')} 自定义 Hook`;\r\n          description = `React 自定义 Hook，提供可复用的状态逻辑`;\r\n          keyPoints = ['React Hook', '状态管理', '待 AI 分析详细内容'];\r\n        } else if (isComponent) {\r\n          summary = `${fileName.replace(/\\.(tsx|jsx)$/, '')} React 组件`;\r\n          description = `React 组件，负责 UI 渲染和交互逻辑`;\r\n          keyPoints = ['React 组件', 'UI 渲染', '待 AI 分析详细内容'];\r\n        } else if (isApi) {\r\n          summary = `${fileName.replace(/\\.(ts|js)$/, '')} API 模块`;\r\n          description = `API 路由或服务端接口实现`;\r\n          keyPoints = ['API 端点', '请求处理', '待 AI 分析详细内容'];\r\n        } else {\r\n          summary = `${fileName} 模块`;\r\n          description = `${language} 代码文件`;\r\n          keyPoints = ['待 AI 分析详细内容'];\r\n        }\r\n      } else if (ext === '.css' || ext === '.scss') {\r\n        summary = `${fileName} 样式文件`;\r\n        description = `CSS 样式表，定义组件或页面的视觉样式`;\r\n        keyPoints = ['样式定义', '待 AI 分析详细内容'];\r\n      } else if (ext === '.json') {\r\n        summary = `${fileName} 配置文件`;\r\n        description = `JSON 格式的配置或数据文件`;\r\n        keyPoints = ['配置数据', '待 AI 分析详细内容'];\r\n      } else if (ext === '.md') {\r\n        summary = `${fileName} 文档`;\r\n        description = `Markdown 格式的文档或说明文件`;\r\n        keyPoints = ['文档说明', '待 AI 分析详细内容'];\r\n      } else {\r\n        summary = `${fileName} 文件`;\r\n        description = `${language} 代码文件`;\r\n        keyPoints = ['待 AI 分析详细内容'];\r\n      }\r\n    } catch (e) {\r\n      // 读取失败时使用默认值\r\n      summary = `${fileName} 文件`;\r\n      description = `无法读取文件内容`;\r\n      keyPoints = ['文件读取失败'];\r\n    }\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        path: filePath,\r\n        name: fileName,\r\n        language,\r\n        lineCount,\r\n        symbolCount,\r\n        imports,\r\n        exports,\r\n        annotation: {\r\n          summary,\r\n          description,\r\n          keyPoints,\r\n          confidence: 0.6, // 静态分析置信度较低\r\n          userModified: false,\r\n        },\r\n      },\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[File Detail Error]', error);\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 查找反向依赖（哪些文件引用了当前文件）\r\n */\r\nconst findReverseDependencies = (targetPath: string, rootDir: string = 'src'): Array<{path: string, imports: string[]}> => {\r\n  const results: Array<{path: string, imports: string[]}> = [];\r\n  const absoluteRoot = path.resolve(process.cwd(), rootDir);\r\n  const targetRelative = path.relative(process.cwd(), path.resolve(process.cwd(), targetPath));\r\n\r\n  // 递归遍历所有文件\r\n  const scanDirectory = (dirPath: string) => {\r\n    if (!fs.existsSync(dirPath)) return;\r\n\r\n    const entries = fs.readdirSync(dirPath);\r\n    for (const entry of entries) {\r\n      if (entry.startsWith('.') || entry === 'node_modules' || entry === 'dist') continue;\r\n\r\n      const fullPath = path.join(dirPath, entry);\r\n      const stats = fs.statSync(fullPath);\r\n\r\n      if (stats.isDirectory()) {\r\n        scanDirectory(fullPath);\r\n      } else if (stats.isFile() && /\\.(ts|tsx|js|jsx)$/.test(entry)) {\r\n        try {\r\n          const content = fs.readFileSync(fullPath, 'utf-8');\r\n          const imports: string[] = [];\r\n\r\n          // 匹配 import 和 export 语句（包括 export ... from）\r\n          const importExportRegex = /(?:import|export)\\s+(?:[\\s\\S]*?)\\s+from\\s+['\"]([^'\"]+)['\"]/g;\r\n          let match;\r\n          while ((match = importExportRegex.exec(content)) !== null) {\r\n            const importPath = match[1];\r\n\r\n            // 解析相对路径\r\n            if (importPath.startsWith('.')) {\r\n              const currentDir = path.dirname(fullPath);\r\n              const resolvedImport = path.resolve(currentDir, importPath);\r\n              const normalizedImport = path.relative(process.cwd(), resolvedImport);\r\n\r\n              // 检查是否匹配目标文件（考虑扩展名）\r\n              const targetWithoutExt = targetRelative.replace(/\\.(ts|tsx|js|jsx)$/, '');\r\n              const importWithoutExt = normalizedImport.replace(/\\.(ts|tsx|js|jsx)$/, '');\r\n\r\n              if (importWithoutExt === targetWithoutExt || normalizedImport === targetRelative) {\r\n                // 提取导入/导出的具体项\r\n                const fullStatement = match[0];\r\n\r\n                // 匹配 export * from\r\n                if (/export\\s+\\*\\s+from/.test(fullStatement)) {\r\n                  imports.push('* (所有导出)');\r\n                }\r\n                // 匹配 { ... } 形式\r\n                else {\r\n                  const items = fullStatement.match(/(?:import|export)\\s+\\{([^}]+)\\}/);\r\n                  if (items) {\r\n                    imports.push(...items[1].split(',').map(s => s.trim()));\r\n                  } else {\r\n                    // 匹配默认导入/导出\r\n                    const defaultItem = fullStatement.match(/(?:import|export)\\s+(\\w+)\\s+from/);\r\n                    if (defaultItem) {\r\n                      imports.push(defaultItem[1]);\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n\r\n          if (imports.length > 0) {\r\n            results.push({\r\n              path: path.relative(process.cwd(), fullPath).replace(/\\\\/g, '/'),\r\n              imports,\r\n            });\r\n          }\r\n        } catch (err) {\r\n          // 忽略无法读取的文件\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  scanDirectory(absoluteRoot);\r\n  return results;\r\n};\r\n\r\n/**\r\n * 分析单个节点（文件或目录）\r\n * 使用 getDefaultClient() 获取已认证的 Claude 客户端（与其他模块一致）\r\n */\r\nrouter.post('/analyze-node', async (req: Request, res: Response) => {\r\n  try {\r\n    const { path: nodePath } = req.body;\r\n\r\n    if (!nodePath) {\r\n      return res.status(400).json({ success: false, error: '缺少路径参数' });\r\n    }\r\n\r\n    const absolutePath = path.resolve(process.cwd(), nodePath);\r\n\r\n    // 检查路径是否存在\r\n    if (!fs.existsSync(absolutePath)) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        error: `路径不存在: ${nodePath}`,\r\n      });\r\n    }\r\n\r\n    const stats = fs.statSync(absolutePath);\r\n    const isFile = stats.isFile();\r\n    const name = path.basename(nodePath);\r\n\r\n    console.log(`[Analyze Node] 开始分析: ${nodePath} (${isFile ? '文件' : '目录'})`);\r\n\r\n    // 检查缓存\r\n    const cachedAnalysis = analysisCache.get(absolutePath, isFile);\r\n    if (cachedAnalysis) {\r\n      console.log(`[Analyze Node] 使用缓存结果: ${nodePath}`);\r\n\r\n      // 即使使用缓存，也计算反向依赖（因为其他文件可能变化）\r\n      let reverseDeps: Array<{path: string, imports: string[]}> = [];\r\n      if (isFile) {\r\n        reverseDeps = findReverseDependencies(nodePath);\r\n      }\r\n\r\n      return res.json({\r\n        success: true,\r\n        data: {\r\n          ...cachedAnalysis,\r\n          reverseDependencies: reverseDeps,\r\n          fromCache: true,\r\n        },\r\n      });\r\n    }\r\n\r\n    console.log(`[Analyze Node] 缓存未命中，调用 AI 分析...`);\r\n\r\n    // 使用 getDefaultClient() 获取已认证的客户端（与其他模块一致）\r\n    const { getDefaultClient } = await import('../../../core/client.js');\r\n    const client = getDefaultClient();\r\n\r\n    // 读取文件/目录内容\r\n    let contentInfo = '';\r\n    if (isFile) {\r\n      const content = fs.readFileSync(absolutePath, 'utf-8');\r\n      contentInfo = `文件内容（前 5000 字符）:\\n\\`\\`\\`\\n${content.slice(0, 5000)}\\n\\`\\`\\``;\r\n    } else {\r\n      const entries = fs.readdirSync(absolutePath);\r\n      const filtered = entries.filter(e => !e.startsWith('.') && e !== 'node_modules');\r\n      contentInfo = `目录内容:\\n${filtered.join('\\n')}`;\r\n    }\r\n\r\n    // 构建分析提示\r\n    const prompt = `请分析以下${isFile ? '文件' : '目录'}并生成 JSON 格式的语义分析报告：\r\n\r\n路径: ${nodePath}\r\n类型: ${isFile ? '文件' : '目录'}\r\n名称: ${name}\r\n\r\n${contentInfo}\r\n\r\n请返回以下 JSON 格式的分析结果（只返回 JSON，不要其他内容）：\r\n{\r\n  \"path\": \"${nodePath}\",\r\n  \"name\": \"${name}\",\r\n  \"type\": \"${isFile ? 'file' : 'directory'}\",\r\n  \"summary\": \"简短摘要（一句话描述主要功能）\",\r\n  \"description\": \"详细描述\",\r\n  ${isFile ? `\"exports\": [\"导出的函数/类/变量名\"],\r\n  \"dependencies\": [\"依赖的模块\"],\r\n  \"keyPoints\": [\"关键点1\", \"关键点2\"],` : `\"responsibilities\": [\"职责1\", \"职责2\"],\r\n  \"children\": [{\"name\": \"子项名\", \"description\": \"子项描述\"}],`}\r\n  \"techStack\": [\"使用的技术\"]\r\n}`;\r\n\r\n    // 调用 AI 分析\r\n    const response = await client.createMessage(\r\n      [{ role: 'user', content: prompt }],\r\n      undefined,\r\n      '你是一个代码分析专家。分析代码并返回结构化的 JSON 结果。只返回 JSON，不要其他内容。'\r\n    );\r\n\r\n    // 提取响应文本\r\n    let analysisText = '';\r\n    for (const block of response.content) {\r\n      if (block.type === 'text') {\r\n        analysisText += block.text;\r\n      }\r\n    }\r\n\r\n    console.log(`[Analyze Node] AI 返回结果长度: ${analysisText.length}`);\r\n\r\n    // 提取 JSON\r\n    let analysis: Record<string, any>;\r\n    // 尝试直接解析\r\n    try {\r\n      analysis = JSON.parse(analysisText.trim());\r\n    } catch {\r\n      // 尝试提取 JSON 块\r\n      const jsonMatch = analysisText.match(/```json\\s*([\\s\\S]*?)\\s*```/);\r\n      if (jsonMatch) {\r\n        analysis = JSON.parse(jsonMatch[1]);\r\n      } else {\r\n        // 尝试匹配裸 JSON\r\n        const bareJsonMatch = analysisText.match(/\\{[\\s\\S]*\\}/);\r\n        if (bareJsonMatch) {\r\n          analysis = JSON.parse(bareJsonMatch[0]);\r\n        } else {\r\n          // 无法解析 JSON，直接报错\r\n          throw new Error(`无法解析 AI 返回的 JSON: ${analysisText.slice(0, 200)}`);\r\n        }\r\n      }\r\n    }\r\n\r\n    // 添加分析时间\r\n    analysis.analyzedAt = new Date().toISOString();\r\n\r\n    // 计算反向依赖（文件）\r\n    let reverseDeps: Array<{path: string, imports: string[]}> = [];\r\n    if (isFile) {\r\n      reverseDeps = findReverseDependencies(nodePath);\r\n    }\r\n\r\n    // 保存到缓存\r\n    analysisCache.set(absolutePath, isFile, analysis);\r\n\r\n    console.log(`[Analyze Node] 分析完成: ${nodePath}`);\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        ...analysis,\r\n        reverseDependencies: reverseDeps,\r\n        fromCache: false,\r\n      },\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[Analyze Node Error]', error);\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n// ============================================================================\r\n// 一键分析 API\r\n// ============================================================================\r\n\r\n/**\r\n * 分析现有代码库并生成蓝图\r\n */\r\nrouter.post('/analyze', async (req: Request, res: Response) => {\r\n  try {\r\n    const { rootDir = '.', projectName, projectDescription, granularity = 'medium' } = req.body;\r\n\r\n    // 使用代码库分析器\r\n    const result = await codebaseAnalyzer.analyzeAndGenerate({\r\n      rootDir,\r\n      projectName,\r\n      projectDescription,\r\n      granularity,\r\n    });\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        codebase: {\r\n          name: result.codebase.name,\r\n          description: result.codebase.description,\r\n          stats: result.codebase.stats,\r\n          modules: result.codebase.modules.map(m => ({\r\n            name: m.name,\r\n            path: m.path,\r\n            type: m.type,\r\n            fileCount: m.files.length,\r\n          })),\r\n        },\r\n        blueprint: {\r\n          id: result.blueprint.id,\r\n          name: result.blueprint.name,\r\n          moduleCount: result.blueprint.modules.length,\r\n          processCount: result.blueprint.businessProcesses.length,\r\n        },\r\n        taskTree: {\r\n          id: result.taskTree.id,\r\n          taskCount: result.taskTree.stats.totalTasks,\r\n          maxDepth: result.taskTree.stats.maxDepth,\r\n        },\r\n      },\r\n    });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 获取分析进度（用于长时间运行的分析）\r\n */\r\nrouter.get('/analyze/status', (req: Request, res: Response) => {\r\n  try {\r\n    // 简单实现：返回当前状态\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        status: 'idle',\r\n        progress: 0,\r\n        message: '等待分析任务',\r\n      },\r\n    });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 智能生成蓝图\r\n *\r\n * 根据当前项目状态选择合适的生成方式：\r\n * - 有代码：分析现有代码库生成蓝图\r\n * - 无代码：提示用户进行对话式需求调研\r\n */\r\nrouter.post('/generate', async (req: Request, res: Response) => {\r\n  const startTime = Date.now();\r\n  console.log('\\n========================================');\r\n  console.log('[Blueprint Generate] 🚀 开始生成蓝图');\r\n  console.log('========================================');\r\n\r\n  try {\r\n    const { projectRoot = '.' } = req.body;\r\n\r\n    // 将相对路径转为绝对路径，确保项目名称正确\r\n    const absoluteRoot = path.resolve(process.cwd(), projectRoot);\r\n    console.log(`[Blueprint Generate] 📁 项目根目录: ${absoluteRoot}`);\r\n\r\n    // Step 1: 设置配置\r\n    console.log('[Blueprint Generate] ⚙️  Step 1: 设置代码库分析器配置...');\r\n    codebaseAnalyzer.setRootDir(absoluteRoot);\r\n\r\n    // Step 2: 分析代码库\r\n    console.log('[Blueprint Generate] 🔍 Step 2: 分析代码库结构...');\r\n    const analyzeStart = Date.now();\r\n    const codebaseInfo = await codebaseAnalyzer.analyze();\r\n    console.log(`[Blueprint Generate]    ✓ 分析完成，耗时 ${Date.now() - analyzeStart}ms`);\r\n    console.log(`[Blueprint Generate]    - 项目名称: ${codebaseInfo.name}`);\r\n    console.log(`[Blueprint Generate]    - 检测到模块: ${codebaseInfo.modules.length} 个`);\r\n    console.log(`[Blueprint Generate]    - 总文件数: ${codebaseInfo.stats.totalFiles}`);\r\n    console.log(`[Blueprint Generate]    - 总代码行: ${codebaseInfo.stats.totalLines}`);\r\n    if (codebaseInfo.modules.length > 0) {\r\n      console.log(`[Blueprint Generate]    - 模块列表: ${codebaseInfo.modules.map(m => m.name).join(', ')}`);\r\n    }\r\n\r\n    // Step 3: 判断是否有足够的代码\r\n    console.log('[Blueprint Generate] 📊 Step 3: 判断代码库是否满足要求...');\r\n    const hasCode = codebaseInfo.modules.length > 0 &&\r\n                    codebaseInfo.stats.totalFiles > 5;\r\n\r\n    if (!hasCode) {\r\n      console.log('[Blueprint Generate] ⚠️  代码不足，需要对话式调研');\r\n      console.log(`[Blueprint Generate]    - 模块数: ${codebaseInfo.modules.length} (需要 > 0)`);\r\n      console.log(`[Blueprint Generate]    - 文件数: ${codebaseInfo.stats.totalFiles} (需要 > 5)`);\r\n      console.log(`[Blueprint Generate] 总耗时: ${Date.now() - startTime}ms`);\r\n      console.log('========================================\\n');\r\n\r\n      return res.json({\r\n        success: false,\r\n        needsDialog: true,\r\n        message: '当前目录没有检测到足够的代码。请通过对话方式描述您的项目需求，AI 将帮您生成蓝图。',\r\n        hint: '您可以开始一个新的需求对话来描述您想要构建的系统。',\r\n      });\r\n    }\r\n\r\n    console.log('[Blueprint Generate]    ✓ 代码库满足要求');\r\n\r\n    // Step 4: 生成蓝图和任务树\r\n    console.log('[Blueprint Generate] 🏗️  Step 4: 生成蓝图和任务树...');\r\n    const generateStart = Date.now();\r\n    const result = await codebaseAnalyzer.analyzeAndGenerate({\r\n      rootDir: absoluteRoot,\r\n      projectName: codebaseInfo.name,\r\n      projectDescription: codebaseInfo.description,\r\n      granularity: 'medium',\r\n    });\r\n    console.log(`[Blueprint Generate]    ✓ 生成完成，耗时 ${Date.now() - generateStart}ms`);\r\n    console.log(`[Blueprint Generate]    - 蓝图 ID: ${result.blueprint.id}`);\r\n    console.log(`[Blueprint Generate]    - 蓝图名称: ${result.blueprint.name}`);\r\n    console.log(`[Blueprint Generate]    - 模块数: ${result.blueprint.modules.length}`);\r\n    console.log(`[Blueprint Generate]    - 业务流程数: ${result.blueprint.businessProcesses.length}`);\r\n    console.log(`[Blueprint Generate]    - NFR 数: ${result.blueprint.nfrs?.length || 0}`);\r\n    console.log(`[Blueprint Generate]    - 任务树 ID: ${result.taskTree?.id || 'N/A'}`);\r\n\r\n    console.log('[Blueprint Generate] ✅ 蓝图生成成功！');\r\n    console.log(`[Blueprint Generate] 总耗时: ${Date.now() - startTime}ms`);\r\n    console.log('========================================\\n');\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        id: result.blueprint.id,\r\n        name: result.blueprint.name,\r\n        description: result.blueprint.description,\r\n        status: result.blueprint.status,\r\n        createdAt: result.blueprint.createdAt,\r\n        updatedAt: result.blueprint.updatedAt,\r\n        moduleCount: result.blueprint.modules.length,\r\n        processCount: result.blueprint.businessProcesses.length,\r\n        nfrCount: result.blueprint.nfrs?.length || 0,\r\n        codebaseStats: {\r\n          totalFiles: codebaseInfo.stats.totalFiles,\r\n          totalLines: codebaseInfo.stats.totalLines,\r\n          filesByType: codebaseInfo.stats.filesByType,\r\n        },\r\n        taskTreeId: result.taskTree?.id,\r\n      },\r\n      message: `成功从代码库生成蓝图！检测到 ${codebaseInfo.modules.length} 个模块，${codebaseInfo.stats.totalFiles} 个文件。`,\r\n    });\r\n  } catch (error: any) {\r\n    console.error('\\n========================================');\r\n    console.error('[Blueprint Generate] ❌ 生成蓝图失败！');\r\n    console.error('========================================');\r\n    console.error(`[Blueprint Generate] 错误信息: ${error.message}`);\r\n    console.error(`[Blueprint Generate] 错误堆栈:\\n${error.stack}`);\r\n    console.error(`[Blueprint Generate] 总耗时: ${Date.now() - startTime}ms`);\r\n    console.error('========================================\\n');\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n// ============================================================================\r\n// 任务树 API\r\n// ============================================================================\r\n\r\n/**\r\n * 获取任务树\r\n */\r\nrouter.get('/task-trees/:id', (req: Request, res: Response) => {\r\n  try {\r\n    const tree = taskTreeManager.getTaskTree(req.params.id);\r\n    if (!tree) {\r\n      return res.status(404).json({ success: false, error: 'Task tree not found' });\r\n    }\r\n    res.json({ success: true, data: tree });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 获取任务树统计\r\n */\r\nrouter.get('/task-trees/:id/stats', (req: Request, res: Response) => {\r\n  try {\r\n    const tree = taskTreeManager.getTaskTree(req.params.id);\r\n    if (!tree) {\r\n      return res.status(404).json({ success: false, error: 'Task tree not found' });\r\n    }\r\n    res.json({ success: true, data: tree.stats });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 获取可执行任务\r\n */\r\nrouter.get('/task-trees/:id/executable', (req: Request, res: Response) => {\r\n  try {\r\n    const tasks = taskTreeManager.getExecutableTasks(req.params.id);\r\n    res.json({\r\n      success: true,\r\n      data: tasks.map(t => ({\r\n        id: t.id,\r\n        name: t.name,\r\n        description: t.description,\r\n        priority: t.priority,\r\n        depth: t.depth,\r\n        dependencies: t.dependencies,\r\n      })),\r\n    });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 获取叶子任务\r\n */\r\nrouter.get('/task-trees/:id/leaves', (req: Request, res: Response) => {\r\n  try {\r\n    const tasks = taskTreeManager.getLeafTasks(req.params.id);\r\n    res.json({\r\n      success: true,\r\n      data: tasks.map(t => ({\r\n        id: t.id,\r\n        name: t.name,\r\n        status: t.status,\r\n        depth: t.depth,\r\n      })),\r\n    });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 更新任务状态\r\n */\r\nrouter.patch('/task-trees/:treeId/tasks/:taskId/status', (req: Request, res: Response) => {\r\n  try {\r\n    const { status } = req.body;\r\n    const task = taskTreeManager.updateTaskStatus(req.params.treeId, req.params.taskId, status);\r\n    if (!task) {\r\n      return res.status(404).json({ success: false, error: 'Task not found' });\r\n    }\r\n    res.json({ success: true, data: task });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 动态添加子任务\r\n */\r\nrouter.post('/task-trees/:treeId/tasks/:parentId/subtasks', (req: Request, res: Response) => {\r\n  try {\r\n    const task = taskTreeManager.addSubTask(req.params.treeId, req.params.parentId, req.body);\r\n    res.json({ success: true, data: task });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n// ============================================================================\r\n// Agent 协调 API\r\n// ============================================================================\r\n\r\n/**\r\n * 初始化蜂王\r\n */\r\nrouter.post('/coordinator/queen', async (req: Request, res: Response) => {\r\n  try {\r\n    const { blueprintId } = req.body;\r\n    const queen = await agentCoordinator.initializeQueen(blueprintId);\r\n    res.json({ success: true, data: queen });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 获取蜂王状态\r\n */\r\nrouter.get('/coordinator/queen', (req: Request, res: Response) => {\r\n  try {\r\n    const queen = agentCoordinator.getQueen();\r\n    res.json({ success: true, data: queen });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 启动主循环\r\n */\r\nrouter.post('/coordinator/start', (req: Request, res: Response) => {\r\n  try {\r\n    agentCoordinator.startMainLoop();\r\n    res.json({ success: true, message: '主循环已启动' });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 停止主循环\r\n */\r\nrouter.post('/coordinator/stop', (req: Request, res: Response) => {\r\n  try {\r\n    agentCoordinator.stopMainLoop();\r\n    res.json({ success: true, message: '主循环已停止' });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 获取所有 Worker\r\n */\r\nrouter.get('/coordinator/workers', (req: Request, res: Response) => {\r\n  try {\r\n    const workers = agentCoordinator.getWorkers();\r\n    res.json({ success: true, data: workers });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 获取仪表板数据\r\n */\r\nrouter.get('/coordinator/dashboard', (req: Request, res: Response) => {\r\n  try {\r\n    const data = agentCoordinator.getDashboardData();\r\n    res.json({ success: true, data });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 获取时间线\r\n */\r\nrouter.get('/coordinator/timeline', (req: Request, res: Response) => {\r\n  try {\r\n    const timeline = agentCoordinator.getTimeline();\r\n    res.json({ success: true, data: timeline });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n// ============================================================================\r\n// TDD 循环 API\r\n// ============================================================================\r\n\r\n/**\r\n * 启动 TDD 循环\r\n */\r\nrouter.post('/tdd/start', (req: Request, res: Response) => {\r\n  try {\r\n    const { treeId, taskId } = req.body;\r\n    const state = tddExecutor.startLoop(treeId, taskId);\r\n    res.json({ success: true, data: state });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 获取 TDD 循环状态\r\n */\r\nrouter.get('/tdd/:taskId', (req: Request, res: Response) => {\r\n  try {\r\n    if (!tddExecutor.isInLoop(req.params.taskId)) {\r\n      return res.status(404).json({ success: false, error: 'TDD loop not found' });\r\n    }\r\n    const state = tddExecutor.getLoopState(req.params.taskId);\r\n    res.json({ success: true, data: state });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 获取阶段指南\r\n */\r\nrouter.get('/tdd/:taskId/guidance', (req: Request, res: Response) => {\r\n  try {\r\n    const guidance = tddExecutor.getPhaseGuidance(req.params.taskId);\r\n    res.json({ success: true, data: guidance });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 获取 TDD 报告\r\n */\r\nrouter.get('/tdd/:taskId/report', (req: Request, res: Response) => {\r\n  try {\r\n    const report = tddExecutor.generateReport(req.params.taskId);\r\n    res.json({ success: true, data: report });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 获取活跃的 TDD 循环\r\n */\r\nrouter.get('/tdd', (req: Request, res: Response) => {\r\n  try {\r\n    const loops = tddExecutor.getActiveLoops();\r\n    res.json({ success: true, data: loops });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n// ============================================================================\r\n// 时光倒流 API\r\n// ============================================================================\r\n\r\n/**\r\n * 获取所有检查点\r\n */\r\nrouter.get('/time-travel/:treeId/checkpoints', (req: Request, res: Response) => {\r\n  try {\r\n    const checkpoints = timeTravelManager.getAllCheckpoints(req.params.treeId);\r\n    res.json({ success: true, data: checkpoints });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 获取时间线视图\r\n */\r\nrouter.get('/time-travel/:treeId/timeline', (req: Request, res: Response) => {\r\n  try {\r\n    const view = timeTravelManager.getTimelineView(req.params.treeId);\r\n    res.json({ success: true, data: view });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 创建检查点\r\n */\r\nrouter.post('/time-travel/:treeId/checkpoints', (req: Request, res: Response) => {\r\n  try {\r\n    const { name, description, taskId } = req.body;\r\n    const checkpoint = timeTravelManager.createManualCheckpoint(\r\n      req.params.treeId,\r\n      name,\r\n      description,\r\n      taskId\r\n    );\r\n    res.json({ success: true, data: checkpoint });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 回滚到检查点\r\n */\r\nrouter.post('/time-travel/:treeId/rollback/:checkpointId', (req: Request, res: Response) => {\r\n  try {\r\n    timeTravelManager.rollback(req.params.treeId, req.params.checkpointId);\r\n    res.json({ success: true, message: '回滚成功' });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 预览回滚效果\r\n */\r\nrouter.get('/time-travel/:treeId/preview/:checkpointId', (req: Request, res: Response) => {\r\n  try {\r\n    const preview = timeTravelManager.previewRollback(req.params.treeId, req.params.checkpointId);\r\n    res.json({ success: true, data: preview });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 获取检查点详情\r\n */\r\nrouter.get('/time-travel/:treeId/checkpoints/:checkpointId', (req: Request, res: Response) => {\r\n  try {\r\n    const details = timeTravelManager.getCheckpointDetails(\r\n      req.params.treeId,\r\n      req.params.checkpointId\r\n    );\r\n    if (!details) {\r\n      return res.status(404).json({ success: false, error: 'Checkpoint not found' });\r\n    }\r\n    res.json({ success: true, data: details });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 创建分支\r\n */\r\nrouter.post('/time-travel/:treeId/branches', (req: Request, res: Response) => {\r\n  try {\r\n    const { checkpointId, branchName } = req.body;\r\n    const branch = timeTravelManager.createBranch(req.params.treeId, checkpointId, branchName);\r\n    res.json({ success: true, data: branch });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 获取 ASCII 时间线图\r\n */\r\nrouter.get('/time-travel/:treeId/ascii', (req: Request, res: Response) => {\r\n  try {\r\n    const ascii = timeTravelManager.generateTimelineAscii(req.params.treeId);\r\n    res.json({ success: true, data: ascii });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 获取当前/最新的蓝图（便捷接口）\r\n */\r\nrouter.get('/blueprints/current', (req: Request, res: Response) => {\r\n  try {\r\n    const blueprints = blueprintManager.getAllBlueprints();\r\n    if (blueprints.length === 0) {\r\n      return res.status(404).json({ success: false, error: 'No blueprints found' });\r\n    }\r\n    // 返回最新的蓝图\r\n    const latest = blueprints.sort((a, b) =>\r\n      new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime()\r\n    )[0];\r\n    res.json({ success: true, data: latest });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n// ============================================================================\r\n// 需求对话 API\r\n// ============================================================================\r\n\r\n/**\r\n * 开始新的需求对话\r\n */\r\nrouter.post('/requirement-dialog/start', (req: Request, res: Response) => {\r\n  try {\r\n    const dialogState = requirementDialogManager.startDialog();\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        sessionId: dialogState.id,\r\n        phase: dialogState.phase,\r\n        history: dialogState.history,\r\n      },\r\n    });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 发送消息到需求对话\r\n */\r\nrouter.post('/requirement-dialog/:sessionId/message', async (req: Request, res: Response) => {\r\n  try {\r\n    const { sessionId } = req.params;\r\n    const { message } = req.body;\r\n\r\n    if (!message || typeof message !== 'string') {\r\n      return res.status(400).json({ success: false, error: 'Message is required' });\r\n    }\r\n\r\n    const response = await requirementDialogManager.processUserInput(sessionId, message);\r\n    const state = requirementDialogManager.getDialogState(sessionId);\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        response,\r\n        phase: state?.phase,\r\n        isComplete: state?.phase === 'complete',\r\n      },\r\n    });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 获取对话状态\r\n */\r\nrouter.get('/requirement-dialog/:sessionId', (req: Request, res: Response) => {\r\n  try {\r\n    const { sessionId } = req.params;\r\n    const state = requirementDialogManager.getDialogState(sessionId);\r\n\r\n    if (!state) {\r\n      return res.status(404).json({ success: false, error: 'Dialog session not found' });\r\n    }\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        sessionId: state.id,\r\n        phase: state.phase,\r\n        projectName: state.projectName,\r\n        projectDescription: state.projectDescription,\r\n        businessProcesses: state.businessProcesses,\r\n        modules: state.modules,\r\n        nfrs: state.nfrs,\r\n        history: state.history,\r\n      },\r\n    });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 结束对话\r\n */\r\nrouter.delete('/requirement-dialog/:sessionId', (req: Request, res: Response) => {\r\n  try {\r\n    const { sessionId } = req.params;\r\n    requirementDialogManager.endDialog(sessionId);\r\n    res.json({ success: true, message: 'Dialog ended' });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n// ============================================================================\r\n// 时光倒流 API\r\n// ============================================================================\r\n\r\n/**\r\n * 获取时间线视图\r\n */\r\nrouter.get('/time-travel/:treeId/timeline', (req: Request, res: Response) => {\r\n  try {\r\n    const { treeId } = req.params;\r\n    const timeline = timeTravelManager.getTimelineView(treeId);\r\n    res.json({ success: true, data: timeline });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 获取检查点详情\r\n */\r\nrouter.get('/time-travel/:treeId/checkpoints/:checkpointId', (req: Request, res: Response) => {\r\n  try {\r\n    const { treeId, checkpointId } = req.params;\r\n    const detail = timeTravelManager.getCheckpointDetails(treeId, checkpointId);\r\n\r\n    if (!detail) {\r\n      return res.status(404).json({ success: false, error: 'Checkpoint not found' });\r\n    }\r\n\r\n    // 添加任务状态快照\r\n    const tree = taskTreeManager.getTaskTree(treeId);\r\n    let taskSnapshot: any[] = [];\r\n    if (tree) {\r\n      const collectTasks = (node: any) => {\r\n        taskSnapshot.push({\r\n          id: node.id,\r\n          name: node.name,\r\n          status: node.status,\r\n        });\r\n        for (const child of node.children || []) {\r\n          collectTasks(child);\r\n        }\r\n      };\r\n      collectTasks(tree.root);\r\n    }\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        ...detail,\r\n        taskSnapshot: taskSnapshot.slice(0, 20), // 限制数量\r\n      },\r\n    });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 创建检查点\r\n */\r\nrouter.post('/time-travel/:treeId/checkpoints', (req: Request, res: Response) => {\r\n  try {\r\n    const { treeId } = req.params;\r\n    const { name, description, isGlobal, taskId } = req.body;\r\n\r\n    const checkpoint = timeTravelManager.createManualCheckpoint(\r\n      treeId,\r\n      name,\r\n      description,\r\n      isGlobal ? undefined : taskId\r\n    );\r\n\r\n    res.json({ success: true, data: checkpoint });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 回滚到检查点\r\n */\r\nrouter.post('/time-travel/:treeId/rollback', (req: Request, res: Response) => {\r\n  try {\r\n    const { treeId } = req.params;\r\n    const { checkpointId } = req.body;\r\n\r\n    timeTravelManager.rollback(treeId, checkpointId);\r\n\r\n    res.json({ success: true, message: 'Rollback successful' });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 创建分支\r\n */\r\nrouter.post('/time-travel/:treeId/branches', (req: Request, res: Response) => {\r\n  try {\r\n    const { treeId } = req.params;\r\n    const { checkpointId, branchName } = req.body;\r\n\r\n    const branch = timeTravelManager.createBranch(treeId, checkpointId, branchName);\r\n\r\n    res.json({ success: true, data: branch });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 对比两个检查点\r\n */\r\nrouter.get('/time-travel/:treeId/compare', (req: Request, res: Response) => {\r\n  try {\r\n    const { treeId } = req.params;\r\n    const { from, to } = req.query;\r\n\r\n    if (!from || !to) {\r\n      return res.status(400).json({ success: false, error: 'Missing from or to parameter' });\r\n    }\r\n\r\n    const result = timeTravelManager.compare(treeId, from as string, to as string);\r\n\r\n    res.json({ success: true, data: result });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n// ============================================================================\r\n// 蓝图编辑 API（对话式修改）\r\n// ============================================================================\r\n\r\n/**\r\n * 对话式修改蓝图\r\n * 用户可以用自然语言描述修改需求\r\n */\r\nrouter.post('/blueprints/:id/chat-edit', async (req: Request, res: Response) => {\r\n  try {\r\n    const { id } = req.params;\r\n    const { message } = req.body;\r\n\r\n    const blueprint = blueprintManager.getBlueprint(id);\r\n    if (!blueprint) {\r\n      return res.status(404).json({ success: false, error: 'Blueprint not found' });\r\n    }\r\n\r\n    // 使用 AI 解析修改请求并应用\r\n    const { getDefaultClient } = await import('../../../core/client.js');\r\n    const client = getDefaultClient();\r\n\r\n    const response = await client.createMessage(\r\n      [{\r\n        role: 'user',\r\n        content: `用户想要修改以下蓝图：\r\n\r\n蓝图名称：${blueprint.name}\r\n蓝图描述：${blueprint.description}\r\n系统模块：${blueprint.modules.map(m => m.name).join('、')}\r\n业务流程：${blueprint.businessProcesses.map(p => p.name).join('、')}\r\n非功能要求：${blueprint.nfrs.map(n => n.name).join('、')}\r\n\r\n用户的修改请求：${message}\r\n\r\n请分析用户的请求，返回 JSON 格式的修改指令：\r\n{\r\n  \"action\": \"add_module\" | \"remove_module\" | \"update_module\" | \"add_process\" | \"remove_process\" | \"update_process\" | \"add_nfr\" | \"remove_nfr\" | \"update_description\",\r\n  \"target\": \"目标项名称（如果有）\",\r\n  \"data\": { ... 新数据 ... },\r\n  \"explanation\": \"修改说明\"\r\n}`,\r\n      }],\r\n      undefined,\r\n      '你是一个蓝图编辑助手。分析用户的修改请求，返回 JSON 格式的修改指令。'\r\n    );\r\n\r\n    let text = '';\r\n    for (const block of response.content) {\r\n      if (block.type === 'text') {\r\n        text += block.text;\r\n      }\r\n    }\r\n\r\n    // 解析 JSON\r\n    const jsonMatch = text.match(/\\{[\\s\\S]*\\}/);\r\n    if (!jsonMatch) {\r\n      return res.json({\r\n        success: true,\r\n        data: {\r\n          modified: false,\r\n          explanation: '无法解析修改请求，请尝试更明确地描述你想要的修改。',\r\n        },\r\n      });\r\n    }\r\n\r\n    const instruction = JSON.parse(jsonMatch[0]);\r\n\r\n    // 应用修改\r\n    let modified = false;\r\n    switch (instruction.action) {\r\n      case 'add_module':\r\n        if (instruction.data) {\r\n          blueprintManager.addModule(id, instruction.data);\r\n          modified = true;\r\n        }\r\n        break;\r\n      case 'add_process':\r\n        if (instruction.data) {\r\n          blueprintManager.addBusinessProcess(id, instruction.data);\r\n          modified = true;\r\n        }\r\n        break;\r\n      case 'add_nfr':\r\n        if (instruction.data) {\r\n          blueprintManager.addNFR(id, instruction.data);\r\n          modified = true;\r\n        }\r\n        break;\r\n      case 'update_description':\r\n        if (instruction.data?.description) {\r\n          const current = blueprintManager.getBlueprint(id);\r\n          if (current) {\r\n            blueprintManager.modifyDuringExecution(id, { description: instruction.data.description });\r\n            modified = true;\r\n          }\r\n        }\r\n        break;\r\n      // 可以添加更多操作类型\r\n    }\r\n\r\n    const updatedBlueprint = blueprintManager.getBlueprint(id);\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        modified,\r\n        explanation: instruction.explanation,\r\n        blueprint: updatedBlueprint,\r\n      },\r\n    });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n// ============================================================================\r\n// 缓存管理 API\r\n// ============================================================================\r\n\r\n/**\r\n * 获取缓存统计\r\n */\r\nrouter.get('/cache/stats', (req: Request, res: Response) => {\r\n  try {\r\n    const stats = analysisCache.getStats();\r\n    res.json({ success: true, data: stats });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 清除所有缓存\r\n */\r\nrouter.delete('/cache', (req: Request, res: Response) => {\r\n  try {\r\n    const count = analysisCache.clear();\r\n    res.json({ success: true, message: `已清除 ${count} 个缓存文件` });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 清除过期缓存\r\n */\r\nrouter.delete('/cache/expired', (req: Request, res: Response) => {\r\n  try {\r\n    const count = analysisCache.cleanExpired();\r\n    res.json({ success: true, message: `已清除 ${count} 个过期缓存` });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 清除指定路径的缓存\r\n */\r\nrouter.delete('/cache/path', (req: Request, res: Response) => {\r\n  try {\r\n    const { path: targetPath } = req.body;\r\n    if (!targetPath) {\r\n      return res.status(400).json({ success: false, error: '缺少路径参数' });\r\n    }\r\n\r\n    const absolutePath = path.resolve(process.cwd(), targetPath);\r\n    const success = analysisCache.delete(absolutePath);\r\n\r\n    if (success) {\r\n      res.json({ success: true, message: '缓存已清除' });\r\n    } else {\r\n      res.json({ success: false, message: '未找到缓存' });\r\n    }\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 重置缓存统计\r\n */\r\nrouter.post('/cache/reset-stats', (req: Request, res: Response) => {\r\n  try {\r\n    analysisCache.resetStats();\r\n    res.json({ success: true, message: '统计已重置' });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n// ============================================================================\r\n// 调用图 API (LSP + AI混合)\r\n// ============================================================================\r\n\r\n// 缓存\r\nconst callGraphCache = new Map<string, { data: any; timestamp: number }>();\r\nconst CACHE_TTL = 5 * 60 * 1000; // 5分钟\r\n\r\n// 全局 LSP 分析器（延迟初始化）\r\nlet lspAnalyzer: any = null;\r\nlet aiAnalyzer: any = null;\r\n\r\n/**\r\n * 获取文件/符号的调用图 (LSP + AI混合分析)\r\n * 参数:\r\n *   - path: 文件路径 (可选)\r\n *   - symbol: 符号名称 (可选, 例如函数名或类名.方法名)\r\n *   - depth: 分析深度 (默认: 2)\r\n *   - useAI: 是否使用AI增强分析 (默认: true)\r\n *   - detectCycles: 是否检测循环依赖 (默认: false)\r\n *\r\n * 如果不提供参数,返回整个项目的调用图\r\n */\r\nrouter.get('/call-graph', async (req: Request, res: Response) => {\r\n  try {\r\n    const {\r\n      path: filePath,\r\n      symbol,\r\n      depth = '2',\r\n      useAI = 'true',\r\n      detectCycles = 'false'\r\n    } = req.query;\r\n    const maxDepth = parseInt(depth as string) || 2;\r\n    const enableAI = useAI === 'true';\r\n    const enableCycleDetection = detectCycles === 'true';\r\n\r\n    console.log('[Call Graph API] 请求参数:', { filePath, symbol, maxDepth, enableAI, enableCycleDetection });\r\n\r\n    // 检查缓存\r\n    const cacheKey = JSON.stringify({ filePath, symbol, maxDepth, enableAI });\r\n    const cached = callGraphCache.get(cacheKey);\r\n    if (cached && Date.now() - cached.timestamp < CACHE_TTL) {\r\n      console.log('[Call Graph API] 使用缓存');\r\n      return res.json({\r\n        success: true,\r\n        ...cached.data,\r\n        cached: true,\r\n      });\r\n    }\r\n\r\n    const projectRoot = process.cwd();\r\n    console.log('[Call Graph API] 项目根目录:', projectRoot);\r\n\r\n    // 1. 扫描TypeScript文件\r\n    const tsFiles: string[] = [];\r\n    const srcPath = path.join(projectRoot, 'src');\r\n\r\n    const scanDir = (dir: string) => {\r\n      if (!fs.existsSync(dir)) return;\r\n      const entries = fs.readdirSync(dir, { withFileTypes: true });\r\n\r\n      for (const entry of entries) {\r\n        const fullPath = path.join(dir, entry.name);\r\n        if (entry.isDirectory()) {\r\n          if (['node_modules', 'dist', '.git', '.lh'].includes(entry.name)) continue;\r\n          scanDir(fullPath);\r\n        } else if (entry.isFile()) {\r\n          const ext = path.extname(entry.name);\r\n          if (['.ts', '.tsx'].includes(ext)) {\r\n            tsFiles.push(fullPath);\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    scanDir(srcPath);\r\n    console.log(`[Call Graph API] 扫描到 ${tsFiles.length} 个TypeScript文件`);\r\n\r\n    if (tsFiles.length === 0) {\r\n      return res.json({\r\n        success: true,\r\n        data: { nodes: [], edges: [] },\r\n        message: '未找到TypeScript文件',\r\n      });\r\n    }\r\n\r\n    // 2. 初始化LSP分析器（延迟加载）\r\n    if (!lspAnalyzer) {\r\n      const { TypeScriptLSPAnalyzer } = await import('./lsp-analyzer.js');\r\n      lspAnalyzer = new TypeScriptLSPAnalyzer();\r\n      lspAnalyzer.initProgram(tsFiles, projectRoot);\r\n      console.log('[Call Graph API] LSP分析器已初始化');\r\n    }\r\n\r\n    // 3. 使用LSP提取符号（只分析必要的文件）\r\n    const allNodes: CallGraphNode[] = [];\r\n    const allEdges: CallGraphEdge[] = [];\r\n    const symbolMap = new Map<string, CallGraphNode>();\r\n\r\n    // 确定需要分析的文件\r\n    let filesToAnalyze = tsFiles;\r\n    if (filePath) {\r\n      // 规范化路径：将相对路径转为绝对路径，统一使用正斜杠\r\n      const normalizedFilePath = path.normalize(path.join(projectRoot, filePath as string));\r\n      console.log(`[Call Graph API] 查找文件: ${normalizedFilePath}`);\r\n\r\n      // 只分析指定文件及其依赖\r\n      filesToAnalyze = tsFiles.filter(f => {\r\n        const normalized = path.normalize(f);\r\n        return normalized === normalizedFilePath || normalized.includes(path.basename(normalizedFilePath));\r\n      });\r\n\r\n      // 如果精确匹配失败，尝试模糊匹配\r\n      if (filesToAnalyze.length === 0) {\r\n        const fileName = path.basename(filePath as string);\r\n        filesToAnalyze = tsFiles.filter(f => f.includes(fileName));\r\n      }\r\n\r\n      // 限制数量\r\n      filesToAnalyze = filesToAnalyze.slice(0, 10);\r\n    } else {\r\n      // 限制文件数量（避免太慢）\r\n      filesToAnalyze = tsFiles.slice(0, 50);\r\n    }\r\n\r\n    console.log(`[Call Graph API] 将分析 ${filesToAnalyze.length} 个文件`);\r\n\r\n    for (const file of filesToAnalyze) {\r\n      try {\r\n        const { functions, classes, interfaces, types } = lspAnalyzer.analyzeFile(file);\r\n        const relativePath = path.relative(projectRoot, file);\r\n\r\n        console.log(`[Call Graph API] 分析文件: ${relativePath}, 函数: ${functions.length}, 类: ${classes.length}, 接口: ${interfaces.length}, 类型: ${types.length}`);\r\n\r\n        // 添加函数节点\r\n        for (const func of functions) {\r\n          const node: CallGraphNode = {\r\n            id: func.id,\r\n            name: func.name,\r\n            type: 'function',\r\n            moduleId: relativePath,\r\n            signature: func.signature,\r\n          };\r\n          allNodes.push(node);\r\n          symbolMap.set(func.name, node);\r\n          symbolMap.set(func.id, node);\r\n        }\r\n\r\n        // 添加类节点\r\n        for (const cls of classes) {\r\n          // 添加类本身作为节点\r\n          const clsNode: CallGraphNode = {\r\n            id: cls.id,\r\n            name: cls.name,\r\n            type: cls.isAbstract ? 'function' : 'method', // 抽象类显示为 function 类型\r\n            moduleId: relativePath,\r\n            signature: `${cls.isExported ? 'export ' : ''}${cls.isAbstract ? 'abstract ' : ''}class ${cls.name}`,\r\n          };\r\n          allNodes.push(clsNode);\r\n          symbolMap.set(cls.name, clsNode);\r\n          symbolMap.set(cls.id, clsNode);\r\n\r\n          // 添加类方法节点\r\n          for (const method of cls.methods) {\r\n            const node: CallGraphNode = {\r\n              id: method.id,\r\n              name: method.name,\r\n              type: method.name === 'constructor' ? 'constructor' : 'method',\r\n              moduleId: relativePath,\r\n              className: cls.name,\r\n              signature: method.signature,\r\n            };\r\n            allNodes.push(node);\r\n            symbolMap.set(method.name, node);\r\n            symbolMap.set(`${cls.name}.${method.name}`, node);\r\n            symbolMap.set(method.id, node);\r\n          }\r\n        }\r\n\r\n        // 添加接口节点\r\n        for (const iface of interfaces) {\r\n          // 添加接口本身作为节点\r\n          const ifaceNode: CallGraphNode = {\r\n            id: iface.id,\r\n            name: iface.name,\r\n            type: 'function', // 接口显示为 function 类型\r\n            moduleId: relativePath,\r\n            signature: `${iface.isExported ? 'export ' : ''}interface ${iface.name}`,\r\n          };\r\n          allNodes.push(ifaceNode);\r\n          symbolMap.set(iface.name, ifaceNode);\r\n          symbolMap.set(iface.id, ifaceNode);\r\n\r\n          // 添加接口方法签名\r\n          for (const method of iface.methods) {\r\n            const node: CallGraphNode = {\r\n              id: `${iface.id}::${method.name}`,\r\n              name: method.name,\r\n              type: 'method',\r\n              moduleId: relativePath,\r\n              className: iface.name,\r\n              signature: method.signature,\r\n            };\r\n            allNodes.push(node);\r\n            symbolMap.set(`${iface.name}.${method.name}`, node);\r\n            symbolMap.set(node.id, node);\r\n          }\r\n        }\r\n\r\n        // 添加类型别名节点\r\n        for (const type of types) {\r\n          const typeNode: CallGraphNode = {\r\n            id: type.id,\r\n            name: type.name,\r\n            type: 'function', // 类型别名显示为 function 类型\r\n            moduleId: relativePath,\r\n            signature: `${type.isExported ? 'export ' : ''}type ${type.name} = ${type.definition.substring(0, 50)}...`,\r\n          };\r\n          allNodes.push(typeNode);\r\n          symbolMap.set(type.name, typeNode);\r\n          symbolMap.set(type.id, typeNode);\r\n        }\r\n      } catch (error) {\r\n        console.error(`[Call Graph API] 分析文件失败: ${file}`, error);\r\n      }\r\n    }\r\n\r\n    console.log(`[Call Graph API] LSP提取到 ${allNodes.length} 个符号`);\r\n\r\n    // 4. 如果启用AI，使用Claude分析调用关系\r\n    if (enableAI && allNodes.length > 0 && allNodes.length < 200) {\r\n      try {\r\n        if (!aiAnalyzer) {\r\n          const apiKey = process.env.ANTHROPIC_API_KEY || process.env.CLAUDE_API_KEY;\r\n          if (apiKey) {\r\n            const { AICallGraphAnalyzer } = await import('./lsp-analyzer.js');\r\n            aiAnalyzer = new AICallGraphAnalyzer(apiKey);\r\n            console.log('[Call Graph API] AI分析器已初始化');\r\n          }\r\n        }\r\n\r\n        if (aiAnalyzer) {\r\n          // 只分析重点文件\r\n          const targetFile = filePath\r\n            ? filesToAnalyze.find(f => f.includes(filePath as string))\r\n            : filesToAnalyze[0];\r\n\r\n          if (targetFile && fs.existsSync(targetFile)) {\r\n            const content = fs.readFileSync(targetFile, 'utf-8');\r\n            const allSymbols = {\r\n              functions: [],\r\n              classes: []\r\n            };\r\n\r\n            console.log('[Call Graph API] 使用AI分析调用关系...');\r\n            const aiResult = await aiAnalyzer.analyzeCallRelationships(\r\n              content,\r\n              targetFile,\r\n              allSymbols\r\n            );\r\n\r\n            // 将AI结果转换为边\r\n            for (const call of aiResult.calls || []) {\r\n              const sourceNode = symbolMap.get(call.from);\r\n              const targetNode = symbolMap.get(call.to);\r\n\r\n              if (sourceNode && targetNode) {\r\n                allEdges.push({\r\n                  source: sourceNode.id,\r\n                  target: targetNode.id,\r\n                  type: call.type || 'direct',\r\n                  count: 1,\r\n                  locations: [],\r\n                });\r\n              }\r\n            }\r\n\r\n            console.log(`[Call Graph API] AI分析得到 ${allEdges.length} 条调用关系`);\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.error('[Call Graph API] AI分析失败:', error);\r\n        // 继续使用正则表达式分析\r\n      }\r\n    }\r\n\r\n    // 5. 如果没有AI结果，回退到正则表达式分析\r\n    if (allEdges.length === 0) {\r\n      console.log('[Call Graph API] 使用正则表达式分析调用关系...');\r\n      // 简单的正则分析\r\n      for (const file of filesToAnalyze.slice(0, 20)) {\r\n        try {\r\n          const content = fs.readFileSync(file, 'utf-8');\r\n          const lines = content.split('\\n');\r\n\r\n          for (let i = 0; i < lines.length; i++) {\r\n            const line = lines[i];\r\n            // 匹配函数调用: xxx(...)\r\n            const callPattern = /\\b([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*\\(/g;\r\n            let match;\r\n\r\n            while ((match = callPattern.exec(line)) !== null) {\r\n              const calledName = match[1];\r\n              const targetNode = symbolMap.get(calledName);\r\n\r\n              if (targetNode) {\r\n                // 找到调用者（当前行所在的函数）\r\n                for (const node of allNodes) {\r\n                  if (node.moduleId === path.relative(projectRoot, file)) {\r\n                    allEdges.push({\r\n                      source: node.id,\r\n                      target: targetNode.id,\r\n                      type: 'direct',\r\n                      count: 1,\r\n                      locations: [],\r\n                    });\r\n                    break;\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        } catch (error) {\r\n          // 忽略错误\r\n        }\r\n      }\r\n\r\n      console.log(`[Call Graph API] 正则分析得到 ${allEdges.length} 条调用关系`);\r\n    }\r\n\r\n    let callGraph = { nodes: allNodes, edges: allEdges };\r\n\r\n    // 5. 如果指定了文件或符号，过滤调用图\r\n    let filteredNodes = callGraph.nodes;\r\n    let filteredEdges = callGraph.edges;\r\n    const originalTargetNodes = new Set<string>(); // 原始目标节点（用户选中的符号）\r\n    const targetNodes = new Set<string>(); // 扩展后的节点集合\r\n\r\n    if (filePath || symbol) {\r\n\r\n      // 如果指定了符号，先检查它是否为静态符号（不支持调用图）\r\n      if (symbol) {\r\n        const symbolName = symbol as string;\r\n\r\n        // 从 symbolMap 中查找符号\r\n        const symbolNode = symbolMap.get(symbolName);\r\n\r\n        if (symbolNode && (symbolNode as any).isStatic) {\r\n          // 这是一个静态符号（interface/type/property），不支持调用图\r\n          const signature = symbolNode.signature || symbolName;\r\n          const kind = signature.includes('interface') ? 'interface' :\r\n                       signature.includes('type') ? 'type' : 'static symbol';\r\n\r\n          console.log(`[Call Graph API] 符号 \"${symbolName}\" 是静态符号 (${kind})，不支持调用图`);\r\n\r\n          return res.json({\r\n            success: false,\r\n            error: `符号 \"${symbolName}\" 是 ${kind}，不支持调用图分析`,\r\n            suggestion: 'references',\r\n            hint: `${kind} 是类型定义，建议使用\"引用查找\"视图查看它在哪些地方被使用`,\r\n            data: {\r\n              symbol: symbolName,\r\n              type: kind,\r\n              supportedViews: ['definition', 'references', 'type-hierarchy'],\r\n            },\r\n          });\r\n        }\r\n      }\r\n\r\n      // 查找目标节点\r\n      for (const node of callGraph.nodes) {\r\n        let matched = false;\r\n\r\n        if (filePath) {\r\n          // 规范化路径比较（统一使用正斜杠）\r\n          const normalizedModuleId = node.moduleId.replace(/\\\\/g, '/');\r\n          const normalizedFilePath = (filePath as string).replace(/\\\\/g, '/');\r\n          if (normalizedModuleId.includes(normalizedFilePath) ||\r\n              normalizedFilePath.includes(normalizedModuleId)) {\r\n            matched = true;\r\n          }\r\n        }\r\n\r\n        if (symbol) {\r\n          const symbolName = symbol as string;\r\n          if (node.name === symbolName ||\r\n              node.name.includes(symbolName) ||\r\n              (node.className && `${node.className}.${node.name}` === symbolName)) {\r\n            matched = true;\r\n          }\r\n        }\r\n\r\n        if (matched) {\r\n          originalTargetNodes.add(node.id); // 保存原始目标\r\n          targetNodes.add(node.id);\r\n          console.log(`[Call Graph API] 匹配到目标节点: ${node.name} (${node.id})`);\r\n        }\r\n      }\r\n\r\n      console.log(`[Call Graph API] 找到 ${originalTargetNodes.size} 个原始目标节点`);\r\n\r\n      // 扩展到相关节点（基于depth）\r\n      const expandNodes = (nodeIds: Set<string>, currentDepth: number) => {\r\n        if (currentDepth >= maxDepth) return;\r\n\r\n        const newNodes = new Set<string>();\r\n        for (const edge of callGraph.edges) {\r\n          if (nodeIds.has(edge.source)) {\r\n            newNodes.add(edge.target);\r\n          }\r\n          if (nodeIds.has(edge.target)) {\r\n            newNodes.add(edge.source);\r\n          }\r\n        }\r\n\r\n        newNodes.forEach(id => targetNodes.add(id));\r\n        if (newNodes.size > 0) {\r\n          expandNodes(newNodes, currentDepth + 1);\r\n        }\r\n      };\r\n\r\n      expandNodes(targetNodes, 0);\r\n\r\n      // 过滤节点和边\r\n      filteredNodes = callGraph.nodes.filter(n => targetNodes.has(n.id));\r\n      filteredEdges = callGraph.edges.filter(e =>\r\n        targetNodes.has(e.source) && targetNodes.has(e.target)\r\n      );\r\n\r\n      console.log(`[Call Graph API] 过滤后节点数: ${filteredNodes.length}, 边数: ${filteredEdges.length}`);\r\n    }\r\n\r\n    // 6. 限制返回的节点数量（避免图太大）\r\n    const MAX_NODES = 100;\r\n    if (filteredNodes.length > MAX_NODES) {\r\n      // 按照调用次数排序，保留最重要的节点\r\n      const nodeDegree = new Map<string, number>();\r\n      for (const node of filteredNodes) {\r\n        nodeDegree.set(node.id, 0);\r\n      }\r\n      for (const edge of filteredEdges) {\r\n        nodeDegree.set(edge.source, (nodeDegree.get(edge.source) || 0) + 1);\r\n        nodeDegree.set(edge.target, (nodeDegree.get(edge.target) || 0) + 1);\r\n      }\r\n\r\n      filteredNodes = filteredNodes\r\n        .sort((a, b) => (nodeDegree.get(b.id) || 0) - (nodeDegree.get(a.id) || 0))\r\n        .slice(0, MAX_NODES);\r\n\r\n      const nodeIds = new Set(filteredNodes.map(n => n.id));\r\n      filteredEdges = filteredEdges.filter(e => nodeIds.has(e.source) && nodeIds.has(e.target));\r\n\r\n      console.log(`[Call Graph API] 限制节点数到 ${MAX_NODES}, 最终边数: ${filteredEdges.length}`);\r\n    }\r\n\r\n    // 7. 循环依赖检测\r\n    const cycles: string[][] = [];\r\n    if (enableCycleDetection) {\r\n      console.log('[Call Graph API] 检测循环依赖...');\r\n      const visited = new Set<string>();\r\n      const recStack = new Set<string>();\r\n      const currentPath: string[] = [];\r\n\r\n      const detectCycle = (nodeId: string): boolean => {\r\n        if (recStack.has(nodeId)) {\r\n          // 找到循环，提取循环路径\r\n          const cycleStart = currentPath.indexOf(nodeId);\r\n          if (cycleStart >= 0) {\r\n            const cycle = currentPath.slice(cycleStart);\r\n            cycle.push(nodeId); // 闭合循环\r\n            cycles.push(cycle);\r\n          }\r\n          return true;\r\n        }\r\n\r\n        if (visited.has(nodeId)) return false;\r\n\r\n        visited.add(nodeId);\r\n        recStack.add(nodeId);\r\n        currentPath.push(nodeId);\r\n\r\n        // 检查所有出边\r\n        for (const edge of filteredEdges) {\r\n          if (edge.source === nodeId) {\r\n            detectCycle(edge.target);\r\n          }\r\n        }\r\n\r\n        recStack.delete(nodeId);\r\n        currentPath.pop();\r\n        return false;\r\n      };\r\n\r\n      // 对每个节点进行DFS\r\n      for (const node of filteredNodes) {\r\n        if (!visited.has(node.id)) {\r\n          detectCycle(node.id);\r\n        }\r\n      }\r\n\r\n      console.log(`[Call Graph API] 检测到 ${cycles.length} 个循环依赖`);\r\n    }\r\n\r\n    // 7. 调用链追踪：查找从入口点到目标符号的路径\r\n    const callChains: string[][] = [];\r\n\r\n    // 检测入口点（常见入口模式）\r\n    const entryPoints: string[] = [];\r\n    for (const node of filteredNodes) {\r\n      const name = node.name.toLowerCase();\r\n      const moduleId = node.moduleId.toLowerCase();\r\n\r\n      // 检测入口特征\r\n      if (\r\n        name === 'main' ||                      // main函数\r\n        name === 'index' ||                     // index函数\r\n        name === 'start' ||                     // start函数\r\n        name === 'init' ||                      // init函数\r\n        name === 'run' ||                       // run函数\r\n        moduleId.includes('index.ts') ||        // index文件\r\n        moduleId.includes('main.ts') ||         // main文件\r\n        moduleId.includes('cli.ts') ||          // CLI入口\r\n        moduleId.includes('app.ts') ||          // app入口\r\n        moduleId.includes('server.ts')          // server入口\r\n      ) {\r\n        entryPoints.push(node.id);\r\n        console.log(`[Call Graph API] 检测到入口点: ${node.name} (${moduleId})`);\r\n      }\r\n    }\r\n\r\n    console.log(`[Call Graph API] 共找到 ${entryPoints.length} 个入口点`);\r\n\r\n    // 如果没有找到传统入口点，使用入度为0的节点（没有被调用的节点）\r\n    if (entryPoints.length === 0 && filteredNodes.length > 0) {\r\n      console.log('[Call Graph API] 未找到传统入口点，使用入度为0的节点');\r\n      const inDegree = new Map<string, number>();\r\n      filteredNodes.forEach(n => inDegree.set(n.id, 0));\r\n      filteredEdges.forEach(e => {\r\n        inDegree.set(e.target, (inDegree.get(e.target) || 0) + 1);\r\n      });\r\n\r\n      for (const node of filteredNodes) {\r\n        if (inDegree.get(node.id) === 0) {\r\n          entryPoints.push(node.id);\r\n          console.log(`[Call Graph API] 入度为0的节点作为入口: ${node.name}`);\r\n        }\r\n      }\r\n\r\n      // 限制入口点数量\r\n      if (entryPoints.length > 10) {\r\n        entryPoints.splice(10);\r\n      }\r\n\r\n      console.log(`[Call Graph API] 使用 ${entryPoints.length} 个入度为0的节点作为入口点`);\r\n    }\r\n\r\n    // 如果找到入口点且有原始目标节点，查找调用链\r\n    if (entryPoints.length > 0 && originalTargetNodes.size > 0) {\r\n      console.log(`[Call Graph API] 从 ${entryPoints.length} 个入口点搜索到 ${originalTargetNodes.size} 个目标的调用链`);\r\n\r\n      const findPaths = (startId: string, targetId: string): string[][] => {\r\n        const paths: string[][] = [];\r\n        const visited = new Set<string>();\r\n        const currentPath: string[] = [];\r\n\r\n        const dfs = (nodeId: string) => {\r\n          if (nodeId === targetId) {\r\n            paths.push([...currentPath, nodeId]);\r\n            return;\r\n          }\r\n\r\n          if (visited.has(nodeId) || currentPath.length > 10) return; // 限制深度避免死循环\r\n\r\n          visited.add(nodeId);\r\n          currentPath.push(nodeId);\r\n\r\n          // 查找所有出边（使用完整的callGraph而不是filteredEdges，以找到更完整的路径）\r\n          for (const edge of callGraph.edges) {\r\n            if (edge.source === nodeId) {\r\n              dfs(edge.target);\r\n            }\r\n          }\r\n\r\n          currentPath.pop();\r\n          visited.delete(nodeId);\r\n        };\r\n\r\n        dfs(startId);\r\n        return paths;\r\n      };\r\n\r\n      // 为每个原始目标节点查找从所有入口点的路径\r\n      for (const targetId of originalTargetNodes) {\r\n        for (const entryId of entryPoints) {\r\n          const paths = findPaths(entryId, targetId);\r\n          if (paths.length > 0) {\r\n            console.log(`[Call Graph API] 找到 ${paths.length} 条从 ${entryId} 到 ${targetId} 的路径`);\r\n          }\r\n          callChains.push(...paths);\r\n        }\r\n      }\r\n\r\n      // 限制返回的路径数量（避免太多）\r\n      if (callChains.length > 10) {\r\n        callChains.splice(10);\r\n      }\r\n\r\n      console.log(`[Call Graph API] 找到 ${callChains.length} 条调用链`);\r\n    }\r\n\r\n    // 8. 构建结果\r\n    const result = {\r\n      data: {\r\n        nodes: filteredNodes,\r\n        edges: filteredEdges,\r\n        cycles: enableCycleDetection ? cycles : undefined,\r\n        callChains: callChains.length > 0 ? callChains : undefined,\r\n        entryPoints: entryPoints.map(id => {\r\n          const node = filteredNodes.find(n => n.id === id);\r\n          return node ? { id, name: node.name, moduleId: node.moduleId } : null;\r\n        }).filter(Boolean),\r\n      },\r\n      stats: {\r\n        totalNodes: callGraph.nodes.length,\r\n        totalEdges: callGraph.edges.length,\r\n        filteredNodes: filteredNodes.length,\r\n        filteredEdges: filteredEdges.length,\r\n        cycleCount: cycles.length,\r\n      },\r\n      metadata: {\r\n        usedLSP: true,\r\n        usedAI: enableAI && allEdges.length > 0,\r\n        detectedCycles: enableCycleDetection,\r\n        analysisTime: Date.now(),\r\n      },\r\n    };\r\n\r\n    // 9. 缓存结果\r\n    callGraphCache.set(cacheKey, {\r\n      data: result,\r\n      timestamp: Date.now(),\r\n    });\r\n\r\n    res.json({\r\n      success: true,\r\n      ...result,\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[Call Graph API] 错误:', error);\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n// ============================================================================\r\n// 模块依赖图 API\r\n// ============================================================================\r\n\r\n/**\r\n * GET /api/blueprint/dependency-graph?module=src/core/client.ts\r\n *\r\n * 生成模块依赖图\r\n *\r\n * 参数:\r\n *   - module: 模块路径（可选）。如果提供，只分析该模块及其依赖；否则分析整个项目\r\n *   - depth: 依赖深度（默认：3）\r\n *   - includeTypeOnly: 是否包含纯类型导入（默认：false）\r\n *\r\n * 返回:\r\n *   - nodes: 模块节点列表，包含导入/导出信息\r\n *   - edges: 依赖边列表，表示模块间的导入关系\r\n *   - cycles: 循环依赖列表（如果存在）\r\n *   - stats: 依赖统计信息\r\n */\r\nrouter.get('/dependency-graph', async (req: Request, res: Response) => {\r\n  try {\r\n    const { module, depth = '3', includeTypeOnly = 'false' } = req.query;\r\n    const maxDepth = parseInt(depth as string) || 3;\r\n    const includeTypeOnlyImports = includeTypeOnly === 'true';\r\n\r\n    console.log('[Dependency Graph API] 请求参数:', { module, maxDepth, includeTypeOnlyImports });\r\n\r\n    const projectRoot = process.cwd();\r\n    const srcPath = path.join(projectRoot, 'src');\r\n\r\n    // 1. 扫描所有 TypeScript/JavaScript 文件\r\n    const allFiles: string[] = [];\r\n\r\n    const scanDir = (dir: string) => {\r\n      if (!fs.existsSync(dir)) return;\r\n      const entries = fs.readdirSync(dir, { withFileTypes: true });\r\n\r\n      for (const entry of entries) {\r\n        const fullPath = path.join(dir, entry.name);\r\n        if (entry.isDirectory()) {\r\n          // 跳过不需要的目录\r\n          if (['node_modules', 'dist', '.git', '.lh', 'coverage'].includes(entry.name)) continue;\r\n          scanDir(fullPath);\r\n        } else if (entry.isFile()) {\r\n          const ext = path.extname(entry.name);\r\n          if (['.ts', '.tsx', '.js', '.jsx'].includes(ext)) {\r\n            allFiles.push(fullPath);\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    scanDir(srcPath);\r\n    console.log(`[Dependency Graph API] 扫描到 ${allFiles.length} 个文件`);\r\n\r\n    if (allFiles.length === 0) {\r\n      return res.json({\r\n        success: true,\r\n        data: {\r\n          nodes: [],\r\n          edges: [],\r\n          cycles: [],\r\n          stats: {\r\n            totalEdges: 0,\r\n            internalDeps: 0,\r\n            typeOnlyDeps: 0,\r\n            dynamicDeps: 0,\r\n            mostDependent: [],\r\n            mostDepended: [],\r\n          },\r\n        },\r\n        message: '未找到任何源文件',\r\n      });\r\n    }\r\n\r\n    // 2. 解析所有文件的导入/导出\r\n    const { CodeMapAnalyzer } = await import('../../../map/analyzer.js');\r\n    const fileAnalyzer = new CodeMapAnalyzer(projectRoot);\r\n\r\n    const modules: ModuleNode[] = [];\r\n\r\n    // 限制文件数量（避免太慢），优先分析 src 目录\r\n    const filesToAnalyze = allFiles.slice(0, 200);\r\n    console.log(`[Dependency Graph API] 将分析 ${filesToAnalyze.length} 个文件`);\r\n\r\n    for (const file of filesToAnalyze) {\r\n      try {\r\n        const moduleNode = await fileAnalyzer.analyzeFile(file);\r\n        modules.push(moduleNode);\r\n      } catch (error) {\r\n        console.error(`[Dependency Graph API] 解析文件失败: ${file}`, error);\r\n      }\r\n    }\r\n\r\n    console.log(`[Dependency Graph API] 成功解析 ${modules.length} 个模块`);\r\n\r\n    // 3. 使用 DependencyAnalyzer 分析依赖关系\r\n    const { DependencyAnalyzer } = await import('../../../map/dependency-analyzer.js');\r\n    const analyzer = new DependencyAnalyzer();\r\n\r\n    let dependencyGraph = analyzer.analyzeDependencies(modules);\r\n\r\n    // 4. 如果指定了模块，过滤依赖图\r\n    let filteredModules = modules;\r\n    let filteredEdges = dependencyGraph.edges;\r\n\r\n    if (module && typeof module === 'string') {\r\n      console.log(`[Dependency Graph API] 过滤模块: ${module}`);\r\n\r\n      // 规范化模块路径\r\n      const normalizedModulePath = module.replace(/\\\\/g, '/');\r\n\r\n      // 查找目标模块\r\n      const targetModules = modules.filter(m => {\r\n        const normalizedId = m.id.replace(/\\\\/g, '/');\r\n        return normalizedId.includes(normalizedModulePath) || normalizedModulePath.includes(normalizedId);\r\n      });\r\n\r\n      if (targetModules.length === 0) {\r\n        return res.status(404).json({\r\n          success: false,\r\n          error: `未找到模块: ${module}`,\r\n        });\r\n      }\r\n\r\n      console.log(`[Dependency Graph API] 找到 ${targetModules.length} 个匹配的模块`);\r\n\r\n      // 扩展到相关模块（基于 depth）\r\n      const targetModuleIds = new Set(targetModules.map(m => m.id));\r\n      const relatedModuleIds = new Set<string>(targetModuleIds);\r\n\r\n      const expandModules = (moduleIds: Set<string>, currentDepth: number) => {\r\n        if (currentDepth >= maxDepth) return;\r\n\r\n        const newModuleIds = new Set<string>();\r\n\r\n        // 查找所有相关的依赖\r\n        for (const edge of dependencyGraph.edges) {\r\n          if (moduleIds.has(edge.source)) {\r\n            newModuleIds.add(edge.target);\r\n          }\r\n          if (moduleIds.has(edge.target)) {\r\n            newModuleIds.add(edge.source);\r\n          }\r\n        }\r\n\r\n        newModuleIds.forEach(id => relatedModuleIds.add(id));\r\n\r\n        if (newModuleIds.size > 0) {\r\n          expandModules(newModuleIds, currentDepth + 1);\r\n        }\r\n      };\r\n\r\n      expandModules(targetModuleIds, 0);\r\n\r\n      // 过滤模块和边\r\n      filteredModules = modules.filter(m => relatedModuleIds.has(m.id));\r\n      filteredEdges = dependencyGraph.edges.filter(e =>\r\n        relatedModuleIds.has(e.source) && relatedModuleIds.has(e.target)\r\n      );\r\n\r\n      console.log(`[Dependency Graph API] 过滤后模块数: ${filteredModules.length}, 边数: ${filteredEdges.length}`);\r\n    }\r\n\r\n    // 5. 过滤纯类型导入（如果需要）\r\n    if (!includeTypeOnlyImports) {\r\n      const beforeCount = filteredEdges.length;\r\n      filteredEdges = filteredEdges.filter(e => !e.isTypeOnly);\r\n      console.log(`[Dependency Graph API] 排除纯类型导入: ${beforeCount} -> ${filteredEdges.length}`);\r\n    }\r\n\r\n    // 6. 检测循环依赖\r\n    const cycles = analyzer.detectCircularDependencies({ edges: filteredEdges });\r\n    console.log(`[Dependency Graph API] 检测到 ${cycles.length} 个循环依赖`);\r\n\r\n    // 7. 获取统计信息\r\n    const stats = analyzer.getDependencyStats({ edges: filteredEdges });\r\n\r\n    // 8. 构建返回数据（简化版）\r\n    const nodes = filteredModules.map(m => ({\r\n      id: m.id,\r\n      name: m.name,\r\n      path: m.path,\r\n      language: m.language,\r\n      lines: m.lines,\r\n      imports: m.imports.map(imp => ({\r\n        source: imp.source,\r\n        symbols: imp.symbols,\r\n        isDefault: imp.isDefault,\r\n        isDynamic: imp.isDynamic,\r\n      })),\r\n      exports: m.exports.map(exp => ({\r\n        name: exp.name,\r\n        type: exp.type,\r\n      })),\r\n    }));\r\n\r\n    const edges = filteredEdges.map(e => ({\r\n      source: e.source,\r\n      target: e.target,\r\n      type: e.type,\r\n      symbols: e.symbols,\r\n      isTypeOnly: e.isTypeOnly,\r\n    }));\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        nodes,\r\n        edges,\r\n        cycles: cycles.length > 0 ? cycles : undefined,\r\n        stats,\r\n      },\r\n      metadata: {\r\n        totalModules: modules.length,\r\n        filteredModules: filteredModules.length,\r\n        totalEdges: dependencyGraph.edges.length,\r\n        filteredEdges: filteredEdges.length,\r\n        analysisTime: new Date().toISOString(),\r\n      },\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[Dependency Graph API] 错误:', error);\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n// ============================================================================\r\n// 数据流分析 API\r\n// ============================================================================\r\n\r\n/**\r\n * GET /api/blueprint/data-flow/:symbolId\r\n *\r\n * 获取数据流分析结果\r\n *\r\n * 追踪属性/变量的所有读写位置\r\n *\r\n * 参数:\r\n *   - symbolId: 符号ID，格式为 \"filePath::symbolName\" 或 \"filePath::className::propertyName\"\r\n *\r\n * 返回:\r\n *   - symbolId: 符号ID\r\n *   - symbolName: 符号名称\r\n *   - reads: 读取位置列表\r\n *   - writes: 写入位置列表\r\n *   - dataFlowGraph: 数据流图（可选）\r\n */\r\nrouter.get('/data-flow', async (req: Request, res: Response) => {\r\n  try {\r\n    const symbolId = req.query.symbolId as string;\r\n\r\n    if (!symbolId) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: '缺少必需的参数: symbolId',\r\n      });\r\n    }\r\n\r\n    // 解码符号 ID\r\n    const decodedId = decodeURIComponent(symbolId);\r\n\r\n    console.log('[Data Flow API] 分析符号:', decodedId);\r\n\r\n    // 执行数据流分析\r\n    const { DataFlowAnalyzer } = await import('./data-flow-analyzer.js');\r\n    const analyzer = new DataFlowAnalyzer();\r\n    const dataFlow = await analyzer.analyzeDataFlow(decodedId);\r\n\r\n    console.log('[Data Flow API] 分析完成:', {\r\n      symbolName: dataFlow.symbolName,\r\n      reads: dataFlow.reads.length,\r\n      writes: dataFlow.writes.length,\r\n    });\r\n\r\n    res.json({\r\n      success: true,\r\n      data: dataFlow,\r\n    });\r\n  } catch (error) {\r\n    console.error('[Data Flow API] 错误:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: (error as Error).message,\r\n    });\r\n  }\r\n});\r\n\r\n\r\n// ============================================================================\r\n// 符号浏览 API (LSP)\r\n// ============================================================================\r\n\r\n// 符号缓存（避免每次都扫描所有文件）\r\nlet symbolsCache: {\r\n  data: Array<{\r\n    id: string;\r\n    name: string;\r\n    type: string;\r\n    moduleId: string;\r\n    signature?: string;\r\n    className?: string;\r\n  }>;\r\n  timestamp: number;\r\n} | null = null;\r\n\r\nconst SYMBOLS_CACHE_TTL = 10 * 60 * 1000; // 10分钟\r\n\r\n/**\r\n * 获取符号列表（支持过滤）\r\n * GET /api/blueprint/symbols?type=function&module=src/core&search=handler\r\n *\r\n * 查询参数：\r\n * - type: 符号类型 (function/method/class/interface/type)\r\n * - module: 模块路径（支持部分匹配）\r\n * - search: 搜索词（匹配符号名称）\r\n */\r\n\r\n/**\r\n * 获取文件内容 API\r\n * GET /api/blueprint/file-content?path=xxx\r\n */\r\nrouter.get('/file-content', async (req: Request, res: Response) => {\r\n  try {\r\n    const filePath = req.query.path as string;\r\n\r\n    if (!filePath) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: '缺少必需的参数: path',\r\n      });\r\n    }\r\n\r\n    const projectRoot = process.cwd();\r\n    let absolutePath: string;\r\n\r\n    // 处理相对路径和绝对路径\r\n    if (path.isAbsolute(filePath)) {\r\n      absolutePath = filePath;\r\n    } else {\r\n      absolutePath = path.join(projectRoot, filePath);\r\n    }\r\n\r\n    if (!fs.existsSync(absolutePath)) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        error: `文件不存在: ${filePath}`,\r\n      });\r\n    }\r\n\r\n    const content = fs.readFileSync(absolutePath, 'utf-8');\r\n    const stats = fs.statSync(absolutePath);\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        path: filePath,\r\n        absolutePath,\r\n        content,\r\n        size: stats.size,\r\n        modified: stats.mtime.toISOString(),\r\n      },\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[File Content API] 错误:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: error.message || '读取文件失败',\r\n    });\r\n  }\r\n});\r\n\r\nrouter.get('/symbols', async (req: Request, res: Response) => {\r\n  try {\r\n    const { type, module, search } = req.query;\r\n\r\n    console.log('[Symbols API] 查询参数:', { type, module, search });\r\n\r\n    // 检查缓存\r\n    if (symbolsCache && Date.now() - symbolsCache.timestamp < SYMBOLS_CACHE_TTL) {\r\n      console.log('[Symbols API] 使用缓存的符号列表');\r\n    } else {\r\n      console.log('[Symbols API] 重新扫描符号...');\r\n\r\n      const projectRoot = process.cwd();\r\n      const tsFiles: string[] = [];\r\n      const srcPath = path.join(projectRoot, 'src');\r\n\r\n      // 扫描 TypeScript 文件\r\n      const scanDir = (dir: string) => {\r\n        if (!fs.existsSync(dir)) return;\r\n        const entries = fs.readdirSync(dir, { withFileTypes: true });\r\n\r\n        for (const entry of entries) {\r\n          const fullPath = path.join(dir, entry.name);\r\n          if (entry.isDirectory()) {\r\n            if (['node_modules', 'dist', '.git', '.lh'].includes(entry.name)) continue;\r\n            scanDir(fullPath);\r\n          } else if (entry.isFile()) {\r\n            const ext = path.extname(entry.name);\r\n            if (['.ts', '.tsx'].includes(ext)) {\r\n              tsFiles.push(fullPath);\r\n            }\r\n          }\r\n        }\r\n      };\r\n\r\n      scanDir(srcPath);\r\n      console.log(`[Symbols API] 扫描到 ${tsFiles.length} 个 TypeScript 文件`);\r\n\r\n      // 初始化 LSP 分析器（复用全局实例）\r\n      if (!lspAnalyzer) {\r\n        const { TypeScriptLSPAnalyzer } = await import('./lsp-analyzer.js');\r\n        lspAnalyzer = new TypeScriptLSPAnalyzer();\r\n        lspAnalyzer.initProgram(tsFiles, projectRoot);\r\n        console.log('[Symbols API] LSP 分析器已初始化');\r\n      }\r\n\r\n      // 提取所有符号\r\n      const allSymbols: Array<{\r\n        id: string;\r\n        name: string;\r\n        type: string;\r\n        moduleId: string;\r\n        signature?: string;\r\n        className?: string;\r\n      }> = [];\r\n\r\n      for (const file of tsFiles) {\r\n        try {\r\n          const { functions, classes, interfaces, types } = lspAnalyzer.analyzeFile(file);\r\n          const relativePath = path.relative(projectRoot, file);\r\n\r\n          // 添加函数\r\n          for (const func of functions) {\r\n            allSymbols.push({\r\n              id: func.id,\r\n              name: func.name,\r\n              type: 'function',\r\n              moduleId: relativePath,\r\n              signature: func.signature,\r\n            });\r\n          }\r\n\r\n          // 添加类和类方法\r\n          for (const cls of classes) {\r\n            // 添加类本身\r\n            const exportStr = cls.isExported ? 'export ' : '';\r\n            const abstractStr = cls.isAbstract ? 'abstract ' : '';\r\n            allSymbols.push({\r\n              id: cls.id,\r\n              name: cls.name,\r\n              type: 'class',\r\n              moduleId: relativePath,\r\n              signature: `${exportStr}${abstractStr}class ${cls.name}`,\r\n            });\r\n\r\n            // 添加类方法\r\n            for (const method of cls.methods) {\r\n              allSymbols.push({\r\n                id: method.id,\r\n                name: method.name,\r\n                type: method.name === 'constructor' ? 'constructor' : 'method',\r\n                moduleId: relativePath,\r\n                className: cls.name,\r\n                signature: method.signature,\r\n              });\r\n            }\r\n          }\r\n\r\n          // 添加接口\r\n          for (const iface of interfaces) {\r\n            const exportStr = iface.isExported ? 'export ' : '';\r\n            allSymbols.push({\r\n              id: iface.id,\r\n              name: iface.name,\r\n              type: 'interface',\r\n              moduleId: relativePath,\r\n              signature: `${exportStr}interface ${iface.name}`,\r\n            });\r\n          }\r\n\r\n          // 添加类型别名\r\n          for (const typeNode of types) {\r\n            const exportStr = typeNode.isExported ? 'export ' : '';\r\n            allSymbols.push({\r\n              id: typeNode.id,\r\n              name: typeNode.name,\r\n              type: 'type',\r\n              moduleId: relativePath,\r\n              signature: `${exportStr}type ${typeNode.name}`,\r\n            });\r\n          }\r\n        } catch (error) {\r\n          console.error(`[Symbols API] 分析文件失败: ${file}`, error);\r\n        }\r\n      }\r\n\r\n      // 更新缓存\r\n      symbolsCache = {\r\n        data: allSymbols,\r\n        timestamp: Date.now(),\r\n      };\r\n\r\n      console.log(`[Symbols API] 提取到 ${allSymbols.length} 个符号`);\r\n    }\r\n\r\n    // 应用过滤\r\n    let filteredSymbols = symbolsCache.data;\r\n\r\n    // 过滤：按类型\r\n    if (type && typeof type === 'string') {\r\n      filteredSymbols = filteredSymbols.filter(s => s.type === type);\r\n    }\r\n\r\n    // 过滤：按模块\r\n    if (module && typeof module === 'string') {\r\n      const normalizedModule = (module as string).replace(/\\\\/g, '/');\r\n      filteredSymbols = filteredSymbols.filter(s =>\r\n        s.moduleId.replace(/\\\\/g, '/').includes(normalizedModule)\r\n      );\r\n    }\r\n\r\n    // 过滤：按搜索词\r\n    if (search && typeof search === 'string') {\r\n      const searchLower = (search as string).toLowerCase();\r\n      filteredSymbols = filteredSymbols.filter(s =>\r\n        s.name.toLowerCase().includes(searchLower) ||\r\n        (s.className && s.className.toLowerCase().includes(searchLower))\r\n      );\r\n    }\r\n\r\n    console.log(`[Symbols API] 过滤后剩余 ${filteredSymbols.length} 个符号`);\r\n\r\n    res.json({\r\n      success: true,\r\n      data: filteredSymbols,\r\n      count: filteredSymbols.length,\r\n      cached: symbolsCache !== null,\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[Symbols API] 错误:', error);\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 获取符号详情\r\n * GET /api/blueprint/symbol/:id/detail\r\n *\r\n * 符号 ID 格式:\r\n * - 函数/类/接口/类型: \"file.ts::symbolName\"\r\n * - 类方法: \"file.ts::ClassName::methodName\"\r\n */\r\nrouter.get('/symbol-detail', async (req: Request, res: Response) => {\r\n  try {\r\n    const id = req.query.id as string;\r\n\r\n    if (!id) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: '缺少必需的参数: id',\r\n      });\r\n    }\r\n\r\n    console.log(`[Symbol Detail API] 查询符号: ${id}`);\r\n\r\n    // 解析符号 ID\r\n    // ID 格式: \"file.ts::symbolName\" 或 \"file.ts::ClassName::methodName\"\r\n    const parts = id.split('::');\r\n    if (parts.length < 2) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: `无效的符号 ID 格式: ${id}`,\r\n        hint: 'ID 格式应为 \"file.ts::symbolName\" 或 \"file.ts::ClassName::methodName\"',\r\n      });\r\n    }\r\n\r\n    const filePath = parts[0];\r\n    const symbolName = parts[parts.length - 1];\r\n\r\n    console.log(`[Symbol Detail API] 文件: ${filePath}, 符号: ${symbolName}`);\r\n\r\n    // 构建绝对路径（处理相对路径和绝对路径两种情况）\r\n    const projectRoot = process.cwd();\r\n    let absolutePath: string;\r\n\r\n    // 检查是否为绝对路径\r\n    if (path.isAbsolute(filePath)) {\r\n      absolutePath = filePath;\r\n    } else {\r\n      absolutePath = path.join(projectRoot, filePath);\r\n    }\r\n\r\n    if (!fs.existsSync(absolutePath)) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        error: `文件不存在: ${filePath}`,\r\n      });\r\n    }\r\n\r\n    // 初始化 LSP 分析器（复用全局实例）\r\n    if (!lspAnalyzer) {\r\n      const tsFiles: string[] = [];\r\n      const srcPath = path.join(projectRoot, 'src');\r\n\r\n      const scanDir = (dir: string) => {\r\n        if (!fs.existsSync(dir)) return;\r\n        const entries = fs.readdirSync(dir, { withFileTypes: true });\r\n\r\n        for (const entry of entries) {\r\n          const fullPath = path.join(dir, entry.name);\r\n          if (entry.isDirectory()) {\r\n            if (['node_modules', 'dist', '.git', '.lh'].includes(entry.name)) continue;\r\n            scanDir(fullPath);\r\n          } else if (entry.isFile()) {\r\n            const ext = path.extname(entry.name);\r\n            if (['.ts', '.tsx'].includes(ext)) {\r\n              tsFiles.push(fullPath);\r\n            }\r\n          }\r\n        }\r\n      };\r\n\r\n      scanDir(srcPath);\r\n\r\n      const { TypeScriptLSPAnalyzer } = await import('./lsp-analyzer.js');\r\n      lspAnalyzer = new TypeScriptLSPAnalyzer();\r\n      lspAnalyzer.initProgram(tsFiles, projectRoot);\r\n      console.log('[Symbol Detail API] LSP 分析器已初始化');\r\n    }\r\n\r\n    // 分析文件\r\n    const { functions, classes, interfaces, types } = lspAnalyzer.analyzeFile(absolutePath);\r\n\r\n    console.log(`[Symbol Detail API] 分析结果 - 函数: ${functions.length}, 类: ${classes.length}, 接口: ${interfaces.length}, 类型: ${types.length}`);\r\n\r\n    // 查找符号\r\n    let detail: any = null;\r\n    let symbolType = 'unknown';\r\n\r\n    // 在 functions 中查找\r\n    const func = functions.find(f => f.name === symbolName);\r\n    if (func) {\r\n      detail = func;\r\n      symbolType = 'function';\r\n    }\r\n\r\n    // 在 classes 中查找\r\n    if (!detail) {\r\n      const cls = classes.find(c => c.name === symbolName);\r\n      if (cls) {\r\n        detail = cls;\r\n        symbolType = 'class';\r\n      } else {\r\n        // 查找类的方法\r\n        for (const cls of classes) {\r\n          const method = cls.methods.find(m => m.name === symbolName);\r\n          if (method) {\r\n            detail = { ...method, className: cls.name };\r\n            symbolType = 'method';\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // 在 interfaces 中查找\r\n    if (!detail) {\r\n      const iface = interfaces.find(i => i.name === symbolName);\r\n      if (iface) {\r\n        detail = iface;\r\n        symbolType = 'interface';\r\n      }\r\n    }\r\n\r\n    // 在 types 中查找\r\n    if (!detail) {\r\n      const typeNode = types.find(t => t.name === symbolName);\r\n      if (typeNode) {\r\n        detail = typeNode;\r\n        symbolType = 'type';\r\n      }\r\n    }\r\n\r\n    if (!detail) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        error: `符号 \"${symbolName}\" 未在文件 \"${filePath}\" 中找到`,\r\n        hint: `可用符号: ${[\r\n          ...functions.map(f => f.name),\r\n          ...classes.map(c => c.name),\r\n          ...interfaces.map(i => i.name),\r\n          ...types.map(t => t.name),\r\n        ].join(', ')}`,\r\n      });\r\n    }\r\n\r\n    // 获取符号分类信息\r\n    const classification = classifySymbol(symbolType);\r\n\r\n    console.log(`[Symbol Detail API] 找到符号: ${symbolName} (${symbolType})`);\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        ...detail,\r\n        symbolType,\r\n        classification,\r\n        availableViews: classification.supportedViews,\r\n      },\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[Symbol Detail API] 错误:', error);\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 获取入口点的调用路径追踪\r\n * 用于代码地图的数据流向可视化\r\n */\r\nrouter.get('/call-paths', async (req: Request, res: Response) => {\r\n  try {\r\n    const { entryPoint, maxDepth = '5' } = req.query;\r\n    const depth = parseInt(maxDepth as string, 10) || 5;\r\n\r\n    console.log('[Call Paths API] 请求参数:', { entryPoint, maxDepth: depth });\r\n\r\n    const projectRoot = process.cwd();\r\n\r\n    // 1. 扫描TypeScript文件\r\n    const tsFiles: string[] = [];\r\n    const srcPath = path.join(projectRoot, 'src');\r\n\r\n    const scanDir = (dir: string) => {\r\n      if (!fs.existsSync(dir)) return;\r\n      const entries = fs.readdirSync(dir, { withFileTypes: true });\r\n\r\n      for (const ent of entries) {\r\n        const fullPath = path.join(dir, ent.name);\r\n        if (ent.isDirectory()) {\r\n          if (['node_modules', 'dist', '.git', '.lh'].includes(ent.name)) continue;\r\n          scanDir(fullPath);\r\n        } else if (ent.isFile()) {\r\n          const ext = path.extname(ent.name);\r\n          if (['.ts', '.tsx'].includes(ext)) {\r\n            tsFiles.push(fullPath);\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    scanDir(srcPath);\r\n    console.log(`[Call Paths API] 扫描到 ${tsFiles.length} 个TypeScript文件`);\r\n\r\n    // 2. 检测入口点\r\n    const { detectEntryPoints } = await import('./project-map-generator.js');\r\n    const entryPoints = await detectEntryPoints(tsFiles);\r\n\r\n    // 如果没有指定入口点，返回所有入口点列表\r\n    if (!entryPoint) {\r\n      return res.json({\r\n        success: true,\r\n        data: {\r\n          entryPoints,\r\n          message: '请选择一个入口点',\r\n        },\r\n      });\r\n    }\r\n\r\n    // 3. 找到指定的入口点\r\n    const entry = entryPoints.find(\r\n      (e: any) => e.id === entryPoint || e.moduleId === entryPoint\r\n    );\r\n\r\n    if (!entry) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        error: `入口点 \"${entryPoint}\" 未找到`,\r\n      });\r\n    }\r\n\r\n    console.log('[Call Paths API] 入口点:', entry);\r\n\r\n    // 4. 初始化LSP分析器\r\n    if (!lspAnalyzer) {\r\n      const { TypeScriptLSPAnalyzer } = await import('./lsp-analyzer.js');\r\n      lspAnalyzer = new TypeScriptLSPAnalyzer();\r\n      lspAnalyzer.initProgram(tsFiles, projectRoot);\r\n      console.log('[Call Paths API] LSP分析器已初始化');\r\n    }\r\n\r\n    // 5. 构建调用图（复用 /call-graph 的逻辑）\r\n    const allNodes: CallGraphNode[] = [];\r\n    const allEdges: CallGraphEdge[] = [];\r\n    const symbolMap = new Map<string, CallGraphNode>();\r\n\r\n    // 限制分析的文件数量（避免太慢）\r\n    const filesToAnalyze = tsFiles.slice(0, 100);\r\n    console.log(`[Call Paths API] 将分析 ${filesToAnalyze.length} 个文件`);\r\n\r\n    for (const file of filesToAnalyze) {\r\n      try {\r\n        const { functions, classes } = lspAnalyzer.analyzeFile(file);\r\n        const relativePath = path.relative(projectRoot, file);\r\n\r\n        // 添加函数节点\r\n        for (const func of functions) {\r\n          const node: CallGraphNode = {\r\n            id: func.id,\r\n            name: func.name,\r\n            type: 'function',\r\n            moduleId: relativePath,\r\n            signature: func.signature,\r\n          };\r\n          allNodes.push(node);\r\n          symbolMap.set(func.name, node);\r\n          symbolMap.set(func.id, node);\r\n        }\r\n\r\n        // 添加类方法节点\r\n        for (const cls of classes) {\r\n          for (const method of cls.methods) {\r\n            const node: CallGraphNode = {\r\n              id: method.id,\r\n              name: method.name,\r\n              type: method.name === 'constructor' ? 'constructor' : 'method',\r\n              moduleId: relativePath,\r\n              className: cls.name,\r\n              signature: method.signature,\r\n            };\r\n            allNodes.push(node);\r\n            symbolMap.set(`${cls.name}.${method.name}`, node);\r\n            symbolMap.set(method.id, node);\r\n          }\r\n        }\r\n\r\n        // 提取调用关系（简化版本，只提取直接调用）\r\n        for (const func of functions) {\r\n          if (func.calls) {\r\n            for (const call of func.calls) {\r\n              const targetNode = symbolMap.get(call);\r\n              if (targetNode) {\r\n                allEdges.push({\r\n                  source: func.id,\r\n                  target: targetNode.id,\r\n                  type: 'direct',\r\n                  count: 1,\r\n                  locations: [],\r\n                });\r\n              }\r\n            }\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.error(`[Call Paths API] 分析文件失败: ${file}`, error);\r\n      }\r\n    }\r\n\r\n    console.log(`[Call Paths API] 调用图: ${allNodes.length} 节点, ${allEdges.length} 边`);\r\n\r\n    // 6. 从入口点开始追踪调用路径\r\n    // 找到入口点对应的节点\r\n    const entryNodes = allNodes.filter(n => {\r\n      // 使用 moduleId 匹配入口点（moduleId 是相对路径）\r\n      return n.moduleId === entry.moduleId || n.moduleId.includes(entry.moduleId);\r\n    });\r\n\r\n    console.log(`[Call Paths API] 找到 ${entryNodes.length} 个入口节点`);\r\n\r\n    // 7. BFS 追踪所有可达节点\r\n    const filePathMap = new Map<string, { depth: number; callCount: number; paths: string[][] }>();\r\n    const visited = new Set<string>();\r\n    const queue: Array<{ nodeId: string; depth: number; path: string[] }> = [];\r\n\r\n    // 初始化队列\r\n    for (const node of entryNodes) {\r\n      queue.push({ nodeId: node.id, depth: 0, path: [node.moduleId] });\r\n      visited.add(node.id);\r\n\r\n      filePathMap.set(node.moduleId, { depth: 0, callCount: 1, paths: [[node.moduleId]] });\r\n    }\r\n\r\n    // BFS 遍历\r\n    while (queue.length > 0) {\r\n      const { nodeId, depth: currentDepth, path: currentPath } = queue.shift()!;\r\n\r\n      if (currentDepth >= depth) continue;\r\n\r\n      // 找到所有出边\r\n      const outEdges = allEdges.filter(e => e.source === nodeId);\r\n\r\n      for (const edge of outEdges) {\r\n        const targetNode = allNodes.find(n => n.id === edge.target);\r\n        if (!targetNode) continue;\r\n\r\n        const targetModuleId = targetNode.moduleId;\r\n        const newPath = [...currentPath, targetModuleId];\r\n\r\n        // 更新文件路径映射\r\n        if (!filePathMap.has(targetModuleId)) {\r\n          filePathMap.set(targetModuleId, { depth: currentDepth + 1, callCount: 0, paths: [] });\r\n        }\r\n\r\n        const fileInfo = filePathMap.get(targetModuleId)!;\r\n        fileInfo.callCount++;\r\n        fileInfo.paths.push(newPath);\r\n\r\n        // 更新深度（保留最短路径深度）\r\n        if (currentDepth + 1 < fileInfo.depth) {\r\n          fileInfo.depth = currentDepth + 1;\r\n        }\r\n\r\n        // 继续遍历\r\n        if (!visited.has(edge.target)) {\r\n          visited.add(edge.target);\r\n          queue.push({ nodeId: edge.target, depth: currentDepth + 1, path: newPath });\r\n        }\r\n      }\r\n    }\r\n\r\n    // 8. 构建返回数据\r\n    const paths = Array.from(filePathMap.entries()).map(([filePath, info]) => ({\r\n      file: filePath,\r\n      depth: info.depth,\r\n      callCount: info.callCount,\r\n      paths: info.paths.slice(0, 5), // 最多返回5条路径示例\r\n    }));\r\n\r\n    // 按深度和调用次数排序\r\n    paths.sort((a, b) => {\r\n      if (a.depth !== b.depth) return a.depth - b.depth;\r\n      return b.callCount - a.callCount;\r\n    });\r\n\r\n    console.log(`[Call Paths API] 追踪到 ${paths.length} 个文件`);\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        entryPoint: {\r\n          id: entry.id,\r\n          name: entry.name,\r\n          moduleId: entry.moduleId,\r\n        },\r\n        paths,\r\n        stats: {\r\n          totalFiles: paths.length,\r\n          maxDepth: Math.max(...paths.map(p => p.depth), 0),\r\n          totalCalls: paths.reduce((sum, p) => sum + p.callCount, 0),\r\n        },\r\n      },\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[Call Paths API] 错误:', error);\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n// ============================================================================\r\n// 洋葱架构导航器 API (Onion Navigator)\r\n// ============================================================================\r\n\r\nimport {\r\n  analyzeProjectIntent,\r\n  analyzeBusinessDomains,\r\n  analyzeKeyProcesses,\r\n  analyzeImplementation,\r\n  generateAIAnnotation,\r\n} from './onion-analyzer.js';\r\nimport { OnionLayer } from '../../shared/onion-types.js';\r\n\r\n/**\r\n * 获取指定层级的洋葱数据\r\n * GET /api/blueprint/onion/layer/:layer\r\n *\r\n * 路径参数:\r\n * - layer: 1-4 (PROJECT_INTENT | BUSINESS_DOMAIN | KEY_PROCESS | IMPLEMENTATION)\r\n *\r\n * 查询参数:\r\n * - context: JSON 字符串，包含 fromLayer 和 nodeId\r\n * - forceRefresh: boolean\r\n * - filePath: 第四层需要的文件路径\r\n * - symbolId: 第四层可选的符号ID\r\n * - enableAI: boolean - 是否启用 AI 分析生成关键点（默认 true）\r\n */\r\nrouter.get('/onion/layer/:layer', async (req: Request, res: Response) => {\r\n  try {\r\n    const layer = parseInt(req.params.layer, 10) as OnionLayer;\r\n    const contextStr = req.query.context as string;\r\n    const forceRefresh = req.query.forceRefresh === 'true';\r\n    const filePath = req.query.filePath as string;\r\n    const symbolId = req.query.symbolId as string;\r\n    const nodeId = req.query.nodeId as string; // 直接获取 nodeId 参数\r\n    const fromLayer = req.query.fromLayer as string;\r\n    const enableAI = req.query.enableAI !== 'false'; // 默认启用 AI\r\n\r\n    if (layer < 1 || layer > 4) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: '无效的层级，必须是 1-4',\r\n      });\r\n    }\r\n\r\n    const projectRoot = process.cwd();\r\n    const startTime = Date.now();\r\n\r\n    let data: any;\r\n    let context: any;\r\n\r\n    // 优先使用直接传递的 nodeId 和 fromLayer 参数\r\n    if (nodeId || fromLayer) {\r\n      context = { nodeId, fromLayer };\r\n    } else if (contextStr) {\r\n      // 兼容旧的 context JSON 格式\r\n      try {\r\n        context = JSON.parse(contextStr);\r\n      } catch (e) {\r\n        console.warn('[Onion API] 无法解析 context:', contextStr);\r\n      }\r\n    }\r\n\r\n    console.log(`[Onion API] 请求层级 ${layer}，nodeId: ${nodeId || context?.nodeId || '无'}`);\r\n\r\n\r\n    switch (layer) {\r\n      case OnionLayer.PROJECT_INTENT:\r\n        data = await analyzeProjectIntent(projectRoot);\r\n        break;\r\n\r\n      case OnionLayer.BUSINESS_DOMAIN:\r\n        data = await analyzeBusinessDomains(projectRoot);\r\n        break;\r\n\r\n      case OnionLayer.KEY_PROCESS:\r\n        data = await analyzeKeyProcesses(projectRoot, context?.nodeId, forceRefresh);\r\n        break;\r\n\r\n      case OnionLayer.IMPLEMENTATION:\r\n        if (!filePath) {\r\n          return res.status(400).json({\r\n            success: false,\r\n            error: '第四层需要提供 filePath 参数',\r\n          });\r\n        }\r\n        data = await analyzeImplementation(projectRoot, filePath, symbolId);\r\n        break;\r\n    }\r\n\r\n    // 如果启用 AI 分析，且 annotation.keyPoints 包含占位符，则触发 AI 分析\r\n    if (enableAI && data?.annotation) {\r\n      const keyPoints = data.annotation.keyPoints || [];\r\n      const hasPlaceholder = keyPoints.some((kp: string) =>\r\n        kp.includes('待 AI 分析') || kp.includes('分析中')\r\n      );\r\n\r\n      if (hasPlaceholder) {\r\n        console.log(`[Onion API] 检测到占位符，触发 AI 分析: layer=${layer}`);\r\n\r\n        try {\r\n          const targetType = layer === OnionLayer.PROJECT_INTENT ? 'project'\r\n            : layer === OnionLayer.BUSINESS_DOMAIN ? 'module'\r\n            : layer === OnionLayer.KEY_PROCESS ? 'process'\r\n            : 'file';\r\n\r\n          const aiAnnotation = await generateAIAnnotation(\r\n            targetType,\r\n            data.annotation.targetId || 'project',\r\n            { projectRoot }\r\n          );\r\n\r\n          // 用 AI 分析结果更新 annotation\r\n          data.annotation = {\r\n            ...data.annotation,\r\n            summary: aiAnnotation.summary,\r\n            description: aiAnnotation.description,\r\n            keyPoints: aiAnnotation.keyPoints,\r\n            confidence: aiAnnotation.confidence,\r\n            analyzedAt: aiAnnotation.analyzedAt,\r\n          };\r\n\r\n          console.log(`[Onion API] AI 分析完成，关键点: ${aiAnnotation.keyPoints.length} 个`);\r\n        } catch (aiError: any) {\r\n          console.error('[Onion API] AI 分析失败，保持原有数据:', aiError.message);\r\n          // AI 分析失败不影响返回数据，保持原有占位符\r\n        }\r\n      }\r\n    }\r\n\r\n    const analysisTime = Date.now() - startTime;\r\n\r\n    res.json({\r\n      success: true,\r\n      layer,\r\n      data,\r\n      analysisTime,\r\n      fromCache: false, // TODO: 从分析器返回缓存状态\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[Onion API] 层级数据获取错误:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: error.message,\r\n    });\r\n  }\r\n});\r\n\r\n/**\r\n * 触发 AI 分析生成语义标注\r\n * POST /api/blueprint/onion/analyze\r\n *\r\n * 请求体:\r\n * {\r\n *   targetType: 'project' | 'module' | 'file' | 'symbol' | 'process',\r\n *   targetId: string,\r\n *   context?: { projectName, relatedModules }\r\n * }\r\n */\r\nrouter.post('/onion/analyze', async (req: Request, res: Response) => {\r\n  try {\r\n    const { targetType, targetId, context } = req.body;\r\n\r\n    if (!targetType || !targetId) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: '需要提供 targetType 和 targetId',\r\n      });\r\n    }\r\n\r\n    const annotation = await generateAIAnnotation(targetType, targetId, context);\r\n\r\n    res.json({\r\n      success: true,\r\n      annotation,\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[Onion API] AI 分析错误:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: error.message,\r\n    });\r\n  }\r\n});\r\n\r\n/**\r\n * 获取特定流程的详细步骤\r\n * GET /api/blueprint/onion/process-flow/:processId\r\n */\r\nrouter.get('/onion/process-flow/:processId', async (req: Request, res: Response) => {\r\n  try {\r\n    const { processId } = req.params;\r\n    const projectRoot = process.cwd();\r\n\r\n    // 获取所有流程数据\r\n    const processData = await analyzeKeyProcesses(projectRoot);\r\n\r\n    // 查找指定流程\r\n    const targetProcess = processData.processes.find(p => p.id === processId);\r\n\r\n    if (!targetProcess) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        error: '流程未找到',\r\n      });\r\n    }\r\n\r\n    res.json({\r\n      success: true,\r\n      data: targetProcess,\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[Onion API] 流程详情获取错误:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: error.message,\r\n    });\r\n  }\r\n});\r\n\r\n/**\r\n * 用户修改语义标注\r\n * PUT /api/blueprint/onion/annotation/:annotationId\r\n *\r\n * 请求体:\r\n * {\r\n *   summary?: string,\r\n *   description?: string,\r\n *   keyPoints?: string[]\r\n * }\r\n */\r\nrouter.put('/onion/annotation/:annotationId', async (req: Request, res: Response) => {\r\n  try {\r\n    const { annotationId } = req.params;\r\n    const { summary, description, keyPoints } = req.body;\r\n\r\n    // TODO: 实现标注更新和持久化\r\n    // 目前返回模拟成功\r\n\r\n    res.json({\r\n      success: true,\r\n      message: '标注已更新',\r\n      annotationId,\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[Onion API] 标注更新错误:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: error.message,\r\n    });\r\n  }\r\n});\r\n\r\n// ============================================================================\r\n// 符号语义分析 API\r\n// ============================================================================\r\n\r\n/**\r\n * 符号分析缓存\r\n * key: filePath:symbolName:line\r\n * 基于文件修改时间判断缓存是否有效\r\n */\r\nconst symbolAnalysisCache = new Map<string, {\r\n  data: any;\r\n  fileMtime: number; // 文件修改时间\r\n}>();\r\n\r\n/**\r\n * 分析代码符号（函数、类、方法等）\r\n * 返回语义描述、调用链、参数说明等信息\r\n */\r\nrouter.post('/analyze-symbol', async (req: Request, res: Response) => {\r\n  try {\r\n    const { filePath, symbolName, symbolKind, lineNumber, detail } = req.body;\r\n\r\n    if (!filePath || !symbolName) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: '缺少必要参数: filePath, symbolName',\r\n      });\r\n    }\r\n\r\n    const absolutePath = path.resolve(process.cwd(), filePath);\r\n\r\n    // 检查文件是否存在\r\n    if (!fs.existsSync(absolutePath)) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        error: `文件不存在: ${filePath}`,\r\n      });\r\n    }\r\n\r\n    // 获取文件修改时间\r\n    const stats = fs.statSync(absolutePath);\r\n    const currentMtime = stats.mtimeMs;\r\n\r\n    // 检查缓存（基于文件修改时间）\r\n    const cacheKey = `${filePath}:${symbolName}:${lineNumber || 0}`;\r\n    const cached = symbolAnalysisCache.get(cacheKey);\r\n    if (cached && cached.fileMtime === currentMtime) {\r\n      console.log(`[Analyze Symbol] 使用缓存 (文件未变化): ${symbolName} @ ${filePath}`);\r\n      return res.json({\r\n        success: true,\r\n        data: { ...cached.data, fromCache: true },\r\n      });\r\n    }\r\n\r\n    // 如果文件已修改，清除旧缓存\r\n    if (cached) {\r\n      console.log(`[Analyze Symbol] 文件已修改，清除旧缓存: ${symbolName} @ ${filePath}`);\r\n    }\r\n\r\n    const totalStart = Date.now();\r\n    console.log(`[Analyze Symbol] 开始分析符号: ${symbolName} (${symbolKind}) @ ${filePath}:${lineNumber}`);\r\n\r\n    // 读取文件内容\r\n    let t1 = Date.now();\r\n    const fileContent = fs.readFileSync(absolutePath, 'utf-8');\r\n    const lines = fileContent.split('\\n');\r\n    console.log(`[Analyze Symbol] 读取文件耗时: ${Date.now() - t1}ms`);\r\n\r\n    // 提取符号上下文（符号定义前后的代码，减少上下文加速 AI 分析）\r\n    const targetLine = lineNumber ? lineNumber - 1 : 0;\r\n    const contextStart = Math.max(0, targetLine - 3);\r\n    const contextEnd = Math.min(lines.length, targetLine + 50); // 从 50 减到 20 行\r\n    const symbolContext = lines.slice(contextStart, contextEnd).join('\\n');\r\n\r\n    // 分析文件内调用关系\r\n    t1 = Date.now();\r\n    const internalCalls = analyzeInternalCalls(fileContent, symbolName, symbolKind);\r\n    console.log(`[Analyze Symbol] analyzeInternalCalls 耗时: ${Date.now() - t1}ms`);\r\n\r\n    // 分析跨文件调用关系\r\n    t1 = Date.now();\r\n    const externalReferences = analyzeExternalReferences(filePath, symbolName);\r\n    console.log(`[Analyze Symbol] analyzeExternalReferences 耗时: ${Date.now() - t1}ms, 找到 ${externalReferences.length} 个引用`);\r\n\r\n    // 获取 AI 客户端 - 使用 Haiku 模型加速简单分析\r\n    const { ClaudeClient } = await import('../../../core/client.js');\r\n    const client = new ClaudeClient({ model: 'haiku' });\r\n\r\n    // 构建分析提示\r\n    const prompt = `请分析以下代码符号并生成语义分析报告。\r\n\r\n## 符号信息\r\n- 名称: ${symbolName}\r\n- 类型: ${symbolKind}\r\n- 文件: ${filePath}\r\n- 行号: ${lineNumber || '未知'}\r\n${detail ? `- 类型签名: ${detail}` : ''}\r\n\r\n## 符号代码上下文\r\n\\`\\`\\`\r\n${symbolContext}\r\n\\`\\`\\`\r\n\r\n## 文件内调用关系\r\n- 被调用位置: ${internalCalls.calledBy.length > 0 ? internalCalls.calledBy.map(c => `第${c.line}行 ${c.caller}`).join(', ') : '无'}\r\n- 调用的符号: ${internalCalls.calls.length > 0 ? internalCalls.calls.join(', ') : '无'}\r\n\r\n## 跨文件引用\r\n${externalReferences.length > 0 ? externalReferences.map(r => `- ${r.file}: ${r.imports.join(', ')}`).join('\\n') : '无外部引用'}\r\n\r\n请返回以下 JSON 格式的分析结果（只返回 JSON，不要其他内容）：\r\n{\r\n  \"semanticDescription\": \"这个${symbolKind === 'function' || symbolKind === 'method' ? '函数/方法' : symbolKind === 'class' ? '类' : '符号'}的核心功能是什么，用通俗易懂的语言描述，让新手也能理解\",\r\n  \"purpose\": \"这个符号存在的目的和解决的问题\",\r\n  \"parameters\": [{\"name\": \"参数名\", \"type\": \"类型\", \"description\": \"参数作用说明\"}],\r\n  \"returnValue\": {\"type\": \"返回类型\", \"description\": \"返回值说明\"},\r\n  \"usageExample\": \"一个简短的使用示例代码\",\r\n  \"relatedConcepts\": [\"相关的编程概念或设计模式\"],\r\n  \"complexity\": \"low|medium|high\",\r\n  \"tips\": [\"给新手的使用提示\"]\r\n}`;\r\n\r\n    // 调用 AI 分析\r\n    t1 = Date.now();\r\n    console.log(`[Analyze Symbol] 开始调用 AI...`);\r\n    const response = await client.createMessage(\r\n      [{ role: 'user', content: prompt }],\r\n      undefined,\r\n      '你是一个代码教育专家，擅长用通俗易懂的语言解释复杂的代码。分析代码符号并返回结构化的 JSON 结果。只返回 JSON，不要其他内容。'\r\n    );\r\n    console.log(`[Analyze Symbol] AI 调用耗时: ${Date.now() - t1}ms`);\r\n\r\n    // 提取响应文本\r\n    let analysisText = '';\r\n    for (const block of response.content) {\r\n      if (block.type === 'text') {\r\n        analysisText += block.text;\r\n      }\r\n    }\r\n\r\n    // 解析 JSON\r\n    let analysis: Record<string, any>;\r\n    try {\r\n      analysis = JSON.parse(analysisText.trim());\r\n    } catch {\r\n      const jsonMatch = analysisText.match(/```json\\s*([\\s\\S]*?)\\s*```/);\r\n      if (jsonMatch) {\r\n        analysis = JSON.parse(jsonMatch[1]);\r\n      } else {\r\n        const bareJsonMatch = analysisText.match(/\\{[\\s\\S]*\\}/);\r\n        if (bareJsonMatch) {\r\n          analysis = JSON.parse(bareJsonMatch[0]);\r\n        } else {\r\n          throw new Error(`无法解析 AI 返回的 JSON`);\r\n        }\r\n      }\r\n    }\r\n\r\n    // 组装完整结果\r\n    const result = {\r\n      symbolName,\r\n      symbolKind,\r\n      filePath,\r\n      lineNumber,\r\n      detail,\r\n      ...analysis,\r\n      internalCalls,\r\n      externalReferences,\r\n      analyzedAt: new Date().toISOString(),\r\n    };\r\n\r\n    // 保存到缓存\r\n    symbolAnalysisCache.set(cacheKey, {\r\n      data: result,\r\n      fileMtime: currentMtime, // 使用文件修改时间作为缓存依据\r\n    });\r\n\r\n    console.log(`[Analyze Symbol] 分析完成: ${symbolName}, 总耗时: ${Date.now() - totalStart}ms`);\r\n\r\n    res.json({\r\n      success: true,\r\n      data: { ...result, fromCache: false },\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[Analyze Symbol Error]', error);\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * 分析文件内调用关系\r\n */\r\nfunction analyzeInternalCalls(fileContent: string, symbolName: string, symbolKind: string): {\r\n  calledBy: Array<{ line: number; caller: string }>;\r\n  calls: string[];\r\n} {\r\n  const lines = fileContent.split('\\n');\r\n  const calledBy: Array<{ line: number; caller: string }> = [];\r\n  const calls: string[] = [];\r\n\r\n  // 简单的正则匹配来找调用关系\r\n  const callPattern = new RegExp(`\\\\b${symbolName}\\\\s*\\\\(`, 'g');\r\n\r\n  // 找到当前符号被调用的位置\r\n  let currentFunction = '';\r\n  for (let i = 0; i < lines.length; i++) {\r\n    const line = lines[i];\r\n\r\n    // 检测函数/方法定义（简化版）\r\n    const funcMatch = line.match(/(?:function|const|let|var)\\s+(\\w+)|(\\w+)\\s*[=:]\\s*(?:async\\s*)?\\(|(\\w+)\\s*\\(/);\r\n    if (funcMatch) {\r\n      currentFunction = funcMatch[1] || funcMatch[2] || funcMatch[3] || '';\r\n    }\r\n\r\n    // 检测对目标符号的调用\r\n    if (callPattern.test(line) && currentFunction !== symbolName) {\r\n      calledBy.push({ line: i + 1, caller: currentFunction || '顶层代码' });\r\n    }\r\n    callPattern.lastIndex = 0; // 重置正则\r\n  }\r\n\r\n  // 如果是函数/方法，分析它调用了哪些其他符号\r\n  if (symbolKind === 'function' || symbolKind === 'method') {\r\n    // 简单提取函数体中的调用\r\n    const funcCallPattern = /(\\w+)\\s*\\(/g;\r\n    let match;\r\n    while ((match = funcCallPattern.exec(fileContent)) !== null) {\r\n      const calledFunc = match[1];\r\n      // 排除常见的关键字和自身\r\n      if (!['if', 'for', 'while', 'switch', 'catch', 'function', 'return', symbolName].includes(calledFunc)) {\r\n        if (!calls.includes(calledFunc)) {\r\n          calls.push(calledFunc);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return { calledBy: calledBy.slice(0, 10), calls: calls.slice(0, 10) };\r\n}\r\n\r\n/**\r\n * 分析跨文件引用\r\n */\r\nfunction analyzeExternalReferences(filePath: string, symbolName: string): Array<{ file: string; imports: string[] }> {\r\n  const references: Array<{ file: string; imports: string[] }> = [];\r\n\r\n  try {\r\n    // 获取 src 目录下的所有 ts/tsx/js/jsx 文件\r\n    const srcDir = path.resolve(process.cwd(), 'src');\r\n    if (!fs.existsSync(srcDir)) {\r\n      return references;\r\n    }\r\n\r\n    const walkDir = (dir: string, files: string[] = []): string[] => {\r\n      const entries = fs.readdirSync(dir, { withFileTypes: true });\r\n      for (const entry of entries) {\r\n        if (entry.name.startsWith('.') || entry.name === 'node_modules') continue;\r\n        const fullPath = path.join(dir, entry.name);\r\n        if (entry.isDirectory()) {\r\n          walkDir(fullPath, files);\r\n        } else if (/\\.(ts|tsx|js|jsx)$/.test(entry.name)) {\r\n          files.push(fullPath);\r\n        }\r\n      }\r\n      return files;\r\n    };\r\n\r\n    const files = walkDir(srcDir).slice(0, 200); // 限制扫描文件数量\r\n    const targetFileName = path.basename(filePath, path.extname(filePath));\r\n\r\n    for (const file of files) {\r\n      if (file === path.resolve(process.cwd(), filePath)) continue;\r\n\r\n      try {\r\n        const content = fs.readFileSync(file, 'utf-8');\r\n\r\n        // 检查是否 import 了目标文件\r\n        const importPattern = new RegExp(`import\\\\s+.*from\\\\s+['\"]\\\\..*${targetFileName}['\"]`, 'g');\r\n        if (importPattern.test(content)) {\r\n          // 检查是否使用了目标符号\r\n          const usePattern = new RegExp(`\\\\b${symbolName}\\\\b`, 'g');\r\n          if (usePattern.test(content)) {\r\n            const relativePath = path.relative(process.cwd(), file);\r\n            references.push({\r\n              file: relativePath,\r\n              imports: [symbolName],\r\n            });\r\n          }\r\n        }\r\n      } catch {\r\n        // 忽略读取错误\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.error('[Analyze External References]', error);\r\n  }\r\n\r\n  return references.slice(0, 5); // 最多返回 5 个引用\r\n}\r\n\r\nexport default router;\r\n"
        }
    ]
}