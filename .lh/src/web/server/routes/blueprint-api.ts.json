{
    "sourceFile": "src/web/server/routes/blueprint-api.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1768364953091,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1768365008344,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4243,9 +4243,9 @@\n       undefined,\r\n       'ä½ æ˜¯ä¸€ä¸ªä»£ç æ•™è‚²ä¸“å®¶ï¼Œæ“…é•¿ç”¨é€šä¿—æ˜“æ‡‚çš„è¯­è¨€è§£é‡Šå¤æ‚çš„ä»£ç ã€‚åˆ†æä»£ç ç¬¦å·å¹¶è¿”å›ç»“æ„åŒ–çš„ JSON ç»“æœã€‚åªè¿”å› JSONï¼Œä¸è¦å…¶ä»–å†…å®¹ã€‚'\r\n     );\r\n     console.log(`[Analyze Symbol] AI è°ƒç”¨è€—æ—¶: ${Date.now() - t1}ms`);\r\n-\r\n+    console.log(`[Analyze Symbol] AI è¾“å…¥: ${prompt}`);\r\n     // æå–å“åº”æ–‡æœ¬\r\n     let analysisText = '';\r\n     for (const block of response.content) {\r\n       if (block.type === 'text') {\r\n"
                }
            ],
            "date": 1768364953091,
            "name": "Commit-0",
            "content": "/**\r\n * è“å›¾ç³»ç»Ÿ API è·¯ç”±\r\n *\r\n * æä¾›ï¼š\r\n * 1. è“å›¾ç®¡ç† API\r\n * 2. ä»»åŠ¡æ ‘ç®¡ç† API\r\n * 3. Agent åè°ƒ API\r\n * 4. æ—¶å…‰å€’æµ API\r\n * 5. å®æ—¶äº‹ä»¶æ¨é€ï¼ˆWebSocketï¼‰\r\n */\r\n\r\nimport { Router, Request, Response } from 'express';\r\nimport * as path from 'path';\r\nimport * as fs from 'fs';\r\nimport {\r\n  blueprintManager,\r\n  taskTreeManager,\r\n  agentCoordinator,\r\n  tddExecutor,\r\n  generateBlueprintSummary,\r\n  codebaseAnalyzer,\r\n  requirementDialogManager,\r\n} from '../../../blueprint/index.js';\r\nimport { timeTravelManager } from '../../../blueprint/time-travel.js';\r\nimport { analysisCache } from '../../../blueprint/analysis-cache.js';\r\nimport { CallGraphBuilder } from '../../../map/call-graph-builder.js';\r\nimport type { ModuleNode, CallGraphNode, CallGraphEdge } from '../../../map/types.js';\r\nimport { classifySymbol, canGenerateCallGraph } from './symbol-classifier.js';\r\nimport { calculateTotalLines, groupByDirectory, detectEntryPoints, getCoreSymbols } from './project-map-generator.js';\r\n\r\nconst router = Router();\r\n\r\n// ============================================================================\r\n// è“å›¾ API\r\n// ============================================================================\r\n\r\n/**\r\n * è·å–æ‰€æœ‰è“å›¾\r\n */\r\nrouter.get('/blueprints', (req: Request, res: Response) => {\r\n  try {\r\n    const blueprints = blueprintManager.getAllBlueprints();\r\n    res.json({\r\n      success: true,\r\n      data: blueprints.map(b => ({\r\n        id: b.id,\r\n        name: b.name,\r\n        description: b.description,\r\n        version: b.version,\r\n        status: b.status,\r\n        createdAt: b.createdAt,\r\n        updatedAt: b.updatedAt,\r\n        moduleCount: b.modules?.length || 0,\r\n        processCount: b.businessProcesses?.length || 0,\r\n        nfrCount: b.nfrs?.length || 0,\r\n      })),\r\n      total: blueprints.length,\r\n    });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * è·å–å•ä¸ªè“å›¾è¯¦æƒ…\r\n */\r\nrouter.get('/blueprints/:id', (req: Request, res: Response) => {\r\n  try {\r\n    const blueprint = blueprintManager.getBlueprint(req.params.id);\r\n    if (!blueprint) {\r\n      return res.status(404).json({ success: false, error: 'Blueprint not found' });\r\n    }\r\n    res.json({ success: true, data: blueprint });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * è·å–è“å›¾æ‘˜è¦ï¼ˆMarkdown æ ¼å¼ï¼‰\r\n */\r\nrouter.get('/blueprints/:id/summary', (req: Request, res: Response) => {\r\n  try {\r\n    const blueprint = blueprintManager.getBlueprint(req.params.id);\r\n    if (!blueprint) {\r\n      return res.status(404).json({ success: false, error: 'Blueprint not found' });\r\n    }\r\n    const summary = generateBlueprintSummary(blueprint);\r\n    res.json({ success: true, data: summary });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * åˆ›å»ºæ–°è“å›¾\r\n */\r\nrouter.post('/blueprints', (req: Request, res: Response) => {\r\n  try {\r\n    const { name, description } = req.body;\r\n    const blueprint = blueprintManager.createBlueprint(name, description);\r\n    res.json({ success: true, data: blueprint });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * æ·»åŠ ç³»ç»Ÿæ¨¡å—\r\n */\r\nrouter.post('/blueprints/:id/modules', (req: Request, res: Response) => {\r\n  try {\r\n    const module = blueprintManager.addModule(req.params.id, req.body);\r\n    res.json({ success: true, data: module });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * æ·»åŠ ä¸šåŠ¡æµç¨‹\r\n */\r\nrouter.post('/blueprints/:id/processes', (req: Request, res: Response) => {\r\n  try {\r\n    const process = blueprintManager.addBusinessProcess(req.params.id, req.body);\r\n    res.json({ success: true, data: process });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * æäº¤å®¡æ ¸\r\n */\r\nrouter.post('/blueprints/:id/submit', (req: Request, res: Response) => {\r\n  try {\r\n    const blueprint = blueprintManager.submitForReview(req.params.id);\r\n    res.json({ success: true, data: blueprint });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * æ‰¹å‡†è“å›¾\r\n */\r\nrouter.post('/blueprints/:id/approve', (req: Request, res: Response) => {\r\n  try {\r\n    const { approvedBy } = req.body;\r\n    const blueprint = blueprintManager.approveBlueprint(req.params.id, approvedBy);\r\n    res.json({ success: true, data: blueprint });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * æ‹’ç»è“å›¾\r\n */\r\nrouter.post('/blueprints/:id/reject', (req: Request, res: Response) => {\r\n  try {\r\n    const { reason } = req.body;\r\n    const blueprint = blueprintManager.rejectBlueprint(req.params.id, reason);\r\n    res.json({ success: true, data: blueprint });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * åˆ é™¤è“å›¾\r\n */\r\nrouter.delete('/blueprints/:id', (req: Request, res: Response) => {\r\n  try {\r\n    const success = blueprintManager.deleteBlueprint(req.params.id);\r\n    if (!success) {\r\n      return res.status(404).json({ success: false, error: 'Blueprint not found' });\r\n    }\r\n    res.json({ success: true, message: 'è“å›¾å·²åˆ é™¤' });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n// ============================================================================\r\n// é¡¹ç›®åœ°å›¾ API\r\n// ============================================================================\r\n\r\n/**\r\n * GET /api/blueprint/project-map\r\n *\r\n * è¿”å›é¡¹ç›®æ¦‚è§ˆä¿¡æ¯\r\n */\r\nrouter.get('/project-map', async (req: Request, res: Response) => {\r\n  try {\r\n    const projectRoot = process.cwd();\r\n    console.log('[Project Map] å¼€å§‹ç”Ÿæˆé¡¹ç›®åœ°å›¾...');\r\n\r\n    // 1. æ‰«æ TypeScript æ–‡ä»¶\r\n    const tsFiles: string[] = [];\r\n    const srcPath = path.join(projectRoot, 'src');\r\n\r\n    const scanDir = (dir: string) => {\r\n      if (!fs.existsSync(dir)) return;\r\n      const entries = fs.readdirSync(dir, { withFileTypes: true });\r\n\r\n      for (const entry of entries) {\r\n        const fullPath = path.join(dir, entry.name);\r\n        if (entry.isDirectory()) {\r\n          if (['node_modules', 'dist', '.git', '.lh', 'coverage'].includes(entry.name)) continue;\r\n          scanDir(fullPath);\r\n        } else if (entry.isFile()) {\r\n          const ext = path.extname(entry.name);\r\n          if (['.ts', '.tsx'].includes(ext)) {\r\n            tsFiles.push(fullPath);\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    scanDir(srcPath);\r\n    console.log(`[Project Map] æ‰«æåˆ° ${tsFiles.length} ä¸ª TypeScript æ–‡ä»¶`);\r\n\r\n    // 2. æ¨¡å—ç»Ÿè®¡\r\n    const totalLines = await calculateTotalLines(tsFiles);\r\n    const byDirectory = groupByDirectory(tsFiles);\r\n\r\n    const moduleStats = {\r\n      totalFiles: tsFiles.length,\r\n      totalLines,\r\n      byDirectory,\r\n      languages: { typescript: tsFiles.length },\r\n    };\r\n\r\n    console.log(`[Project Map] æ¨¡å—ç»Ÿè®¡: ${moduleStats.totalFiles} æ–‡ä»¶, ${moduleStats.totalLines} è¡Œä»£ç `);\r\n\r\n    // 3. æ¶æ„åˆ†å±‚ï¼ˆå¦‚æœå­˜åœ¨ layer-classifierï¼‰\r\n    let layers = null;\r\n    try {\r\n      const { LayerClassifier } = await import('../../../map/layer-classifier.js');\r\n      const { CodeMapAnalyzer } = await import('../../../map/analyzer.js');\r\n\r\n      // ä½¿ç”¨ analyzer æå–æ¨¡å—ä¿¡æ¯\r\n      const modules: ModuleNode[] = [];\r\n      const analyzer = new CodeMapAnalyzer(projectRoot);\r\n\r\n      for (const file of tsFiles.slice(0, 100)) { // é™åˆ¶æ•°é‡é¿å…å¤ªæ…¢\r\n        try {\r\n          const module = await analyzer.analyzeFile(file);\r\n          if (module) {\r\n            modules.push(module);\r\n          }\r\n        } catch (err) {\r\n          // å¿½ç•¥åˆ†æå¤±è´¥çš„æ–‡ä»¶\r\n        }\r\n      }\r\n\r\n      // åˆ†ç±»\r\n      const classifier = new LayerClassifier();\r\n      const classifications = classifier.classifyAll(modules);\r\n\r\n      // ç»Ÿè®¡æ¯å±‚çš„æ¨¡å—æ•°\r\n      const layerStats: Record<string, number> = {};\r\n      for (const [, result] of classifications) {\r\n        layerStats[result.layer] = (layerStats[result.layer] || 0) + 1;\r\n      }\r\n\r\n      layers = {\r\n        total: classifications.size,\r\n        distribution: layerStats,\r\n      };\r\n\r\n      console.log(`[Project Map] æ¶æ„åˆ†å±‚: ${JSON.stringify(layerStats)}`);\r\n    } catch (err) {\r\n      console.log(`[Project Map] æ¶æ„åˆ†å±‚åˆ†æè·³è¿‡: ${err}`);\r\n      // Layer classifier ä¸å­˜åœ¨æˆ–åˆ†æå¤±è´¥æ—¶è·³è¿‡\r\n    }\r\n\r\n    // 4. å…¥å£ç‚¹æ£€æµ‹\r\n    const entryPoints = await detectEntryPoints(tsFiles);\r\n    console.log(`[Project Map] æ£€æµ‹åˆ° ${entryPoints.length} ä¸ªå…¥å£ç‚¹`);\r\n\r\n    // 5. æ ¸å¿ƒç¬¦å· (ç®€åŒ–ç‰ˆæœ¬ï¼Œä»æ–‡ä»¶ä¸­æå–ç¬¦å·)\r\n    const allSymbols: any[] = [];\r\n    try {\r\n      // ä½¿ç”¨ LSP åˆ†æå™¨æå–ç¬¦å·\r\n      const { TypeScriptLSPAnalyzer } = await import('./lsp-analyzer.js');\r\n      const lspAnalyzer = new TypeScriptLSPAnalyzer();\r\n      lspAnalyzer.initProgram(tsFiles.slice(0, 50), projectRoot); // é™åˆ¶æ•°é‡\r\n\r\n      for (const file of tsFiles.slice(0, 50)) {\r\n        try {\r\n          const { functions, classes } = lspAnalyzer.analyzeFile(file);\r\n          const relativePath = path.relative(projectRoot, file);\r\n\r\n          for (const func of functions) {\r\n            allSymbols.push({\r\n              name: func.name,\r\n              kind: 'function',\r\n              moduleId: relativePath,\r\n            });\r\n          }\r\n\r\n          for (const cls of classes) {\r\n            allSymbols.push({\r\n              name: cls.name,\r\n              kind: 'class',\r\n              moduleId: relativePath,\r\n            });\r\n\r\n            for (const method of cls.methods) {\r\n              allSymbols.push({\r\n                name: method.name,\r\n                kind: 'method',\r\n                moduleId: relativePath,\r\n              });\r\n            }\r\n          }\r\n        } catch (err) {\r\n          // å¿½ç•¥åˆ†æå¤±è´¥çš„æ–‡ä»¶\r\n        }\r\n      }\r\n    } catch (err) {\r\n      console.log(`[Project Map] LSP ç¬¦å·æå–å¤±è´¥: ${err}`);\r\n      // LSP åˆ†æå™¨ä¸å­˜åœ¨æ—¶è·³è¿‡\r\n    }\r\n\r\n    const coreSymbols = await getCoreSymbols(allSymbols);\r\n    console.log(`[Project Map] æ ¸å¿ƒç¬¦å·: ${coreSymbols.classes.length} ç±», ${coreSymbols.functions.length} å‡½æ•°`);\r\n\r\n    console.log('[Project Map] é¡¹ç›®åœ°å›¾ç”Ÿæˆå®Œæˆ!');\r\n\r\n    res.json({\r\n      success: true,\r\n      data: { moduleStats, layers, entryPoints, coreSymbols },\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[Project Map] é”™è¯¯:', error);\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * GET /api/blueprint/treemap\r\n *\r\n * è¿”å›é¡¹ç›® Treemap æ•°æ®ï¼ˆçŸ©å½¢æ ‘å›¾ï¼‰\r\n *\r\n * æŸ¥è¯¢å‚æ•°:\r\n * - maxDepth: æœ€å¤§æ·±åº¦ (é»˜è®¤ 4)\r\n */\r\nrouter.get('/treemap', async (req: Request, res: Response) => {\r\n  try {\r\n    const { maxDepth = '4', includeSymbols = 'false' } = req.query;\r\n    const projectRoot = process.cwd();\r\n    const withSymbols = includeSymbols === 'true';\r\n\r\n    console.log(`[Treemap] å¼€å§‹ç”Ÿæˆ Treemap æ•°æ®... (ç¬¦å·çº§åˆ«: ${withSymbols})`);\r\n\r\n    // åŠ¨æ€å¯¼å…¥ treemap ç”Ÿæˆå‡½æ•°\r\n    const { generateTreemapDataAsync } = await import('./project-map-generator.js');\r\n\r\n    const treemapData = await generateTreemapDataAsync(\r\n      projectRoot,\r\n      parseInt(maxDepth as string, 10),\r\n      ['node_modules', '.git', 'dist', 'build', '.next', 'coverage', '__pycache__'],\r\n      withSymbols\r\n    );\r\n\r\n    console.log('[Treemap] Treemap æ•°æ®ç”Ÿæˆå®Œæˆ!');\r\n\r\n    res.json({\r\n      success: true,\r\n      data: treemapData,\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[Treemap] é”™è¯¯:', error);\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * GET /api/blueprint/layered-treemap\r\n *\r\n * åˆ†å±‚åŠ è½½ Treemap æ•°æ®ï¼ˆåœ°å›¾æ¨¡å¼ï¼‰\r\n *\r\n * æŸ¥è¯¢å‚æ•°:\r\n * - level: ç¼©æ”¾çº§åˆ« 0-4 (PROJECT/MODULE/FILE/SYMBOL/CODE)\r\n * - path: èšç„¦è·¯å¾„ï¼ˆå¯é€‰ï¼‰\r\n * - depth: åŠ è½½æ·±åº¦ï¼Œé»˜è®¤ 1\r\n */\r\nrouter.get('/layered-treemap', async (req: Request, res: Response) => {\r\n  try {\r\n    const {\r\n      level = '0',\r\n      path: focusPath = '',\r\n      depth = '1'\r\n    } = req.query;\r\n\r\n    const projectRoot = process.cwd();\r\n    const zoomLevel = parseInt(level as string, 10);\r\n    const loadDepth = parseInt(depth as string, 10);\r\n\r\n    console.log(`[LayeredTreemap] åŠ è½½æ•°æ®: level=${zoomLevel}, path=${focusPath}, depth=${loadDepth}`);\r\n\r\n    // åŠ¨æ€å¯¼å…¥åˆ†å±‚åŠ è½½å‡½æ•°\r\n    const { generateLayeredTreemapData, ZoomLevel } = await import('./project-map-generator.js');\r\n\r\n    // éªŒè¯ç¼©æ”¾çº§åˆ«\r\n    if (zoomLevel < ZoomLevel.PROJECT || zoomLevel > ZoomLevel.CODE) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: `æ— æ•ˆçš„ç¼©æ”¾çº§åˆ«: ${zoomLevel}ï¼Œåº”ä¸º 0-4`\r\n      });\r\n    }\r\n\r\n    const result = await generateLayeredTreemapData(\r\n      projectRoot,\r\n      zoomLevel as typeof ZoomLevel[keyof typeof ZoomLevel],\r\n      focusPath as string,\r\n      loadDepth,\r\n      ['node_modules', '.git', 'dist', 'build', '.next', 'coverage', '__pycache__']\r\n    );\r\n\r\n    console.log(`[LayeredTreemap] æ•°æ®åŠ è½½å®Œæˆ: ${result.stats.childCount} ä¸ªå­èŠ‚ç‚¹`);\r\n\r\n    res.json({\r\n      success: true,\r\n      data: result,\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[LayeredTreemap] é”™è¯¯:', error);\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * GET /api/blueprint/layered-treemap/children\r\n *\r\n * æ‡’åŠ è½½ç‰¹å®šèŠ‚ç‚¹çš„å­èŠ‚ç‚¹\r\n *\r\n * æŸ¥è¯¢å‚æ•°:\r\n * - path: èŠ‚ç‚¹è·¯å¾„\r\n * - level: å½“å‰ç¼©æ”¾çº§åˆ«\r\n */\r\nrouter.get('/layered-treemap/children', async (req: Request, res: Response) => {\r\n  try {\r\n    const {\r\n      path: nodePath,\r\n      level = '1'\r\n    } = req.query;\r\n\r\n    if (!nodePath) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: 'ç¼ºå°‘èŠ‚ç‚¹è·¯å¾„å‚æ•°'\r\n      });\r\n    }\r\n\r\n    const projectRoot = process.cwd();\r\n    const zoomLevel = parseInt(level as string, 10);\r\n\r\n    console.log(`[LayeredTreemap] æ‡’åŠ è½½å­èŠ‚ç‚¹: path=${nodePath}, level=${zoomLevel}`);\r\n\r\n    // åŠ¨æ€å¯¼å…¥æ‡’åŠ è½½å‡½æ•°\r\n    const { loadNodeChildren, ZoomLevel } = await import('./project-map-generator.js');\r\n\r\n    const children = await loadNodeChildren(\r\n      projectRoot,\r\n      nodePath as string,\r\n      zoomLevel as typeof ZoomLevel[keyof typeof ZoomLevel],\r\n      ['node_modules', '.git', 'dist', 'build', '.next', 'coverage', '__pycache__']\r\n    );\r\n\r\n    console.log(`[LayeredTreemap] åŠ è½½å®Œæˆ: ${children.length} ä¸ªå­èŠ‚ç‚¹`);\r\n\r\n    res.json({\r\n      success: true,\r\n      data: children,\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[LayeredTreemap] æ‡’åŠ è½½é”™è¯¯:', error);\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n// ============================================================================\r\n// æ–‡ä»¶æ ‘ & èŠ‚ç‚¹åˆ†æ API\r\n// ============================================================================\r\n\r\n/**\r\n * æ–‡ä»¶æ ‘èŠ‚ç‚¹æ¥å£\r\n */\r\ninterface FileTreeNode {\r\n  name: string;\r\n  path: string;\r\n  type: 'file' | 'directory';\r\n  children?: FileTreeNode[];\r\n}\r\n\r\n/**\r\n * è¯»å–æ–‡ä»¶å†…å®¹\r\n */\r\nrouter.get('/file-content', (req: Request, res: Response) => {\r\n  try {\r\n    const filePath = req.query.path as string;\r\n    if (!filePath) {\r\n      return res.status(400).json({ success: false, error: 'ç¼ºå°‘æ–‡ä»¶è·¯å¾„å‚æ•°' });\r\n    }\r\n\r\n    const absolutePath = path.resolve(process.cwd(), filePath);\r\n\r\n    // å®‰å…¨æ£€æŸ¥ï¼šç¡®ä¿è·¯å¾„åœ¨é¡¹ç›®ç›®å½•å†…\r\n    const cwd = process.cwd();\r\n    if (!absolutePath.startsWith(cwd)) {\r\n      return res.status(403).json({ success: false, error: 'ç¦æ­¢è®¿é—®é¡¹ç›®ç›®å½•å¤–çš„æ–‡ä»¶' });\r\n    }\r\n\r\n    // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨\r\n    if (!fs.existsSync(absolutePath)) {\r\n      return res.status(404).json({ success: false, error: `æ–‡ä»¶ä¸å­˜åœ¨: ${filePath}` });\r\n    }\r\n\r\n    const stats = fs.statSync(absolutePath);\r\n    if (!stats.isFile()) {\r\n      return res.status(400).json({ success: false, error: 'è·¯å¾„ä¸æ˜¯æ–‡ä»¶' });\r\n    }\r\n\r\n    // æ£€æŸ¥æ–‡ä»¶å¤§å°ï¼ˆé™åˆ¶ 1MBï¼‰\r\n    if (stats.size > 1024 * 1024) {\r\n      return res.status(413).json({ success: false, error: 'æ–‡ä»¶è¿‡å¤§ï¼Œè¶…è¿‡ 1MB é™åˆ¶' });\r\n    }\r\n\r\n    // è¯»å–æ–‡ä»¶å†…å®¹\r\n    const content = fs.readFileSync(absolutePath, 'utf-8');\r\n\r\n    // è·å–æ–‡ä»¶æ‰©å±•åç”¨äºè¯­æ³•é«˜äº®\r\n    const ext = path.extname(filePath).toLowerCase();\r\n    const languageMap: Record<string, string> = {\r\n      '.ts': 'typescript',\r\n      '.tsx': 'typescript',\r\n      '.js': 'javascript',\r\n      '.jsx': 'javascript',\r\n      '.json': 'json',\r\n      '.css': 'css',\r\n      '.scss': 'scss',\r\n      '.less': 'less',\r\n      '.html': 'html',\r\n      '.md': 'markdown',\r\n      '.py': 'python',\r\n      '.go': 'go',\r\n      '.rs': 'rust',\r\n      '.java': 'java',\r\n      '.c': 'c',\r\n      '.cpp': 'cpp',\r\n      '.h': 'c',\r\n      '.hpp': 'cpp',\r\n      '.yaml': 'yaml',\r\n      '.yml': 'yaml',\r\n      '.xml': 'xml',\r\n      '.sh': 'bash',\r\n      '.bat': 'batch',\r\n      '.ps1': 'powershell',\r\n      '.sql': 'sql',\r\n    };\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        path: filePath,\r\n        content,\r\n        language: languageMap[ext] || 'plaintext',\r\n        size: stats.size,\r\n        modifiedAt: stats.mtime.toISOString(),\r\n      },\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[File Content Error]', error);\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * ä¿å­˜æ–‡ä»¶å†…å®¹\r\n */\r\nrouter.put('/file-content', (req: Request, res: Response) => {\r\n  try {\r\n    const { path: filePath, content } = req.body;\r\n\r\n    if (!filePath) {\r\n      return res.status(400).json({ success: false, error: 'ç¼ºå°‘æ–‡ä»¶è·¯å¾„å‚æ•°' });\r\n    }\r\n\r\n    if (typeof content !== 'string') {\r\n      return res.status(400).json({ success: false, error: 'å†…å®¹å¿…é¡»æ˜¯å­—ç¬¦ä¸²' });\r\n    }\r\n\r\n    const absolutePath = path.resolve(process.cwd(), filePath);\r\n\r\n    // å®‰å…¨æ£€æŸ¥ï¼šç¡®ä¿è·¯å¾„åœ¨é¡¹ç›®ç›®å½•å†…\r\n    const cwd = process.cwd();\r\n    if (!absolutePath.startsWith(cwd)) {\r\n      return res.status(403).json({ success: false, error: 'ç¦æ­¢ä¿®æ”¹é¡¹ç›®ç›®å½•å¤–çš„æ–‡ä»¶' });\r\n    }\r\n\r\n    // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨\r\n    if (!fs.existsSync(absolutePath)) {\r\n      return res.status(404).json({ success: false, error: `æ–‡ä»¶ä¸å­˜åœ¨: ${filePath}` });\r\n    }\r\n\r\n    // å†™å…¥æ–‡ä»¶\r\n    fs.writeFileSync(absolutePath, content, 'utf-8');\r\n\r\n    const stats = fs.statSync(absolutePath);\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        path: filePath,\r\n        size: stats.size,\r\n        modifiedAt: stats.mtime.toISOString(),\r\n      },\r\n      message: 'æ–‡ä»¶ä¿å­˜æˆåŠŸ',\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[File Save Error]', error);\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * è·å–ç›®å½•æ ‘ç»“æ„\r\n */\r\nrouter.get('/file-tree', (req: Request, res: Response) => {\r\n  try {\r\n    const root = (req.query.root as string) || 'src';\r\n    const absoluteRoot = path.resolve(process.cwd(), root);\r\n\r\n    // æ£€æŸ¥ç›®å½•æ˜¯å¦å­˜åœ¨\r\n    if (!fs.existsSync(absoluteRoot)) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        error: `ç›®å½•ä¸å­˜åœ¨: ${root}`,\r\n      });\r\n    }\r\n\r\n    // é€’å½’æ„å»ºæ–‡ä»¶æ ‘\r\n    const buildTree = (dirPath: string, relativePath: string): FileTreeNode => {\r\n      const name = path.basename(dirPath);\r\n      const stats = fs.statSync(dirPath);\r\n\r\n      if (stats.isFile()) {\r\n        return {\r\n          name,\r\n          path: relativePath,\r\n          type: 'file',\r\n        };\r\n      }\r\n\r\n      // è¯»å–ç›®å½•å†…å®¹\r\n      const entries = fs.readdirSync(dirPath);\r\n\r\n      // è¿‡æ»¤æ‰ä¸éœ€è¦çš„æ–‡ä»¶å’Œç›®å½•\r\n      const filteredEntries = entries.filter(entry => {\r\n        // æ’é™¤éšè—æ–‡ä»¶ã€node_modulesã€dist ç­‰\r\n        if (entry.startsWith('.')) return false;\r\n        if (entry === 'node_modules') return false;\r\n        if (entry === 'dist') return false;\r\n        if (entry === 'coverage') return false;\r\n        if (entry === '__pycache__') return false;\r\n        return true;\r\n      });\r\n\r\n      // æ’åºï¼šç›®å½•åœ¨å‰ï¼Œæ–‡ä»¶åœ¨å\r\n      const children = filteredEntries\r\n        .map(entry => {\r\n          const entryPath = path.join(dirPath, entry);\r\n          const entryRelativePath = relativePath ? `${relativePath}/${entry}` : entry;\r\n          return buildTree(entryPath, entryRelativePath);\r\n        })\r\n        .sort((a, b) => {\r\n          if (a.type === b.type) return a.name.localeCompare(b.name);\r\n          return a.type === 'directory' ? -1 : 1;\r\n        });\r\n\r\n      return {\r\n        name,\r\n        path: relativePath || name,\r\n        type: 'directory',\r\n        children,\r\n      };\r\n    };\r\n\r\n    const tree = buildTree(absoluteRoot, root);\r\n\r\n    res.json({\r\n      success: true,\r\n      data: tree,\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[File Tree Error]', error);\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * è·å–æ¨¡å—å†…éƒ¨æ–‡ä»¶åˆ—è¡¨\r\n * GET /api/blueprint/module-files?path=src/core\r\n *\r\n * è¿”å›æ¨¡å—ç›®å½•ä¸‹çš„æ‰€æœ‰æ–‡ä»¶ï¼ˆå¸¦è¯­è¨€ã€è¡Œæ•°ç­‰ä¿¡æ¯ï¼‰\r\n */\r\nrouter.get('/module-files', (req: Request, res: Response) => {\r\n  try {\r\n    const modulePath = req.query.path as string;\r\n\r\n    if (!modulePath) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: 'ç¼ºå°‘ path å‚æ•°',\r\n      });\r\n    }\r\n\r\n    const absolutePath = path.resolve(process.cwd(), modulePath);\r\n\r\n    // æ£€æŸ¥ç›®å½•æ˜¯å¦å­˜åœ¨\r\n    if (!fs.existsSync(absolutePath)) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        error: `ç›®å½•ä¸å­˜åœ¨: ${modulePath}`,\r\n      });\r\n    }\r\n\r\n    // æ£€æŸ¥æ˜¯å¦æ˜¯ç›®å½•\r\n    if (!fs.statSync(absolutePath).isDirectory()) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: `è·¯å¾„ä¸æ˜¯ç›®å½•: ${modulePath}`,\r\n      });\r\n    }\r\n\r\n    interface ModuleFileInfo {\r\n      id: string;\r\n      name: string;\r\n      path: string;\r\n      type: 'file' | 'directory';\r\n      language?: string;\r\n      lineCount?: number;\r\n      symbolCount?: number;\r\n    }\r\n\r\n    // è¯­è¨€æ£€æµ‹æ˜ å°„\r\n    const EXT_TO_LANGUAGE: Record<string, string> = {\r\n      '.ts': 'TypeScript',\r\n      '.tsx': 'TypeScript',\r\n      '.js': 'JavaScript',\r\n      '.jsx': 'JavaScript',\r\n      '.css': 'CSS',\r\n      '.scss': 'SCSS',\r\n      '.json': 'JSON',\r\n      '.md': 'Markdown',\r\n      '.html': 'HTML',\r\n      '.yml': 'YAML',\r\n      '.yaml': 'YAML',\r\n    };\r\n\r\n    // é€’å½’è¯»å–æ–‡ä»¶åˆ—è¡¨\r\n    const files: ModuleFileInfo[] = [];\r\n\r\n    const readFiles = (dirPath: string, relativePath: string) => {\r\n      const entries = fs.readdirSync(dirPath, { withFileTypes: true });\r\n\r\n      for (const entry of entries) {\r\n        // è·³è¿‡éšè—æ–‡ä»¶å’Œ node_modules\r\n        if (entry.name.startsWith('.')) continue;\r\n        if (entry.name === 'node_modules') continue;\r\n        if (entry.name === 'dist') continue;\r\n        if (entry.name === '__pycache__') continue;\r\n\r\n        const fullPath = path.join(dirPath, entry.name);\r\n        const fileRelativePath = relativePath\r\n          ? `${relativePath}/${entry.name}`\r\n          : entry.name;\r\n\r\n        if (entry.isDirectory()) {\r\n          // é€’å½’è¯»å–å­ç›®å½•\r\n          readFiles(fullPath, fileRelativePath);\r\n        } else if (entry.isFile()) {\r\n          const ext = path.extname(entry.name);\r\n\r\n          // åªå¤„ç†æºä»£ç æ–‡ä»¶\r\n          if (!['.ts', '.tsx', '.js', '.jsx', '.css', '.scss', '.json', '.md', '.html', '.yml', '.yaml'].includes(ext)) {\r\n            continue;\r\n          }\r\n\r\n          let lineCount: number | undefined;\r\n          let symbolCount: number | undefined;\r\n\r\n          try {\r\n            const content = fs.readFileSync(fullPath, 'utf-8');\r\n            lineCount = content.split('\\n').length;\r\n\r\n            // ç®€å•ç»Ÿè®¡ç¬¦å·æ•°é‡\r\n            if (['.ts', '.tsx', '.js', '.jsx'].includes(ext)) {\r\n              const matches = content.match(\r\n                /(?:export\\s+)?(?:async\\s+)?(?:function|class|interface|type|const|let|var)\\s+\\w+/g\r\n              );\r\n              symbolCount = matches?.length || 0;\r\n            }\r\n          } catch (e) {\r\n            // å¿½ç•¥è¯»å–é”™è¯¯\r\n          }\r\n\r\n          files.push({\r\n            id: `file:${fileRelativePath}`,\r\n            name: entry.name,\r\n            path: path.join(modulePath, fileRelativePath).replace(/\\\\/g, '/'),\r\n            type: 'file',\r\n            language: EXT_TO_LANGUAGE[ext] || 'Other',\r\n            lineCount,\r\n            symbolCount,\r\n          });\r\n        }\r\n      }\r\n    };\r\n\r\n    readFiles(absolutePath, '');\r\n\r\n    // æŒ‰æ–‡ä»¶åæ’åº\r\n    files.sort((a, b) => a.name.localeCompare(b.name));\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        modulePath,\r\n        files,\r\n        total: files.length,\r\n      },\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[Module Files Error]', error);\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * è·å–å•ä¸ªæ–‡ä»¶çš„è¯¦æƒ…ä¿¡æ¯\r\n * GET /api/blueprint/file-detail?path=xxx\r\n */\r\nrouter.get('/file-detail', (req: Request, res: Response) => {\r\n  try {\r\n    const filePath = req.query.path as string;\r\n\r\n    if (!filePath) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: 'ç¼ºå°‘ path å‚æ•°',\r\n      });\r\n    }\r\n\r\n    const absolutePath = path.resolve(process.cwd(), filePath);\r\n\r\n    // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨\r\n    if (!fs.existsSync(absolutePath)) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        error: `æ–‡ä»¶ä¸å­˜åœ¨: ${filePath}`,\r\n      });\r\n    }\r\n\r\n    // æ£€æŸ¥æ˜¯å¦æ˜¯æ–‡ä»¶\r\n    const stat = fs.statSync(absolutePath);\r\n    if (!stat.isFile()) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: `è·¯å¾„ä¸æ˜¯æ–‡ä»¶: ${filePath}`,\r\n      });\r\n    }\r\n\r\n    // è¯­è¨€æ£€æµ‹æ˜ å°„\r\n    const EXT_TO_LANGUAGE: Record<string, string> = {\r\n      '.ts': 'TypeScript',\r\n      '.tsx': 'TypeScript',\r\n      '.js': 'JavaScript',\r\n      '.jsx': 'JavaScript',\r\n      '.css': 'CSS',\r\n      '.scss': 'SCSS',\r\n      '.json': 'JSON',\r\n      '.md': 'Markdown',\r\n      '.html': 'HTML',\r\n      '.yml': 'YAML',\r\n      '.yaml': 'YAML',\r\n      '.py': 'Python',\r\n      '.java': 'Java',\r\n      '.go': 'Go',\r\n      '.rs': 'Rust',\r\n    };\r\n\r\n    const fileName = path.basename(filePath);\r\n    const ext = path.extname(fileName);\r\n    const language = EXT_TO_LANGUAGE[ext] || 'Other';\r\n\r\n    let lineCount = 0;\r\n    let symbolCount = 0;\r\n    let imports: string[] = [];\r\n    let exports: string[] = [];\r\n    let summary = '';\r\n    let description = '';\r\n    let keyPoints: string[] = [];\r\n\r\n    try {\r\n      const content = fs.readFileSync(absolutePath, 'utf-8');\r\n      lineCount = content.split('\\n').length;\r\n\r\n      // åˆ†æ TypeScript/JavaScript æ–‡ä»¶\r\n      if (['.ts', '.tsx', '.js', '.jsx'].includes(ext)) {\r\n        // ç»Ÿè®¡ç¬¦å·æ•°é‡\r\n        const symbolMatches = content.match(\r\n          /(?:export\\s+)?(?:async\\s+)?(?:function|class|interface|type|const|let|var)\\s+\\w+/g\r\n        );\r\n        symbolCount = symbolMatches?.length || 0;\r\n\r\n        // æå– import è¯­å¥\r\n        const importMatches = content.match(/import\\s+.*?from\\s+['\"](.+?)['\"]/g);\r\n        if (importMatches) {\r\n          imports = importMatches.slice(0, 10).map((imp) => {\r\n            const match = imp.match(/from\\s+['\"](.+?)['\"]/);\r\n            return match ? match[1] : imp;\r\n          });\r\n        }\r\n\r\n        // æå– export è¯­å¥\r\n        const exportMatches = content.match(/export\\s+(?:default\\s+)?(?:async\\s+)?(?:function|class|interface|type|const|let|var)\\s+(\\w+)/g);\r\n        if (exportMatches) {\r\n          exports = exportMatches.slice(0, 10).map((exp) => {\r\n            const match = exp.match(/(?:function|class|interface|type|const|let|var)\\s+(\\w+)/);\r\n            return match ? match[1] : exp;\r\n          });\r\n        }\r\n\r\n        // åŸºäºæ–‡ä»¶å†…å®¹ç”Ÿæˆç®€å•æè¿°\r\n        const hasReact = content.includes('React') || content.includes('useState') || content.includes('useEffect');\r\n        const hasExpress = content.includes('express') || content.includes('router.') || content.includes('Request');\r\n        const isTest = fileName.includes('.test.') || fileName.includes('.spec.');\r\n        const isComponent = hasReact && (fileName.endsWith('.tsx') || fileName.endsWith('.jsx'));\r\n        const isHook = hasReact && fileName.startsWith('use');\r\n        const isApi = hasExpress || fileName.includes('api') || fileName.includes('route');\r\n\r\n        if (isTest) {\r\n          summary = `${fileName.replace(/\\.(test|spec)\\.(ts|tsx|js|jsx)$/, '')} çš„æµ‹è¯•æ–‡ä»¶`;\r\n          description = `åŒ…å«é’ˆå¯¹ç›¸å…³æ¨¡å—çš„å•å…ƒæµ‹è¯•æˆ–é›†æˆæµ‹è¯•`;\r\n          keyPoints = ['æµ‹è¯•ç”¨ä¾‹', 'å¾… AI åˆ†æè¯¦ç»†å†…å®¹'];\r\n        } else if (isHook) {\r\n          summary = `${fileName.replace(/\\.(ts|tsx)$/, '')} è‡ªå®šä¹‰ Hook`;\r\n          description = `React è‡ªå®šä¹‰ Hookï¼Œæä¾›å¯å¤ç”¨çš„çŠ¶æ€é€»è¾‘`;\r\n          keyPoints = ['React Hook', 'çŠ¶æ€ç®¡ç†', 'å¾… AI åˆ†æè¯¦ç»†å†…å®¹'];\r\n        } else if (isComponent) {\r\n          summary = `${fileName.replace(/\\.(tsx|jsx)$/, '')} React ç»„ä»¶`;\r\n          description = `React ç»„ä»¶ï¼Œè´Ÿè´£ UI æ¸²æŸ“å’Œäº¤äº’é€»è¾‘`;\r\n          keyPoints = ['React ç»„ä»¶', 'UI æ¸²æŸ“', 'å¾… AI åˆ†æè¯¦ç»†å†…å®¹'];\r\n        } else if (isApi) {\r\n          summary = `${fileName.replace(/\\.(ts|js)$/, '')} API æ¨¡å—`;\r\n          description = `API è·¯ç”±æˆ–æœåŠ¡ç«¯æ¥å£å®ç°`;\r\n          keyPoints = ['API ç«¯ç‚¹', 'è¯·æ±‚å¤„ç†', 'å¾… AI åˆ†æè¯¦ç»†å†…å®¹'];\r\n        } else {\r\n          summary = `${fileName} æ¨¡å—`;\r\n          description = `${language} ä»£ç æ–‡ä»¶`;\r\n          keyPoints = ['å¾… AI åˆ†æè¯¦ç»†å†…å®¹'];\r\n        }\r\n      } else if (ext === '.css' || ext === '.scss') {\r\n        summary = `${fileName} æ ·å¼æ–‡ä»¶`;\r\n        description = `CSS æ ·å¼è¡¨ï¼Œå®šä¹‰ç»„ä»¶æˆ–é¡µé¢çš„è§†è§‰æ ·å¼`;\r\n        keyPoints = ['æ ·å¼å®šä¹‰', 'å¾… AI åˆ†æè¯¦ç»†å†…å®¹'];\r\n      } else if (ext === '.json') {\r\n        summary = `${fileName} é…ç½®æ–‡ä»¶`;\r\n        description = `JSON æ ¼å¼çš„é…ç½®æˆ–æ•°æ®æ–‡ä»¶`;\r\n        keyPoints = ['é…ç½®æ•°æ®', 'å¾… AI åˆ†æè¯¦ç»†å†…å®¹'];\r\n      } else if (ext === '.md') {\r\n        summary = `${fileName} æ–‡æ¡£`;\r\n        description = `Markdown æ ¼å¼çš„æ–‡æ¡£æˆ–è¯´æ˜æ–‡ä»¶`;\r\n        keyPoints = ['æ–‡æ¡£è¯´æ˜', 'å¾… AI åˆ†æè¯¦ç»†å†…å®¹'];\r\n      } else {\r\n        summary = `${fileName} æ–‡ä»¶`;\r\n        description = `${language} ä»£ç æ–‡ä»¶`;\r\n        keyPoints = ['å¾… AI åˆ†æè¯¦ç»†å†…å®¹'];\r\n      }\r\n    } catch (e) {\r\n      // è¯»å–å¤±è´¥æ—¶ä½¿ç”¨é»˜è®¤å€¼\r\n      summary = `${fileName} æ–‡ä»¶`;\r\n      description = `æ— æ³•è¯»å–æ–‡ä»¶å†…å®¹`;\r\n      keyPoints = ['æ–‡ä»¶è¯»å–å¤±è´¥'];\r\n    }\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        path: filePath,\r\n        name: fileName,\r\n        language,\r\n        lineCount,\r\n        symbolCount,\r\n        imports,\r\n        exports,\r\n        annotation: {\r\n          summary,\r\n          description,\r\n          keyPoints,\r\n          confidence: 0.6, // é™æ€åˆ†æç½®ä¿¡åº¦è¾ƒä½\r\n          userModified: false,\r\n        },\r\n      },\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[File Detail Error]', error);\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * æŸ¥æ‰¾åå‘ä¾èµ–ï¼ˆå“ªäº›æ–‡ä»¶å¼•ç”¨äº†å½“å‰æ–‡ä»¶ï¼‰\r\n */\r\nconst findReverseDependencies = (targetPath: string, rootDir: string = 'src'): Array<{path: string, imports: string[]}> => {\r\n  const results: Array<{path: string, imports: string[]}> = [];\r\n  const absoluteRoot = path.resolve(process.cwd(), rootDir);\r\n  const targetRelative = path.relative(process.cwd(), path.resolve(process.cwd(), targetPath));\r\n\r\n  // é€’å½’éå†æ‰€æœ‰æ–‡ä»¶\r\n  const scanDirectory = (dirPath: string) => {\r\n    if (!fs.existsSync(dirPath)) return;\r\n\r\n    const entries = fs.readdirSync(dirPath);\r\n    for (const entry of entries) {\r\n      if (entry.startsWith('.') || entry === 'node_modules' || entry === 'dist') continue;\r\n\r\n      const fullPath = path.join(dirPath, entry);\r\n      const stats = fs.statSync(fullPath);\r\n\r\n      if (stats.isDirectory()) {\r\n        scanDirectory(fullPath);\r\n      } else if (stats.isFile() && /\\.(ts|tsx|js|jsx)$/.test(entry)) {\r\n        try {\r\n          const content = fs.readFileSync(fullPath, 'utf-8');\r\n          const imports: string[] = [];\r\n\r\n          // åŒ¹é… import å’Œ export è¯­å¥ï¼ˆåŒ…æ‹¬ export ... fromï¼‰\r\n          const importExportRegex = /(?:import|export)\\s+(?:[\\s\\S]*?)\\s+from\\s+['\"]([^'\"]+)['\"]/g;\r\n          let match;\r\n          while ((match = importExportRegex.exec(content)) !== null) {\r\n            const importPath = match[1];\r\n\r\n            // è§£æç›¸å¯¹è·¯å¾„\r\n            if (importPath.startsWith('.')) {\r\n              const currentDir = path.dirname(fullPath);\r\n              const resolvedImport = path.resolve(currentDir, importPath);\r\n              const normalizedImport = path.relative(process.cwd(), resolvedImport);\r\n\r\n              // æ£€æŸ¥æ˜¯å¦åŒ¹é…ç›®æ ‡æ–‡ä»¶ï¼ˆè€ƒè™‘æ‰©å±•åï¼‰\r\n              const targetWithoutExt = targetRelative.replace(/\\.(ts|tsx|js|jsx)$/, '');\r\n              const importWithoutExt = normalizedImport.replace(/\\.(ts|tsx|js|jsx)$/, '');\r\n\r\n              if (importWithoutExt === targetWithoutExt || normalizedImport === targetRelative) {\r\n                // æå–å¯¼å…¥/å¯¼å‡ºçš„å…·ä½“é¡¹\r\n                const fullStatement = match[0];\r\n\r\n                // åŒ¹é… export * from\r\n                if (/export\\s+\\*\\s+from/.test(fullStatement)) {\r\n                  imports.push('* (æ‰€æœ‰å¯¼å‡º)');\r\n                }\r\n                // åŒ¹é… { ... } å½¢å¼\r\n                else {\r\n                  const items = fullStatement.match(/(?:import|export)\\s+\\{([^}]+)\\}/);\r\n                  if (items) {\r\n                    imports.push(...items[1].split(',').map(s => s.trim()));\r\n                  } else {\r\n                    // åŒ¹é…é»˜è®¤å¯¼å…¥/å¯¼å‡º\r\n                    const defaultItem = fullStatement.match(/(?:import|export)\\s+(\\w+)\\s+from/);\r\n                    if (defaultItem) {\r\n                      imports.push(defaultItem[1]);\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n\r\n          if (imports.length > 0) {\r\n            results.push({\r\n              path: path.relative(process.cwd(), fullPath).replace(/\\\\/g, '/'),\r\n              imports,\r\n            });\r\n          }\r\n        } catch (err) {\r\n          // å¿½ç•¥æ— æ³•è¯»å–çš„æ–‡ä»¶\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  scanDirectory(absoluteRoot);\r\n  return results;\r\n};\r\n\r\n/**\r\n * åˆ†æå•ä¸ªèŠ‚ç‚¹ï¼ˆæ–‡ä»¶æˆ–ç›®å½•ï¼‰\r\n * ä½¿ç”¨ getDefaultClient() è·å–å·²è®¤è¯çš„ Claude å®¢æˆ·ç«¯ï¼ˆä¸å…¶ä»–æ¨¡å—ä¸€è‡´ï¼‰\r\n */\r\nrouter.post('/analyze-node', async (req: Request, res: Response) => {\r\n  try {\r\n    const { path: nodePath } = req.body;\r\n\r\n    if (!nodePath) {\r\n      return res.status(400).json({ success: false, error: 'ç¼ºå°‘è·¯å¾„å‚æ•°' });\r\n    }\r\n\r\n    const absolutePath = path.resolve(process.cwd(), nodePath);\r\n\r\n    // æ£€æŸ¥è·¯å¾„æ˜¯å¦å­˜åœ¨\r\n    if (!fs.existsSync(absolutePath)) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        error: `è·¯å¾„ä¸å­˜åœ¨: ${nodePath}`,\r\n      });\r\n    }\r\n\r\n    const stats = fs.statSync(absolutePath);\r\n    const isFile = stats.isFile();\r\n    const name = path.basename(nodePath);\r\n\r\n    console.log(`[Analyze Node] å¼€å§‹åˆ†æ: ${nodePath} (${isFile ? 'æ–‡ä»¶' : 'ç›®å½•'})`);\r\n\r\n    // æ£€æŸ¥ç¼“å­˜\r\n    const cachedAnalysis = analysisCache.get(absolutePath, isFile);\r\n    if (cachedAnalysis) {\r\n      console.log(`[Analyze Node] ä½¿ç”¨ç¼“å­˜ç»“æœ: ${nodePath}`);\r\n\r\n      // å³ä½¿ä½¿ç”¨ç¼“å­˜ï¼Œä¹Ÿè®¡ç®—åå‘ä¾èµ–ï¼ˆå› ä¸ºå…¶ä»–æ–‡ä»¶å¯èƒ½å˜åŒ–ï¼‰\r\n      let reverseDeps: Array<{path: string, imports: string[]}> = [];\r\n      if (isFile) {\r\n        reverseDeps = findReverseDependencies(nodePath);\r\n      }\r\n\r\n      return res.json({\r\n        success: true,\r\n        data: {\r\n          ...cachedAnalysis,\r\n          reverseDependencies: reverseDeps,\r\n          fromCache: true,\r\n        },\r\n      });\r\n    }\r\n\r\n    console.log(`[Analyze Node] ç¼“å­˜æœªå‘½ä¸­ï¼Œè°ƒç”¨ AI åˆ†æ...`);\r\n\r\n    // ä½¿ç”¨ getDefaultClient() è·å–å·²è®¤è¯çš„å®¢æˆ·ç«¯ï¼ˆä¸å…¶ä»–æ¨¡å—ä¸€è‡´ï¼‰\r\n    const { getDefaultClient } = await import('../../../core/client.js');\r\n    const client = getDefaultClient();\r\n\r\n    // è¯»å–æ–‡ä»¶/ç›®å½•å†…å®¹\r\n    let contentInfo = '';\r\n    if (isFile) {\r\n      const content = fs.readFileSync(absolutePath, 'utf-8');\r\n      contentInfo = `æ–‡ä»¶å†…å®¹ï¼ˆå‰ 5000 å­—ç¬¦ï¼‰:\\n\\`\\`\\`\\n${content.slice(0, 5000)}\\n\\`\\`\\``;\r\n    } else {\r\n      const entries = fs.readdirSync(absolutePath);\r\n      const filtered = entries.filter(e => !e.startsWith('.') && e !== 'node_modules');\r\n      contentInfo = `ç›®å½•å†…å®¹:\\n${filtered.join('\\n')}`;\r\n    }\r\n\r\n    // æ„å»ºåˆ†ææç¤º\r\n    const prompt = `è¯·åˆ†æä»¥ä¸‹${isFile ? 'æ–‡ä»¶' : 'ç›®å½•'}å¹¶ç”Ÿæˆ JSON æ ¼å¼çš„è¯­ä¹‰åˆ†ææŠ¥å‘Šï¼š\r\n\r\nè·¯å¾„: ${nodePath}\r\nç±»å‹: ${isFile ? 'æ–‡ä»¶' : 'ç›®å½•'}\r\nåç§°: ${name}\r\n\r\n${contentInfo}\r\n\r\nè¯·è¿”å›ä»¥ä¸‹ JSON æ ¼å¼çš„åˆ†æç»“æœï¼ˆåªè¿”å› JSONï¼Œä¸è¦å…¶ä»–å†…å®¹ï¼‰ï¼š\r\n{\r\n  \"path\": \"${nodePath}\",\r\n  \"name\": \"${name}\",\r\n  \"type\": \"${isFile ? 'file' : 'directory'}\",\r\n  \"summary\": \"ç®€çŸ­æ‘˜è¦ï¼ˆä¸€å¥è¯æè¿°ä¸»è¦åŠŸèƒ½ï¼‰\",\r\n  \"description\": \"è¯¦ç»†æè¿°\",\r\n  ${isFile ? `\"exports\": [\"å¯¼å‡ºçš„å‡½æ•°/ç±»/å˜é‡å\"],\r\n  \"dependencies\": [\"ä¾èµ–çš„æ¨¡å—\"],\r\n  \"keyPoints\": [\"å…³é”®ç‚¹1\", \"å…³é”®ç‚¹2\"],` : `\"responsibilities\": [\"èŒè´£1\", \"èŒè´£2\"],\r\n  \"children\": [{\"name\": \"å­é¡¹å\", \"description\": \"å­é¡¹æè¿°\"}],`}\r\n  \"techStack\": [\"ä½¿ç”¨çš„æŠ€æœ¯\"]\r\n}`;\r\n\r\n    // è°ƒç”¨ AI åˆ†æ\r\n    const response = await client.createMessage(\r\n      [{ role: 'user', content: prompt }],\r\n      undefined,\r\n      'ä½ æ˜¯ä¸€ä¸ªä»£ç åˆ†æä¸“å®¶ã€‚åˆ†æä»£ç å¹¶è¿”å›ç»“æ„åŒ–çš„ JSON ç»“æœã€‚åªè¿”å› JSONï¼Œä¸è¦å…¶ä»–å†…å®¹ã€‚'\r\n    );\r\n\r\n    // æå–å“åº”æ–‡æœ¬\r\n    let analysisText = '';\r\n    for (const block of response.content) {\r\n      if (block.type === 'text') {\r\n        analysisText += block.text;\r\n      }\r\n    }\r\n\r\n    console.log(`[Analyze Node] AI è¿”å›ç»“æœé•¿åº¦: ${analysisText.length}`);\r\n\r\n    // æå– JSON\r\n    let analysis: Record<string, any>;\r\n    // å°è¯•ç›´æ¥è§£æ\r\n    try {\r\n      analysis = JSON.parse(analysisText.trim());\r\n    } catch {\r\n      // å°è¯•æå– JSON å—\r\n      const jsonMatch = analysisText.match(/```json\\s*([\\s\\S]*?)\\s*```/);\r\n      if (jsonMatch) {\r\n        analysis = JSON.parse(jsonMatch[1]);\r\n      } else {\r\n        // å°è¯•åŒ¹é…è£¸ JSON\r\n        const bareJsonMatch = analysisText.match(/\\{[\\s\\S]*\\}/);\r\n        if (bareJsonMatch) {\r\n          analysis = JSON.parse(bareJsonMatch[0]);\r\n        } else {\r\n          // æ— æ³•è§£æ JSONï¼Œç›´æ¥æŠ¥é”™\r\n          throw new Error(`æ— æ³•è§£æ AI è¿”å›çš„ JSON: ${analysisText.slice(0, 200)}`);\r\n        }\r\n      }\r\n    }\r\n\r\n    // æ·»åŠ åˆ†ææ—¶é—´\r\n    analysis.analyzedAt = new Date().toISOString();\r\n\r\n    // è®¡ç®—åå‘ä¾èµ–ï¼ˆæ–‡ä»¶ï¼‰\r\n    let reverseDeps: Array<{path: string, imports: string[]}> = [];\r\n    if (isFile) {\r\n      reverseDeps = findReverseDependencies(nodePath);\r\n    }\r\n\r\n    // ä¿å­˜åˆ°ç¼“å­˜\r\n    analysisCache.set(absolutePath, isFile, analysis);\r\n\r\n    console.log(`[Analyze Node] åˆ†æå®Œæˆ: ${nodePath}`);\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        ...analysis,\r\n        reverseDependencies: reverseDeps,\r\n        fromCache: false,\r\n      },\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[Analyze Node Error]', error);\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n// ============================================================================\r\n// ä¸€é”®åˆ†æ API\r\n// ============================================================================\r\n\r\n/**\r\n * åˆ†æç°æœ‰ä»£ç åº“å¹¶ç”Ÿæˆè“å›¾\r\n */\r\nrouter.post('/analyze', async (req: Request, res: Response) => {\r\n  try {\r\n    const { rootDir = '.', projectName, projectDescription, granularity = 'medium' } = req.body;\r\n\r\n    // ä½¿ç”¨ä»£ç åº“åˆ†æå™¨\r\n    const result = await codebaseAnalyzer.analyzeAndGenerate({\r\n      rootDir,\r\n      projectName,\r\n      projectDescription,\r\n      granularity,\r\n    });\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        codebase: {\r\n          name: result.codebase.name,\r\n          description: result.codebase.description,\r\n          stats: result.codebase.stats,\r\n          modules: result.codebase.modules.map(m => ({\r\n            name: m.name,\r\n            path: m.path,\r\n            type: m.type,\r\n            fileCount: m.files.length,\r\n          })),\r\n        },\r\n        blueprint: {\r\n          id: result.blueprint.id,\r\n          name: result.blueprint.name,\r\n          moduleCount: result.blueprint.modules.length,\r\n          processCount: result.blueprint.businessProcesses.length,\r\n        },\r\n        taskTree: {\r\n          id: result.taskTree.id,\r\n          taskCount: result.taskTree.stats.totalTasks,\r\n          maxDepth: result.taskTree.stats.maxDepth,\r\n        },\r\n      },\r\n    });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * è·å–åˆ†æè¿›åº¦ï¼ˆç”¨äºé•¿æ—¶é—´è¿è¡Œçš„åˆ†æï¼‰\r\n */\r\nrouter.get('/analyze/status', (req: Request, res: Response) => {\r\n  try {\r\n    // ç®€å•å®ç°ï¼šè¿”å›å½“å‰çŠ¶æ€\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        status: 'idle',\r\n        progress: 0,\r\n        message: 'ç­‰å¾…åˆ†æä»»åŠ¡',\r\n      },\r\n    });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * æ™ºèƒ½ç”Ÿæˆè“å›¾\r\n *\r\n * æ ¹æ®å½“å‰é¡¹ç›®çŠ¶æ€é€‰æ‹©åˆé€‚çš„ç”Ÿæˆæ–¹å¼ï¼š\r\n * - æœ‰ä»£ç ï¼šåˆ†æç°æœ‰ä»£ç åº“ç”Ÿæˆè“å›¾\r\n * - æ— ä»£ç ï¼šæç¤ºç”¨æˆ·è¿›è¡Œå¯¹è¯å¼éœ€æ±‚è°ƒç ”\r\n */\r\nrouter.post('/generate', async (req: Request, res: Response) => {\r\n  const startTime = Date.now();\r\n  console.log('\\n========================================');\r\n  console.log('[Blueprint Generate] ğŸš€ å¼€å§‹ç”Ÿæˆè“å›¾');\r\n  console.log('========================================');\r\n\r\n  try {\r\n    const { projectRoot = '.' } = req.body;\r\n\r\n    // å°†ç›¸å¯¹è·¯å¾„è½¬ä¸ºç»å¯¹è·¯å¾„ï¼Œç¡®ä¿é¡¹ç›®åç§°æ­£ç¡®\r\n    const absoluteRoot = path.resolve(process.cwd(), projectRoot);\r\n    console.log(`[Blueprint Generate] ğŸ“ é¡¹ç›®æ ¹ç›®å½•: ${absoluteRoot}`);\r\n\r\n    // Step 1: è®¾ç½®é…ç½®\r\n    console.log('[Blueprint Generate] âš™ï¸  Step 1: è®¾ç½®ä»£ç åº“åˆ†æå™¨é…ç½®...');\r\n    codebaseAnalyzer.setRootDir(absoluteRoot);\r\n\r\n    // Step 2: åˆ†æä»£ç åº“\r\n    console.log('[Blueprint Generate] ğŸ” Step 2: åˆ†æä»£ç åº“ç»“æ„...');\r\n    const analyzeStart = Date.now();\r\n    const codebaseInfo = await codebaseAnalyzer.analyze();\r\n    console.log(`[Blueprint Generate]    âœ“ åˆ†æå®Œæˆï¼Œè€—æ—¶ ${Date.now() - analyzeStart}ms`);\r\n    console.log(`[Blueprint Generate]    - é¡¹ç›®åç§°: ${codebaseInfo.name}`);\r\n    console.log(`[Blueprint Generate]    - æ£€æµ‹åˆ°æ¨¡å—: ${codebaseInfo.modules.length} ä¸ª`);\r\n    console.log(`[Blueprint Generate]    - æ€»æ–‡ä»¶æ•°: ${codebaseInfo.stats.totalFiles}`);\r\n    console.log(`[Blueprint Generate]    - æ€»ä»£ç è¡Œ: ${codebaseInfo.stats.totalLines}`);\r\n    if (codebaseInfo.modules.length > 0) {\r\n      console.log(`[Blueprint Generate]    - æ¨¡å—åˆ—è¡¨: ${codebaseInfo.modules.map(m => m.name).join(', ')}`);\r\n    }\r\n\r\n    // Step 3: åˆ¤æ–­æ˜¯å¦æœ‰è¶³å¤Ÿçš„ä»£ç \r\n    console.log('[Blueprint Generate] ğŸ“Š Step 3: åˆ¤æ–­ä»£ç åº“æ˜¯å¦æ»¡è¶³è¦æ±‚...');\r\n    const hasCode = codebaseInfo.modules.length > 0 &&\r\n                    codebaseInfo.stats.totalFiles > 5;\r\n\r\n    if (!hasCode) {\r\n      console.log('[Blueprint Generate] âš ï¸  ä»£ç ä¸è¶³ï¼Œéœ€è¦å¯¹è¯å¼è°ƒç ”');\r\n      console.log(`[Blueprint Generate]    - æ¨¡å—æ•°: ${codebaseInfo.modules.length} (éœ€è¦ > 0)`);\r\n      console.log(`[Blueprint Generate]    - æ–‡ä»¶æ•°: ${codebaseInfo.stats.totalFiles} (éœ€è¦ > 5)`);\r\n      console.log(`[Blueprint Generate] æ€»è€—æ—¶: ${Date.now() - startTime}ms`);\r\n      console.log('========================================\\n');\r\n\r\n      return res.json({\r\n        success: false,\r\n        needsDialog: true,\r\n        message: 'å½“å‰ç›®å½•æ²¡æœ‰æ£€æµ‹åˆ°è¶³å¤Ÿçš„ä»£ç ã€‚è¯·é€šè¿‡å¯¹è¯æ–¹å¼æè¿°æ‚¨çš„é¡¹ç›®éœ€æ±‚ï¼ŒAI å°†å¸®æ‚¨ç”Ÿæˆè“å›¾ã€‚',\r\n        hint: 'æ‚¨å¯ä»¥å¼€å§‹ä¸€ä¸ªæ–°çš„éœ€æ±‚å¯¹è¯æ¥æè¿°æ‚¨æƒ³è¦æ„å»ºçš„ç³»ç»Ÿã€‚',\r\n      });\r\n    }\r\n\r\n    console.log('[Blueprint Generate]    âœ“ ä»£ç åº“æ»¡è¶³è¦æ±‚');\r\n\r\n    // Step 4: ç”Ÿæˆè“å›¾å’Œä»»åŠ¡æ ‘\r\n    console.log('[Blueprint Generate] ğŸ—ï¸  Step 4: ç”Ÿæˆè“å›¾å’Œä»»åŠ¡æ ‘...');\r\n    const generateStart = Date.now();\r\n    const result = await codebaseAnalyzer.analyzeAndGenerate({\r\n      rootDir: absoluteRoot,\r\n      projectName: codebaseInfo.name,\r\n      projectDescription: codebaseInfo.description,\r\n      granularity: 'medium',\r\n    });\r\n    console.log(`[Blueprint Generate]    âœ“ ç”Ÿæˆå®Œæˆï¼Œè€—æ—¶ ${Date.now() - generateStart}ms`);\r\n    console.log(`[Blueprint Generate]    - è“å›¾ ID: ${result.blueprint.id}`);\r\n    console.log(`[Blueprint Generate]    - è“å›¾åç§°: ${result.blueprint.name}`);\r\n    console.log(`[Blueprint Generate]    - æ¨¡å—æ•°: ${result.blueprint.modules.length}`);\r\n    console.log(`[Blueprint Generate]    - ä¸šåŠ¡æµç¨‹æ•°: ${result.blueprint.businessProcesses.length}`);\r\n    console.log(`[Blueprint Generate]    - NFR æ•°: ${result.blueprint.nfrs?.length || 0}`);\r\n    console.log(`[Blueprint Generate]    - ä»»åŠ¡æ ‘ ID: ${result.taskTree?.id || 'N/A'}`);\r\n\r\n    console.log('[Blueprint Generate] âœ… è“å›¾ç”ŸæˆæˆåŠŸï¼');\r\n    console.log(`[Blueprint Generate] æ€»è€—æ—¶: ${Date.now() - startTime}ms`);\r\n    console.log('========================================\\n');\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        id: result.blueprint.id,\r\n        name: result.blueprint.name,\r\n        description: result.blueprint.description,\r\n        status: result.blueprint.status,\r\n        createdAt: result.blueprint.createdAt,\r\n        updatedAt: result.blueprint.updatedAt,\r\n        moduleCount: result.blueprint.modules.length,\r\n        processCount: result.blueprint.businessProcesses.length,\r\n        nfrCount: result.blueprint.nfrs?.length || 0,\r\n        codebaseStats: {\r\n          totalFiles: codebaseInfo.stats.totalFiles,\r\n          totalLines: codebaseInfo.stats.totalLines,\r\n          filesByType: codebaseInfo.stats.filesByType,\r\n        },\r\n        taskTreeId: result.taskTree?.id,\r\n      },\r\n      message: `æˆåŠŸä»ä»£ç åº“ç”Ÿæˆè“å›¾ï¼æ£€æµ‹åˆ° ${codebaseInfo.modules.length} ä¸ªæ¨¡å—ï¼Œ${codebaseInfo.stats.totalFiles} ä¸ªæ–‡ä»¶ã€‚`,\r\n    });\r\n  } catch (error: any) {\r\n    console.error('\\n========================================');\r\n    console.error('[Blueprint Generate] âŒ ç”Ÿæˆè“å›¾å¤±è´¥ï¼');\r\n    console.error('========================================');\r\n    console.error(`[Blueprint Generate] é”™è¯¯ä¿¡æ¯: ${error.message}`);\r\n    console.error(`[Blueprint Generate] é”™è¯¯å †æ ˆ:\\n${error.stack}`);\r\n    console.error(`[Blueprint Generate] æ€»è€—æ—¶: ${Date.now() - startTime}ms`);\r\n    console.error('========================================\\n');\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n// ============================================================================\r\n// ä»»åŠ¡æ ‘ API\r\n// ============================================================================\r\n\r\n/**\r\n * è·å–ä»»åŠ¡æ ‘\r\n */\r\nrouter.get('/task-trees/:id', (req: Request, res: Response) => {\r\n  try {\r\n    const tree = taskTreeManager.getTaskTree(req.params.id);\r\n    if (!tree) {\r\n      return res.status(404).json({ success: false, error: 'Task tree not found' });\r\n    }\r\n    res.json({ success: true, data: tree });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * è·å–ä»»åŠ¡æ ‘ç»Ÿè®¡\r\n */\r\nrouter.get('/task-trees/:id/stats', (req: Request, res: Response) => {\r\n  try {\r\n    const tree = taskTreeManager.getTaskTree(req.params.id);\r\n    if (!tree) {\r\n      return res.status(404).json({ success: false, error: 'Task tree not found' });\r\n    }\r\n    res.json({ success: true, data: tree.stats });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * è·å–å¯æ‰§è¡Œä»»åŠ¡\r\n */\r\nrouter.get('/task-trees/:id/executable', (req: Request, res: Response) => {\r\n  try {\r\n    const tasks = taskTreeManager.getExecutableTasks(req.params.id);\r\n    res.json({\r\n      success: true,\r\n      data: tasks.map(t => ({\r\n        id: t.id,\r\n        name: t.name,\r\n        description: t.description,\r\n        priority: t.priority,\r\n        depth: t.depth,\r\n        dependencies: t.dependencies,\r\n      })),\r\n    });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * è·å–å¶å­ä»»åŠ¡\r\n */\r\nrouter.get('/task-trees/:id/leaves', (req: Request, res: Response) => {\r\n  try {\r\n    const tasks = taskTreeManager.getLeafTasks(req.params.id);\r\n    res.json({\r\n      success: true,\r\n      data: tasks.map(t => ({\r\n        id: t.id,\r\n        name: t.name,\r\n        status: t.status,\r\n        depth: t.depth,\r\n      })),\r\n    });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * æ›´æ–°ä»»åŠ¡çŠ¶æ€\r\n */\r\nrouter.patch('/task-trees/:treeId/tasks/:taskId/status', (req: Request, res: Response) => {\r\n  try {\r\n    const { status } = req.body;\r\n    const task = taskTreeManager.updateTaskStatus(req.params.treeId, req.params.taskId, status);\r\n    if (!task) {\r\n      return res.status(404).json({ success: false, error: 'Task not found' });\r\n    }\r\n    res.json({ success: true, data: task });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * åŠ¨æ€æ·»åŠ å­ä»»åŠ¡\r\n */\r\nrouter.post('/task-trees/:treeId/tasks/:parentId/subtasks', (req: Request, res: Response) => {\r\n  try {\r\n    const task = taskTreeManager.addSubTask(req.params.treeId, req.params.parentId, req.body);\r\n    res.json({ success: true, data: task });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n// ============================================================================\r\n// Agent åè°ƒ API\r\n// ============================================================================\r\n\r\n/**\r\n * åˆå§‹åŒ–èœ‚ç‹\r\n */\r\nrouter.post('/coordinator/queen', async (req: Request, res: Response) => {\r\n  try {\r\n    const { blueprintId } = req.body;\r\n    const queen = await agentCoordinator.initializeQueen(blueprintId);\r\n    res.json({ success: true, data: queen });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * è·å–èœ‚ç‹çŠ¶æ€\r\n */\r\nrouter.get('/coordinator/queen', (req: Request, res: Response) => {\r\n  try {\r\n    const queen = agentCoordinator.getQueen();\r\n    res.json({ success: true, data: queen });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * å¯åŠ¨ä¸»å¾ªç¯\r\n */\r\nrouter.post('/coordinator/start', (req: Request, res: Response) => {\r\n  try {\r\n    agentCoordinator.startMainLoop();\r\n    res.json({ success: true, message: 'ä¸»å¾ªç¯å·²å¯åŠ¨' });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * åœæ­¢ä¸»å¾ªç¯\r\n */\r\nrouter.post('/coordinator/stop', (req: Request, res: Response) => {\r\n  try {\r\n    agentCoordinator.stopMainLoop();\r\n    res.json({ success: true, message: 'ä¸»å¾ªç¯å·²åœæ­¢' });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * è·å–æ‰€æœ‰ Worker\r\n */\r\nrouter.get('/coordinator/workers', (req: Request, res: Response) => {\r\n  try {\r\n    const workers = agentCoordinator.getWorkers();\r\n    res.json({ success: true, data: workers });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * è·å–ä»ªè¡¨æ¿æ•°æ®\r\n */\r\nrouter.get('/coordinator/dashboard', (req: Request, res: Response) => {\r\n  try {\r\n    const data = agentCoordinator.getDashboardData();\r\n    res.json({ success: true, data });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * è·å–æ—¶é—´çº¿\r\n */\r\nrouter.get('/coordinator/timeline', (req: Request, res: Response) => {\r\n  try {\r\n    const timeline = agentCoordinator.getTimeline();\r\n    res.json({ success: true, data: timeline });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n// ============================================================================\r\n// TDD å¾ªç¯ API\r\n// ============================================================================\r\n\r\n/**\r\n * å¯åŠ¨ TDD å¾ªç¯\r\n */\r\nrouter.post('/tdd/start', (req: Request, res: Response) => {\r\n  try {\r\n    const { treeId, taskId } = req.body;\r\n    const state = tddExecutor.startLoop(treeId, taskId);\r\n    res.json({ success: true, data: state });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * è·å– TDD å¾ªç¯çŠ¶æ€\r\n */\r\nrouter.get('/tdd/:taskId', (req: Request, res: Response) => {\r\n  try {\r\n    if (!tddExecutor.isInLoop(req.params.taskId)) {\r\n      return res.status(404).json({ success: false, error: 'TDD loop not found' });\r\n    }\r\n    const state = tddExecutor.getLoopState(req.params.taskId);\r\n    res.json({ success: true, data: state });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * è·å–é˜¶æ®µæŒ‡å—\r\n */\r\nrouter.get('/tdd/:taskId/guidance', (req: Request, res: Response) => {\r\n  try {\r\n    const guidance = tddExecutor.getPhaseGuidance(req.params.taskId);\r\n    res.json({ success: true, data: guidance });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * è·å– TDD æŠ¥å‘Š\r\n */\r\nrouter.get('/tdd/:taskId/report', (req: Request, res: Response) => {\r\n  try {\r\n    const report = tddExecutor.generateReport(req.params.taskId);\r\n    res.json({ success: true, data: report });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * è·å–æ´»è·ƒçš„ TDD å¾ªç¯\r\n */\r\nrouter.get('/tdd', (req: Request, res: Response) => {\r\n  try {\r\n    const loops = tddExecutor.getActiveLoops();\r\n    res.json({ success: true, data: loops });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n// ============================================================================\r\n// æ—¶å…‰å€’æµ API\r\n// ============================================================================\r\n\r\n/**\r\n * è·å–æ‰€æœ‰æ£€æŸ¥ç‚¹\r\n */\r\nrouter.get('/time-travel/:treeId/checkpoints', (req: Request, res: Response) => {\r\n  try {\r\n    const checkpoints = timeTravelManager.getAllCheckpoints(req.params.treeId);\r\n    res.json({ success: true, data: checkpoints });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * è·å–æ—¶é—´çº¿è§†å›¾\r\n */\r\nrouter.get('/time-travel/:treeId/timeline', (req: Request, res: Response) => {\r\n  try {\r\n    const view = timeTravelManager.getTimelineView(req.params.treeId);\r\n    res.json({ success: true, data: view });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * åˆ›å»ºæ£€æŸ¥ç‚¹\r\n */\r\nrouter.post('/time-travel/:treeId/checkpoints', (req: Request, res: Response) => {\r\n  try {\r\n    const { name, description, taskId } = req.body;\r\n    const checkpoint = timeTravelManager.createManualCheckpoint(\r\n      req.params.treeId,\r\n      name,\r\n      description,\r\n      taskId\r\n    );\r\n    res.json({ success: true, data: checkpoint });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * å›æ»šåˆ°æ£€æŸ¥ç‚¹\r\n */\r\nrouter.post('/time-travel/:treeId/rollback/:checkpointId', (req: Request, res: Response) => {\r\n  try {\r\n    timeTravelManager.rollback(req.params.treeId, req.params.checkpointId);\r\n    res.json({ success: true, message: 'å›æ»šæˆåŠŸ' });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * é¢„è§ˆå›æ»šæ•ˆæœ\r\n */\r\nrouter.get('/time-travel/:treeId/preview/:checkpointId', (req: Request, res: Response) => {\r\n  try {\r\n    const preview = timeTravelManager.previewRollback(req.params.treeId, req.params.checkpointId);\r\n    res.json({ success: true, data: preview });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * è·å–æ£€æŸ¥ç‚¹è¯¦æƒ…\r\n */\r\nrouter.get('/time-travel/:treeId/checkpoints/:checkpointId', (req: Request, res: Response) => {\r\n  try {\r\n    const details = timeTravelManager.getCheckpointDetails(\r\n      req.params.treeId,\r\n      req.params.checkpointId\r\n    );\r\n    if (!details) {\r\n      return res.status(404).json({ success: false, error: 'Checkpoint not found' });\r\n    }\r\n    res.json({ success: true, data: details });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * åˆ›å»ºåˆ†æ”¯\r\n */\r\nrouter.post('/time-travel/:treeId/branches', (req: Request, res: Response) => {\r\n  try {\r\n    const { checkpointId, branchName } = req.body;\r\n    const branch = timeTravelManager.createBranch(req.params.treeId, checkpointId, branchName);\r\n    res.json({ success: true, data: branch });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * è·å– ASCII æ—¶é—´çº¿å›¾\r\n */\r\nrouter.get('/time-travel/:treeId/ascii', (req: Request, res: Response) => {\r\n  try {\r\n    const ascii = timeTravelManager.generateTimelineAscii(req.params.treeId);\r\n    res.json({ success: true, data: ascii });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * è·å–å½“å‰/æœ€æ–°çš„è“å›¾ï¼ˆä¾¿æ·æ¥å£ï¼‰\r\n */\r\nrouter.get('/blueprints/current', (req: Request, res: Response) => {\r\n  try {\r\n    const blueprints = blueprintManager.getAllBlueprints();\r\n    if (blueprints.length === 0) {\r\n      return res.status(404).json({ success: false, error: 'No blueprints found' });\r\n    }\r\n    // è¿”å›æœ€æ–°çš„è“å›¾\r\n    const latest = blueprints.sort((a, b) =>\r\n      new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime()\r\n    )[0];\r\n    res.json({ success: true, data: latest });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n// ============================================================================\r\n// éœ€æ±‚å¯¹è¯ API\r\n// ============================================================================\r\n\r\n/**\r\n * å¼€å§‹æ–°çš„éœ€æ±‚å¯¹è¯\r\n */\r\nrouter.post('/requirement-dialog/start', (req: Request, res: Response) => {\r\n  try {\r\n    const dialogState = requirementDialogManager.startDialog();\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        sessionId: dialogState.id,\r\n        phase: dialogState.phase,\r\n        history: dialogState.history,\r\n      },\r\n    });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * å‘é€æ¶ˆæ¯åˆ°éœ€æ±‚å¯¹è¯\r\n */\r\nrouter.post('/requirement-dialog/:sessionId/message', async (req: Request, res: Response) => {\r\n  try {\r\n    const { sessionId } = req.params;\r\n    const { message } = req.body;\r\n\r\n    if (!message || typeof message !== 'string') {\r\n      return res.status(400).json({ success: false, error: 'Message is required' });\r\n    }\r\n\r\n    const response = await requirementDialogManager.processUserInput(sessionId, message);\r\n    const state = requirementDialogManager.getDialogState(sessionId);\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        response,\r\n        phase: state?.phase,\r\n        isComplete: state?.phase === 'complete',\r\n      },\r\n    });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * è·å–å¯¹è¯çŠ¶æ€\r\n */\r\nrouter.get('/requirement-dialog/:sessionId', (req: Request, res: Response) => {\r\n  try {\r\n    const { sessionId } = req.params;\r\n    const state = requirementDialogManager.getDialogState(sessionId);\r\n\r\n    if (!state) {\r\n      return res.status(404).json({ success: false, error: 'Dialog session not found' });\r\n    }\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        sessionId: state.id,\r\n        phase: state.phase,\r\n        projectName: state.projectName,\r\n        projectDescription: state.projectDescription,\r\n        businessProcesses: state.businessProcesses,\r\n        modules: state.modules,\r\n        nfrs: state.nfrs,\r\n        history: state.history,\r\n      },\r\n    });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * ç»“æŸå¯¹è¯\r\n */\r\nrouter.delete('/requirement-dialog/:sessionId', (req: Request, res: Response) => {\r\n  try {\r\n    const { sessionId } = req.params;\r\n    requirementDialogManager.endDialog(sessionId);\r\n    res.json({ success: true, message: 'Dialog ended' });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n// ============================================================================\r\n// æ—¶å…‰å€’æµ API\r\n// ============================================================================\r\n\r\n/**\r\n * è·å–æ—¶é—´çº¿è§†å›¾\r\n */\r\nrouter.get('/time-travel/:treeId/timeline', (req: Request, res: Response) => {\r\n  try {\r\n    const { treeId } = req.params;\r\n    const timeline = timeTravelManager.getTimelineView(treeId);\r\n    res.json({ success: true, data: timeline });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * è·å–æ£€æŸ¥ç‚¹è¯¦æƒ…\r\n */\r\nrouter.get('/time-travel/:treeId/checkpoints/:checkpointId', (req: Request, res: Response) => {\r\n  try {\r\n    const { treeId, checkpointId } = req.params;\r\n    const detail = timeTravelManager.getCheckpointDetails(treeId, checkpointId);\r\n\r\n    if (!detail) {\r\n      return res.status(404).json({ success: false, error: 'Checkpoint not found' });\r\n    }\r\n\r\n    // æ·»åŠ ä»»åŠ¡çŠ¶æ€å¿«ç…§\r\n    const tree = taskTreeManager.getTaskTree(treeId);\r\n    let taskSnapshot: any[] = [];\r\n    if (tree) {\r\n      const collectTasks = (node: any) => {\r\n        taskSnapshot.push({\r\n          id: node.id,\r\n          name: node.name,\r\n          status: node.status,\r\n        });\r\n        for (const child of node.children || []) {\r\n          collectTasks(child);\r\n        }\r\n      };\r\n      collectTasks(tree.root);\r\n    }\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        ...detail,\r\n        taskSnapshot: taskSnapshot.slice(0, 20), // é™åˆ¶æ•°é‡\r\n      },\r\n    });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * åˆ›å»ºæ£€æŸ¥ç‚¹\r\n */\r\nrouter.post('/time-travel/:treeId/checkpoints', (req: Request, res: Response) => {\r\n  try {\r\n    const { treeId } = req.params;\r\n    const { name, description, isGlobal, taskId } = req.body;\r\n\r\n    const checkpoint = timeTravelManager.createManualCheckpoint(\r\n      treeId,\r\n      name,\r\n      description,\r\n      isGlobal ? undefined : taskId\r\n    );\r\n\r\n    res.json({ success: true, data: checkpoint });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * å›æ»šåˆ°æ£€æŸ¥ç‚¹\r\n */\r\nrouter.post('/time-travel/:treeId/rollback', (req: Request, res: Response) => {\r\n  try {\r\n    const { treeId } = req.params;\r\n    const { checkpointId } = req.body;\r\n\r\n    timeTravelManager.rollback(treeId, checkpointId);\r\n\r\n    res.json({ success: true, message: 'Rollback successful' });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * åˆ›å»ºåˆ†æ”¯\r\n */\r\nrouter.post('/time-travel/:treeId/branches', (req: Request, res: Response) => {\r\n  try {\r\n    const { treeId } = req.params;\r\n    const { checkpointId, branchName } = req.body;\r\n\r\n    const branch = timeTravelManager.createBranch(treeId, checkpointId, branchName);\r\n\r\n    res.json({ success: true, data: branch });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * å¯¹æ¯”ä¸¤ä¸ªæ£€æŸ¥ç‚¹\r\n */\r\nrouter.get('/time-travel/:treeId/compare', (req: Request, res: Response) => {\r\n  try {\r\n    const { treeId } = req.params;\r\n    const { from, to } = req.query;\r\n\r\n    if (!from || !to) {\r\n      return res.status(400).json({ success: false, error: 'Missing from or to parameter' });\r\n    }\r\n\r\n    const result = timeTravelManager.compare(treeId, from as string, to as string);\r\n\r\n    res.json({ success: true, data: result });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n// ============================================================================\r\n// è“å›¾ç¼–è¾‘ APIï¼ˆå¯¹è¯å¼ä¿®æ”¹ï¼‰\r\n// ============================================================================\r\n\r\n/**\r\n * å¯¹è¯å¼ä¿®æ”¹è“å›¾\r\n * ç”¨æˆ·å¯ä»¥ç”¨è‡ªç„¶è¯­è¨€æè¿°ä¿®æ”¹éœ€æ±‚\r\n */\r\nrouter.post('/blueprints/:id/chat-edit', async (req: Request, res: Response) => {\r\n  try {\r\n    const { id } = req.params;\r\n    const { message } = req.body;\r\n\r\n    const blueprint = blueprintManager.getBlueprint(id);\r\n    if (!blueprint) {\r\n      return res.status(404).json({ success: false, error: 'Blueprint not found' });\r\n    }\r\n\r\n    // ä½¿ç”¨ AI è§£æä¿®æ”¹è¯·æ±‚å¹¶åº”ç”¨\r\n    const { getDefaultClient } = await import('../../../core/client.js');\r\n    const client = getDefaultClient();\r\n\r\n    const response = await client.createMessage(\r\n      [{\r\n        role: 'user',\r\n        content: `ç”¨æˆ·æƒ³è¦ä¿®æ”¹ä»¥ä¸‹è“å›¾ï¼š\r\n\r\nè“å›¾åç§°ï¼š${blueprint.name}\r\nè“å›¾æè¿°ï¼š${blueprint.description}\r\nç³»ç»Ÿæ¨¡å—ï¼š${blueprint.modules.map(m => m.name).join('ã€')}\r\nä¸šåŠ¡æµç¨‹ï¼š${blueprint.businessProcesses.map(p => p.name).join('ã€')}\r\néåŠŸèƒ½è¦æ±‚ï¼š${blueprint.nfrs.map(n => n.name).join('ã€')}\r\n\r\nç”¨æˆ·çš„ä¿®æ”¹è¯·æ±‚ï¼š${message}\r\n\r\nè¯·åˆ†æç”¨æˆ·çš„è¯·æ±‚ï¼Œè¿”å› JSON æ ¼å¼çš„ä¿®æ”¹æŒ‡ä»¤ï¼š\r\n{\r\n  \"action\": \"add_module\" | \"remove_module\" | \"update_module\" | \"add_process\" | \"remove_process\" | \"update_process\" | \"add_nfr\" | \"remove_nfr\" | \"update_description\",\r\n  \"target\": \"ç›®æ ‡é¡¹åç§°ï¼ˆå¦‚æœæœ‰ï¼‰\",\r\n  \"data\": { ... æ–°æ•°æ® ... },\r\n  \"explanation\": \"ä¿®æ”¹è¯´æ˜\"\r\n}`,\r\n      }],\r\n      undefined,\r\n      'ä½ æ˜¯ä¸€ä¸ªè“å›¾ç¼–è¾‘åŠ©æ‰‹ã€‚åˆ†æç”¨æˆ·çš„ä¿®æ”¹è¯·æ±‚ï¼Œè¿”å› JSON æ ¼å¼çš„ä¿®æ”¹æŒ‡ä»¤ã€‚'\r\n    );\r\n\r\n    let text = '';\r\n    for (const block of response.content) {\r\n      if (block.type === 'text') {\r\n        text += block.text;\r\n      }\r\n    }\r\n\r\n    // è§£æ JSON\r\n    const jsonMatch = text.match(/\\{[\\s\\S]*\\}/);\r\n    if (!jsonMatch) {\r\n      return res.json({\r\n        success: true,\r\n        data: {\r\n          modified: false,\r\n          explanation: 'æ— æ³•è§£æä¿®æ”¹è¯·æ±‚ï¼Œè¯·å°è¯•æ›´æ˜ç¡®åœ°æè¿°ä½ æƒ³è¦çš„ä¿®æ”¹ã€‚',\r\n        },\r\n      });\r\n    }\r\n\r\n    const instruction = JSON.parse(jsonMatch[0]);\r\n\r\n    // åº”ç”¨ä¿®æ”¹\r\n    let modified = false;\r\n    switch (instruction.action) {\r\n      case 'add_module':\r\n        if (instruction.data) {\r\n          blueprintManager.addModule(id, instruction.data);\r\n          modified = true;\r\n        }\r\n        break;\r\n      case 'add_process':\r\n        if (instruction.data) {\r\n          blueprintManager.addBusinessProcess(id, instruction.data);\r\n          modified = true;\r\n        }\r\n        break;\r\n      case 'add_nfr':\r\n        if (instruction.data) {\r\n          blueprintManager.addNFR(id, instruction.data);\r\n          modified = true;\r\n        }\r\n        break;\r\n      case 'update_description':\r\n        if (instruction.data?.description) {\r\n          const current = blueprintManager.getBlueprint(id);\r\n          if (current) {\r\n            blueprintManager.modifyDuringExecution(id, { description: instruction.data.description });\r\n            modified = true;\r\n          }\r\n        }\r\n        break;\r\n      // å¯ä»¥æ·»åŠ æ›´å¤šæ“ä½œç±»å‹\r\n    }\r\n\r\n    const updatedBlueprint = blueprintManager.getBlueprint(id);\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        modified,\r\n        explanation: instruction.explanation,\r\n        blueprint: updatedBlueprint,\r\n      },\r\n    });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n// ============================================================================\r\n// ç¼“å­˜ç®¡ç† API\r\n// ============================================================================\r\n\r\n/**\r\n * è·å–ç¼“å­˜ç»Ÿè®¡\r\n */\r\nrouter.get('/cache/stats', (req: Request, res: Response) => {\r\n  try {\r\n    const stats = analysisCache.getStats();\r\n    res.json({ success: true, data: stats });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * æ¸…é™¤æ‰€æœ‰ç¼“å­˜\r\n */\r\nrouter.delete('/cache', (req: Request, res: Response) => {\r\n  try {\r\n    const count = analysisCache.clear();\r\n    res.json({ success: true, message: `å·²æ¸…é™¤ ${count} ä¸ªç¼“å­˜æ–‡ä»¶` });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * æ¸…é™¤è¿‡æœŸç¼“å­˜\r\n */\r\nrouter.delete('/cache/expired', (req: Request, res: Response) => {\r\n  try {\r\n    const count = analysisCache.cleanExpired();\r\n    res.json({ success: true, message: `å·²æ¸…é™¤ ${count} ä¸ªè¿‡æœŸç¼“å­˜` });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * æ¸…é™¤æŒ‡å®šè·¯å¾„çš„ç¼“å­˜\r\n */\r\nrouter.delete('/cache/path', (req: Request, res: Response) => {\r\n  try {\r\n    const { path: targetPath } = req.body;\r\n    if (!targetPath) {\r\n      return res.status(400).json({ success: false, error: 'ç¼ºå°‘è·¯å¾„å‚æ•°' });\r\n    }\r\n\r\n    const absolutePath = path.resolve(process.cwd(), targetPath);\r\n    const success = analysisCache.delete(absolutePath);\r\n\r\n    if (success) {\r\n      res.json({ success: true, message: 'ç¼“å­˜å·²æ¸…é™¤' });\r\n    } else {\r\n      res.json({ success: false, message: 'æœªæ‰¾åˆ°ç¼“å­˜' });\r\n    }\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * é‡ç½®ç¼“å­˜ç»Ÿè®¡\r\n */\r\nrouter.post('/cache/reset-stats', (req: Request, res: Response) => {\r\n  try {\r\n    analysisCache.resetStats();\r\n    res.json({ success: true, message: 'ç»Ÿè®¡å·²é‡ç½®' });\r\n  } catch (error: any) {\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n// ============================================================================\r\n// è°ƒç”¨å›¾ API (LSP + AIæ··åˆ)\r\n// ============================================================================\r\n\r\n// ç¼“å­˜\r\nconst callGraphCache = new Map<string, { data: any; timestamp: number }>();\r\nconst CACHE_TTL = 5 * 60 * 1000; // 5åˆ†é’Ÿ\r\n\r\n// å…¨å±€ LSP åˆ†æå™¨ï¼ˆå»¶è¿Ÿåˆå§‹åŒ–ï¼‰\r\nlet lspAnalyzer: any = null;\r\nlet aiAnalyzer: any = null;\r\n\r\n/**\r\n * è·å–æ–‡ä»¶/ç¬¦å·çš„è°ƒç”¨å›¾ (LSP + AIæ··åˆåˆ†æ)\r\n * å‚æ•°:\r\n *   - path: æ–‡ä»¶è·¯å¾„ (å¯é€‰)\r\n *   - symbol: ç¬¦å·åç§° (å¯é€‰, ä¾‹å¦‚å‡½æ•°åæˆ–ç±»å.æ–¹æ³•å)\r\n *   - depth: åˆ†ææ·±åº¦ (é»˜è®¤: 2)\r\n *   - useAI: æ˜¯å¦ä½¿ç”¨AIå¢å¼ºåˆ†æ (é»˜è®¤: true)\r\n *   - detectCycles: æ˜¯å¦æ£€æµ‹å¾ªç¯ä¾èµ– (é»˜è®¤: false)\r\n *\r\n * å¦‚æœä¸æä¾›å‚æ•°,è¿”å›æ•´ä¸ªé¡¹ç›®çš„è°ƒç”¨å›¾\r\n */\r\nrouter.get('/call-graph', async (req: Request, res: Response) => {\r\n  try {\r\n    const {\r\n      path: filePath,\r\n      symbol,\r\n      depth = '2',\r\n      useAI = 'true',\r\n      detectCycles = 'false'\r\n    } = req.query;\r\n    const maxDepth = parseInt(depth as string) || 2;\r\n    const enableAI = useAI === 'true';\r\n    const enableCycleDetection = detectCycles === 'true';\r\n\r\n    console.log('[Call Graph API] è¯·æ±‚å‚æ•°:', { filePath, symbol, maxDepth, enableAI, enableCycleDetection });\r\n\r\n    // æ£€æŸ¥ç¼“å­˜\r\n    const cacheKey = JSON.stringify({ filePath, symbol, maxDepth, enableAI });\r\n    const cached = callGraphCache.get(cacheKey);\r\n    if (cached && Date.now() - cached.timestamp < CACHE_TTL) {\r\n      console.log('[Call Graph API] ä½¿ç”¨ç¼“å­˜');\r\n      return res.json({\r\n        success: true,\r\n        ...cached.data,\r\n        cached: true,\r\n      });\r\n    }\r\n\r\n    const projectRoot = process.cwd();\r\n    console.log('[Call Graph API] é¡¹ç›®æ ¹ç›®å½•:', projectRoot);\r\n\r\n    // 1. æ‰«æTypeScriptæ–‡ä»¶\r\n    const tsFiles: string[] = [];\r\n    const srcPath = path.join(projectRoot, 'src');\r\n\r\n    const scanDir = (dir: string) => {\r\n      if (!fs.existsSync(dir)) return;\r\n      const entries = fs.readdirSync(dir, { withFileTypes: true });\r\n\r\n      for (const entry of entries) {\r\n        const fullPath = path.join(dir, entry.name);\r\n        if (entry.isDirectory()) {\r\n          if (['node_modules', 'dist', '.git', '.lh'].includes(entry.name)) continue;\r\n          scanDir(fullPath);\r\n        } else if (entry.isFile()) {\r\n          const ext = path.extname(entry.name);\r\n          if (['.ts', '.tsx'].includes(ext)) {\r\n            tsFiles.push(fullPath);\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    scanDir(srcPath);\r\n    console.log(`[Call Graph API] æ‰«æåˆ° ${tsFiles.length} ä¸ªTypeScriptæ–‡ä»¶`);\r\n\r\n    if (tsFiles.length === 0) {\r\n      return res.json({\r\n        success: true,\r\n        data: { nodes: [], edges: [] },\r\n        message: 'æœªæ‰¾åˆ°TypeScriptæ–‡ä»¶',\r\n      });\r\n    }\r\n\r\n    // 2. åˆå§‹åŒ–LSPåˆ†æå™¨ï¼ˆå»¶è¿ŸåŠ è½½ï¼‰\r\n    if (!lspAnalyzer) {\r\n      const { TypeScriptLSPAnalyzer } = await import('./lsp-analyzer.js');\r\n      lspAnalyzer = new TypeScriptLSPAnalyzer();\r\n      lspAnalyzer.initProgram(tsFiles, projectRoot);\r\n      console.log('[Call Graph API] LSPåˆ†æå™¨å·²åˆå§‹åŒ–');\r\n    }\r\n\r\n    // 3. ä½¿ç”¨LSPæå–ç¬¦å·ï¼ˆåªåˆ†æå¿…è¦çš„æ–‡ä»¶ï¼‰\r\n    const allNodes: CallGraphNode[] = [];\r\n    const allEdges: CallGraphEdge[] = [];\r\n    const symbolMap = new Map<string, CallGraphNode>();\r\n\r\n    // ç¡®å®šéœ€è¦åˆ†æçš„æ–‡ä»¶\r\n    let filesToAnalyze = tsFiles;\r\n    if (filePath) {\r\n      // è§„èŒƒåŒ–è·¯å¾„ï¼šå°†ç›¸å¯¹è·¯å¾„è½¬ä¸ºç»å¯¹è·¯å¾„ï¼Œç»Ÿä¸€ä½¿ç”¨æ­£æ–œæ \r\n      const normalizedFilePath = path.normalize(path.join(projectRoot, filePath as string));\r\n      console.log(`[Call Graph API] æŸ¥æ‰¾æ–‡ä»¶: ${normalizedFilePath}`);\r\n\r\n      // åªåˆ†ææŒ‡å®šæ–‡ä»¶åŠå…¶ä¾èµ–\r\n      filesToAnalyze = tsFiles.filter(f => {\r\n        const normalized = path.normalize(f);\r\n        return normalized === normalizedFilePath || normalized.includes(path.basename(normalizedFilePath));\r\n      });\r\n\r\n      // å¦‚æœç²¾ç¡®åŒ¹é…å¤±è´¥ï¼Œå°è¯•æ¨¡ç³ŠåŒ¹é…\r\n      if (filesToAnalyze.length === 0) {\r\n        const fileName = path.basename(filePath as string);\r\n        filesToAnalyze = tsFiles.filter(f => f.includes(fileName));\r\n      }\r\n\r\n      // é™åˆ¶æ•°é‡\r\n      filesToAnalyze = filesToAnalyze.slice(0, 10);\r\n    } else {\r\n      // é™åˆ¶æ–‡ä»¶æ•°é‡ï¼ˆé¿å…å¤ªæ…¢ï¼‰\r\n      filesToAnalyze = tsFiles.slice(0, 50);\r\n    }\r\n\r\n    console.log(`[Call Graph API] å°†åˆ†æ ${filesToAnalyze.length} ä¸ªæ–‡ä»¶`);\r\n\r\n    for (const file of filesToAnalyze) {\r\n      try {\r\n        const { functions, classes, interfaces, types } = lspAnalyzer.analyzeFile(file);\r\n        const relativePath = path.relative(projectRoot, file);\r\n\r\n        console.log(`[Call Graph API] åˆ†ææ–‡ä»¶: ${relativePath}, å‡½æ•°: ${functions.length}, ç±»: ${classes.length}, æ¥å£: ${interfaces.length}, ç±»å‹: ${types.length}`);\r\n\r\n        // æ·»åŠ å‡½æ•°èŠ‚ç‚¹\r\n        for (const func of functions) {\r\n          const node: CallGraphNode = {\r\n            id: func.id,\r\n            name: func.name,\r\n            type: 'function',\r\n            moduleId: relativePath,\r\n            signature: func.signature,\r\n          };\r\n          allNodes.push(node);\r\n          symbolMap.set(func.name, node);\r\n          symbolMap.set(func.id, node);\r\n        }\r\n\r\n        // æ·»åŠ ç±»èŠ‚ç‚¹\r\n        for (const cls of classes) {\r\n          // æ·»åŠ ç±»æœ¬èº«ä½œä¸ºèŠ‚ç‚¹\r\n          const clsNode: CallGraphNode = {\r\n            id: cls.id,\r\n            name: cls.name,\r\n            type: cls.isAbstract ? 'function' : 'method', // æŠ½è±¡ç±»æ˜¾ç¤ºä¸º function ç±»å‹\r\n            moduleId: relativePath,\r\n            signature: `${cls.isExported ? 'export ' : ''}${cls.isAbstract ? 'abstract ' : ''}class ${cls.name}`,\r\n          };\r\n          allNodes.push(clsNode);\r\n          symbolMap.set(cls.name, clsNode);\r\n          symbolMap.set(cls.id, clsNode);\r\n\r\n          // æ·»åŠ ç±»æ–¹æ³•èŠ‚ç‚¹\r\n          for (const method of cls.methods) {\r\n            const node: CallGraphNode = {\r\n              id: method.id,\r\n              name: method.name,\r\n              type: method.name === 'constructor' ? 'constructor' : 'method',\r\n              moduleId: relativePath,\r\n              className: cls.name,\r\n              signature: method.signature,\r\n            };\r\n            allNodes.push(node);\r\n            symbolMap.set(method.name, node);\r\n            symbolMap.set(`${cls.name}.${method.name}`, node);\r\n            symbolMap.set(method.id, node);\r\n          }\r\n        }\r\n\r\n        // æ·»åŠ æ¥å£èŠ‚ç‚¹\r\n        for (const iface of interfaces) {\r\n          // æ·»åŠ æ¥å£æœ¬èº«ä½œä¸ºèŠ‚ç‚¹\r\n          const ifaceNode: CallGraphNode = {\r\n            id: iface.id,\r\n            name: iface.name,\r\n            type: 'function', // æ¥å£æ˜¾ç¤ºä¸º function ç±»å‹\r\n            moduleId: relativePath,\r\n            signature: `${iface.isExported ? 'export ' : ''}interface ${iface.name}`,\r\n          };\r\n          allNodes.push(ifaceNode);\r\n          symbolMap.set(iface.name, ifaceNode);\r\n          symbolMap.set(iface.id, ifaceNode);\r\n\r\n          // æ·»åŠ æ¥å£æ–¹æ³•ç­¾å\r\n          for (const method of iface.methods) {\r\n            const node: CallGraphNode = {\r\n              id: `${iface.id}::${method.name}`,\r\n              name: method.name,\r\n              type: 'method',\r\n              moduleId: relativePath,\r\n              className: iface.name,\r\n              signature: method.signature,\r\n            };\r\n            allNodes.push(node);\r\n            symbolMap.set(`${iface.name}.${method.name}`, node);\r\n            symbolMap.set(node.id, node);\r\n          }\r\n        }\r\n\r\n        // æ·»åŠ ç±»å‹åˆ«åèŠ‚ç‚¹\r\n        for (const type of types) {\r\n          const typeNode: CallGraphNode = {\r\n            id: type.id,\r\n            name: type.name,\r\n            type: 'function', // ç±»å‹åˆ«åæ˜¾ç¤ºä¸º function ç±»å‹\r\n            moduleId: relativePath,\r\n            signature: `${type.isExported ? 'export ' : ''}type ${type.name} = ${type.definition.substring(0, 50)}...`,\r\n          };\r\n          allNodes.push(typeNode);\r\n          symbolMap.set(type.name, typeNode);\r\n          symbolMap.set(type.id, typeNode);\r\n        }\r\n      } catch (error) {\r\n        console.error(`[Call Graph API] åˆ†ææ–‡ä»¶å¤±è´¥: ${file}`, error);\r\n      }\r\n    }\r\n\r\n    console.log(`[Call Graph API] LSPæå–åˆ° ${allNodes.length} ä¸ªç¬¦å·`);\r\n\r\n    // 4. å¦‚æœå¯ç”¨AIï¼Œä½¿ç”¨Claudeåˆ†æè°ƒç”¨å…³ç³»\r\n    if (enableAI && allNodes.length > 0 && allNodes.length < 200) {\r\n      try {\r\n        if (!aiAnalyzer) {\r\n          const apiKey = process.env.ANTHROPIC_API_KEY || process.env.CLAUDE_API_KEY;\r\n          if (apiKey) {\r\n            const { AICallGraphAnalyzer } = await import('./lsp-analyzer.js');\r\n            aiAnalyzer = new AICallGraphAnalyzer(apiKey);\r\n            console.log('[Call Graph API] AIåˆ†æå™¨å·²åˆå§‹åŒ–');\r\n          }\r\n        }\r\n\r\n        if (aiAnalyzer) {\r\n          // åªåˆ†æé‡ç‚¹æ–‡ä»¶\r\n          const targetFile = filePath\r\n            ? filesToAnalyze.find(f => f.includes(filePath as string))\r\n            : filesToAnalyze[0];\r\n\r\n          if (targetFile && fs.existsSync(targetFile)) {\r\n            const content = fs.readFileSync(targetFile, 'utf-8');\r\n            const allSymbols = {\r\n              functions: [],\r\n              classes: []\r\n            };\r\n\r\n            console.log('[Call Graph API] ä½¿ç”¨AIåˆ†æè°ƒç”¨å…³ç³»...');\r\n            const aiResult = await aiAnalyzer.analyzeCallRelationships(\r\n              content,\r\n              targetFile,\r\n              allSymbols\r\n            );\r\n\r\n            // å°†AIç»“æœè½¬æ¢ä¸ºè¾¹\r\n            for (const call of aiResult.calls || []) {\r\n              const sourceNode = symbolMap.get(call.from);\r\n              const targetNode = symbolMap.get(call.to);\r\n\r\n              if (sourceNode && targetNode) {\r\n                allEdges.push({\r\n                  source: sourceNode.id,\r\n                  target: targetNode.id,\r\n                  type: call.type || 'direct',\r\n                  count: 1,\r\n                  locations: [],\r\n                });\r\n              }\r\n            }\r\n\r\n            console.log(`[Call Graph API] AIåˆ†æå¾—åˆ° ${allEdges.length} æ¡è°ƒç”¨å…³ç³»`);\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.error('[Call Graph API] AIåˆ†æå¤±è´¥:', error);\r\n        // ç»§ç»­ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼åˆ†æ\r\n      }\r\n    }\r\n\r\n    // 5. å¦‚æœæ²¡æœ‰AIç»“æœï¼Œå›é€€åˆ°æ­£åˆ™è¡¨è¾¾å¼åˆ†æ\r\n    if (allEdges.length === 0) {\r\n      console.log('[Call Graph API] ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼åˆ†æè°ƒç”¨å…³ç³»...');\r\n      // ç®€å•çš„æ­£åˆ™åˆ†æ\r\n      for (const file of filesToAnalyze.slice(0, 20)) {\r\n        try {\r\n          const content = fs.readFileSync(file, 'utf-8');\r\n          const lines = content.split('\\n');\r\n\r\n          for (let i = 0; i < lines.length; i++) {\r\n            const line = lines[i];\r\n            // åŒ¹é…å‡½æ•°è°ƒç”¨: xxx(...)\r\n            const callPattern = /\\b([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*\\(/g;\r\n            let match;\r\n\r\n            while ((match = callPattern.exec(line)) !== null) {\r\n              const calledName = match[1];\r\n              const targetNode = symbolMap.get(calledName);\r\n\r\n              if (targetNode) {\r\n                // æ‰¾åˆ°è°ƒç”¨è€…ï¼ˆå½“å‰è¡Œæ‰€åœ¨çš„å‡½æ•°ï¼‰\r\n                for (const node of allNodes) {\r\n                  if (node.moduleId === path.relative(projectRoot, file)) {\r\n                    allEdges.push({\r\n                      source: node.id,\r\n                      target: targetNode.id,\r\n                      type: 'direct',\r\n                      count: 1,\r\n                      locations: [],\r\n                    });\r\n                    break;\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        } catch (error) {\r\n          // å¿½ç•¥é”™è¯¯\r\n        }\r\n      }\r\n\r\n      console.log(`[Call Graph API] æ­£åˆ™åˆ†æå¾—åˆ° ${allEdges.length} æ¡è°ƒç”¨å…³ç³»`);\r\n    }\r\n\r\n    let callGraph = { nodes: allNodes, edges: allEdges };\r\n\r\n    // 5. å¦‚æœæŒ‡å®šäº†æ–‡ä»¶æˆ–ç¬¦å·ï¼Œè¿‡æ»¤è°ƒç”¨å›¾\r\n    let filteredNodes = callGraph.nodes;\r\n    let filteredEdges = callGraph.edges;\r\n    const originalTargetNodes = new Set<string>(); // åŸå§‹ç›®æ ‡èŠ‚ç‚¹ï¼ˆç”¨æˆ·é€‰ä¸­çš„ç¬¦å·ï¼‰\r\n    const targetNodes = new Set<string>(); // æ‰©å±•åçš„èŠ‚ç‚¹é›†åˆ\r\n\r\n    if (filePath || symbol) {\r\n\r\n      // å¦‚æœæŒ‡å®šäº†ç¬¦å·ï¼Œå…ˆæ£€æŸ¥å®ƒæ˜¯å¦ä¸ºé™æ€ç¬¦å·ï¼ˆä¸æ”¯æŒè°ƒç”¨å›¾ï¼‰\r\n      if (symbol) {\r\n        const symbolName = symbol as string;\r\n\r\n        // ä» symbolMap ä¸­æŸ¥æ‰¾ç¬¦å·\r\n        const symbolNode = symbolMap.get(symbolName);\r\n\r\n        if (symbolNode && (symbolNode as any).isStatic) {\r\n          // è¿™æ˜¯ä¸€ä¸ªé™æ€ç¬¦å·ï¼ˆinterface/type/propertyï¼‰ï¼Œä¸æ”¯æŒè°ƒç”¨å›¾\r\n          const signature = symbolNode.signature || symbolName;\r\n          const kind = signature.includes('interface') ? 'interface' :\r\n                       signature.includes('type') ? 'type' : 'static symbol';\r\n\r\n          console.log(`[Call Graph API] ç¬¦å· \"${symbolName}\" æ˜¯é™æ€ç¬¦å· (${kind})ï¼Œä¸æ”¯æŒè°ƒç”¨å›¾`);\r\n\r\n          return res.json({\r\n            success: false,\r\n            error: `ç¬¦å· \"${symbolName}\" æ˜¯ ${kind}ï¼Œä¸æ”¯æŒè°ƒç”¨å›¾åˆ†æ`,\r\n            suggestion: 'references',\r\n            hint: `${kind} æ˜¯ç±»å‹å®šä¹‰ï¼Œå»ºè®®ä½¿ç”¨\"å¼•ç”¨æŸ¥æ‰¾\"è§†å›¾æŸ¥çœ‹å®ƒåœ¨å“ªäº›åœ°æ–¹è¢«ä½¿ç”¨`,\r\n            data: {\r\n              symbol: symbolName,\r\n              type: kind,\r\n              supportedViews: ['definition', 'references', 'type-hierarchy'],\r\n            },\r\n          });\r\n        }\r\n      }\r\n\r\n      // æŸ¥æ‰¾ç›®æ ‡èŠ‚ç‚¹\r\n      for (const node of callGraph.nodes) {\r\n        let matched = false;\r\n\r\n        if (filePath) {\r\n          // è§„èŒƒåŒ–è·¯å¾„æ¯”è¾ƒï¼ˆç»Ÿä¸€ä½¿ç”¨æ­£æ–œæ ï¼‰\r\n          const normalizedModuleId = node.moduleId.replace(/\\\\/g, '/');\r\n          const normalizedFilePath = (filePath as string).replace(/\\\\/g, '/');\r\n          if (normalizedModuleId.includes(normalizedFilePath) ||\r\n              normalizedFilePath.includes(normalizedModuleId)) {\r\n            matched = true;\r\n          }\r\n        }\r\n\r\n        if (symbol) {\r\n          const symbolName = symbol as string;\r\n          if (node.name === symbolName ||\r\n              node.name.includes(symbolName) ||\r\n              (node.className && `${node.className}.${node.name}` === symbolName)) {\r\n            matched = true;\r\n          }\r\n        }\r\n\r\n        if (matched) {\r\n          originalTargetNodes.add(node.id); // ä¿å­˜åŸå§‹ç›®æ ‡\r\n          targetNodes.add(node.id);\r\n          console.log(`[Call Graph API] åŒ¹é…åˆ°ç›®æ ‡èŠ‚ç‚¹: ${node.name} (${node.id})`);\r\n        }\r\n      }\r\n\r\n      console.log(`[Call Graph API] æ‰¾åˆ° ${originalTargetNodes.size} ä¸ªåŸå§‹ç›®æ ‡èŠ‚ç‚¹`);\r\n\r\n      // æ‰©å±•åˆ°ç›¸å…³èŠ‚ç‚¹ï¼ˆåŸºäºdepthï¼‰\r\n      const expandNodes = (nodeIds: Set<string>, currentDepth: number) => {\r\n        if (currentDepth >= maxDepth) return;\r\n\r\n        const newNodes = new Set<string>();\r\n        for (const edge of callGraph.edges) {\r\n          if (nodeIds.has(edge.source)) {\r\n            newNodes.add(edge.target);\r\n          }\r\n          if (nodeIds.has(edge.target)) {\r\n            newNodes.add(edge.source);\r\n          }\r\n        }\r\n\r\n        newNodes.forEach(id => targetNodes.add(id));\r\n        if (newNodes.size > 0) {\r\n          expandNodes(newNodes, currentDepth + 1);\r\n        }\r\n      };\r\n\r\n      expandNodes(targetNodes, 0);\r\n\r\n      // è¿‡æ»¤èŠ‚ç‚¹å’Œè¾¹\r\n      filteredNodes = callGraph.nodes.filter(n => targetNodes.has(n.id));\r\n      filteredEdges = callGraph.edges.filter(e =>\r\n        targetNodes.has(e.source) && targetNodes.has(e.target)\r\n      );\r\n\r\n      console.log(`[Call Graph API] è¿‡æ»¤åèŠ‚ç‚¹æ•°: ${filteredNodes.length}, è¾¹æ•°: ${filteredEdges.length}`);\r\n    }\r\n\r\n    // 6. é™åˆ¶è¿”å›çš„èŠ‚ç‚¹æ•°é‡ï¼ˆé¿å…å›¾å¤ªå¤§ï¼‰\r\n    const MAX_NODES = 100;\r\n    if (filteredNodes.length > MAX_NODES) {\r\n      // æŒ‰ç…§è°ƒç”¨æ¬¡æ•°æ’åºï¼Œä¿ç•™æœ€é‡è¦çš„èŠ‚ç‚¹\r\n      const nodeDegree = new Map<string, number>();\r\n      for (const node of filteredNodes) {\r\n        nodeDegree.set(node.id, 0);\r\n      }\r\n      for (const edge of filteredEdges) {\r\n        nodeDegree.set(edge.source, (nodeDegree.get(edge.source) || 0) + 1);\r\n        nodeDegree.set(edge.target, (nodeDegree.get(edge.target) || 0) + 1);\r\n      }\r\n\r\n      filteredNodes = filteredNodes\r\n        .sort((a, b) => (nodeDegree.get(b.id) || 0) - (nodeDegree.get(a.id) || 0))\r\n        .slice(0, MAX_NODES);\r\n\r\n      const nodeIds = new Set(filteredNodes.map(n => n.id));\r\n      filteredEdges = filteredEdges.filter(e => nodeIds.has(e.source) && nodeIds.has(e.target));\r\n\r\n      console.log(`[Call Graph API] é™åˆ¶èŠ‚ç‚¹æ•°åˆ° ${MAX_NODES}, æœ€ç»ˆè¾¹æ•°: ${filteredEdges.length}`);\r\n    }\r\n\r\n    // 7. å¾ªç¯ä¾èµ–æ£€æµ‹\r\n    const cycles: string[][] = [];\r\n    if (enableCycleDetection) {\r\n      console.log('[Call Graph API] æ£€æµ‹å¾ªç¯ä¾èµ–...');\r\n      const visited = new Set<string>();\r\n      const recStack = new Set<string>();\r\n      const currentPath: string[] = [];\r\n\r\n      const detectCycle = (nodeId: string): boolean => {\r\n        if (recStack.has(nodeId)) {\r\n          // æ‰¾åˆ°å¾ªç¯ï¼Œæå–å¾ªç¯è·¯å¾„\r\n          const cycleStart = currentPath.indexOf(nodeId);\r\n          if (cycleStart >= 0) {\r\n            const cycle = currentPath.slice(cycleStart);\r\n            cycle.push(nodeId); // é—­åˆå¾ªç¯\r\n            cycles.push(cycle);\r\n          }\r\n          return true;\r\n        }\r\n\r\n        if (visited.has(nodeId)) return false;\r\n\r\n        visited.add(nodeId);\r\n        recStack.add(nodeId);\r\n        currentPath.push(nodeId);\r\n\r\n        // æ£€æŸ¥æ‰€æœ‰å‡ºè¾¹\r\n        for (const edge of filteredEdges) {\r\n          if (edge.source === nodeId) {\r\n            detectCycle(edge.target);\r\n          }\r\n        }\r\n\r\n        recStack.delete(nodeId);\r\n        currentPath.pop();\r\n        return false;\r\n      };\r\n\r\n      // å¯¹æ¯ä¸ªèŠ‚ç‚¹è¿›è¡ŒDFS\r\n      for (const node of filteredNodes) {\r\n        if (!visited.has(node.id)) {\r\n          detectCycle(node.id);\r\n        }\r\n      }\r\n\r\n      console.log(`[Call Graph API] æ£€æµ‹åˆ° ${cycles.length} ä¸ªå¾ªç¯ä¾èµ–`);\r\n    }\r\n\r\n    // 7. è°ƒç”¨é“¾è¿½è¸ªï¼šæŸ¥æ‰¾ä»å…¥å£ç‚¹åˆ°ç›®æ ‡ç¬¦å·çš„è·¯å¾„\r\n    const callChains: string[][] = [];\r\n\r\n    // æ£€æµ‹å…¥å£ç‚¹ï¼ˆå¸¸è§å…¥å£æ¨¡å¼ï¼‰\r\n    const entryPoints: string[] = [];\r\n    for (const node of filteredNodes) {\r\n      const name = node.name.toLowerCase();\r\n      const moduleId = node.moduleId.toLowerCase();\r\n\r\n      // æ£€æµ‹å…¥å£ç‰¹å¾\r\n      if (\r\n        name === 'main' ||                      // mainå‡½æ•°\r\n        name === 'index' ||                     // indexå‡½æ•°\r\n        name === 'start' ||                     // startå‡½æ•°\r\n        name === 'init' ||                      // initå‡½æ•°\r\n        name === 'run' ||                       // runå‡½æ•°\r\n        moduleId.includes('index.ts') ||        // indexæ–‡ä»¶\r\n        moduleId.includes('main.ts') ||         // mainæ–‡ä»¶\r\n        moduleId.includes('cli.ts') ||          // CLIå…¥å£\r\n        moduleId.includes('app.ts') ||          // appå…¥å£\r\n        moduleId.includes('server.ts')          // serverå…¥å£\r\n      ) {\r\n        entryPoints.push(node.id);\r\n        console.log(`[Call Graph API] æ£€æµ‹åˆ°å…¥å£ç‚¹: ${node.name} (${moduleId})`);\r\n      }\r\n    }\r\n\r\n    console.log(`[Call Graph API] å…±æ‰¾åˆ° ${entryPoints.length} ä¸ªå…¥å£ç‚¹`);\r\n\r\n    // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ä¼ ç»Ÿå…¥å£ç‚¹ï¼Œä½¿ç”¨å…¥åº¦ä¸º0çš„èŠ‚ç‚¹ï¼ˆæ²¡æœ‰è¢«è°ƒç”¨çš„èŠ‚ç‚¹ï¼‰\r\n    if (entryPoints.length === 0 && filteredNodes.length > 0) {\r\n      console.log('[Call Graph API] æœªæ‰¾åˆ°ä¼ ç»Ÿå…¥å£ç‚¹ï¼Œä½¿ç”¨å…¥åº¦ä¸º0çš„èŠ‚ç‚¹');\r\n      const inDegree = new Map<string, number>();\r\n      filteredNodes.forEach(n => inDegree.set(n.id, 0));\r\n      filteredEdges.forEach(e => {\r\n        inDegree.set(e.target, (inDegree.get(e.target) || 0) + 1);\r\n      });\r\n\r\n      for (const node of filteredNodes) {\r\n        if (inDegree.get(node.id) === 0) {\r\n          entryPoints.push(node.id);\r\n          console.log(`[Call Graph API] å…¥åº¦ä¸º0çš„èŠ‚ç‚¹ä½œä¸ºå…¥å£: ${node.name}`);\r\n        }\r\n      }\r\n\r\n      // é™åˆ¶å…¥å£ç‚¹æ•°é‡\r\n      if (entryPoints.length > 10) {\r\n        entryPoints.splice(10);\r\n      }\r\n\r\n      console.log(`[Call Graph API] ä½¿ç”¨ ${entryPoints.length} ä¸ªå…¥åº¦ä¸º0çš„èŠ‚ç‚¹ä½œä¸ºå…¥å£ç‚¹`);\r\n    }\r\n\r\n    // å¦‚æœæ‰¾åˆ°å…¥å£ç‚¹ä¸”æœ‰åŸå§‹ç›®æ ‡èŠ‚ç‚¹ï¼ŒæŸ¥æ‰¾è°ƒç”¨é“¾\r\n    if (entryPoints.length > 0 && originalTargetNodes.size > 0) {\r\n      console.log(`[Call Graph API] ä» ${entryPoints.length} ä¸ªå…¥å£ç‚¹æœç´¢åˆ° ${originalTargetNodes.size} ä¸ªç›®æ ‡çš„è°ƒç”¨é“¾`);\r\n\r\n      const findPaths = (startId: string, targetId: string): string[][] => {\r\n        const paths: string[][] = [];\r\n        const visited = new Set<string>();\r\n        const currentPath: string[] = [];\r\n\r\n        const dfs = (nodeId: string) => {\r\n          if (nodeId === targetId) {\r\n            paths.push([...currentPath, nodeId]);\r\n            return;\r\n          }\r\n\r\n          if (visited.has(nodeId) || currentPath.length > 10) return; // é™åˆ¶æ·±åº¦é¿å…æ­»å¾ªç¯\r\n\r\n          visited.add(nodeId);\r\n          currentPath.push(nodeId);\r\n\r\n          // æŸ¥æ‰¾æ‰€æœ‰å‡ºè¾¹ï¼ˆä½¿ç”¨å®Œæ•´çš„callGraphè€Œä¸æ˜¯filteredEdgesï¼Œä»¥æ‰¾åˆ°æ›´å®Œæ•´çš„è·¯å¾„ï¼‰\r\n          for (const edge of callGraph.edges) {\r\n            if (edge.source === nodeId) {\r\n              dfs(edge.target);\r\n            }\r\n          }\r\n\r\n          currentPath.pop();\r\n          visited.delete(nodeId);\r\n        };\r\n\r\n        dfs(startId);\r\n        return paths;\r\n      };\r\n\r\n      // ä¸ºæ¯ä¸ªåŸå§‹ç›®æ ‡èŠ‚ç‚¹æŸ¥æ‰¾ä»æ‰€æœ‰å…¥å£ç‚¹çš„è·¯å¾„\r\n      for (const targetId of originalTargetNodes) {\r\n        for (const entryId of entryPoints) {\r\n          const paths = findPaths(entryId, targetId);\r\n          if (paths.length > 0) {\r\n            console.log(`[Call Graph API] æ‰¾åˆ° ${paths.length} æ¡ä» ${entryId} åˆ° ${targetId} çš„è·¯å¾„`);\r\n          }\r\n          callChains.push(...paths);\r\n        }\r\n      }\r\n\r\n      // é™åˆ¶è¿”å›çš„è·¯å¾„æ•°é‡ï¼ˆé¿å…å¤ªå¤šï¼‰\r\n      if (callChains.length > 10) {\r\n        callChains.splice(10);\r\n      }\r\n\r\n      console.log(`[Call Graph API] æ‰¾åˆ° ${callChains.length} æ¡è°ƒç”¨é“¾`);\r\n    }\r\n\r\n    // 8. æ„å»ºç»“æœ\r\n    const result = {\r\n      data: {\r\n        nodes: filteredNodes,\r\n        edges: filteredEdges,\r\n        cycles: enableCycleDetection ? cycles : undefined,\r\n        callChains: callChains.length > 0 ? callChains : undefined,\r\n        entryPoints: entryPoints.map(id => {\r\n          const node = filteredNodes.find(n => n.id === id);\r\n          return node ? { id, name: node.name, moduleId: node.moduleId } : null;\r\n        }).filter(Boolean),\r\n      },\r\n      stats: {\r\n        totalNodes: callGraph.nodes.length,\r\n        totalEdges: callGraph.edges.length,\r\n        filteredNodes: filteredNodes.length,\r\n        filteredEdges: filteredEdges.length,\r\n        cycleCount: cycles.length,\r\n      },\r\n      metadata: {\r\n        usedLSP: true,\r\n        usedAI: enableAI && allEdges.length > 0,\r\n        detectedCycles: enableCycleDetection,\r\n        analysisTime: Date.now(),\r\n      },\r\n    };\r\n\r\n    // 9. ç¼“å­˜ç»“æœ\r\n    callGraphCache.set(cacheKey, {\r\n      data: result,\r\n      timestamp: Date.now(),\r\n    });\r\n\r\n    res.json({\r\n      success: true,\r\n      ...result,\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[Call Graph API] é”™è¯¯:', error);\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n// ============================================================================\r\n// æ¨¡å—ä¾èµ–å›¾ API\r\n// ============================================================================\r\n\r\n/**\r\n * GET /api/blueprint/dependency-graph?module=src/core/client.ts\r\n *\r\n * ç”Ÿæˆæ¨¡å—ä¾èµ–å›¾\r\n *\r\n * å‚æ•°:\r\n *   - module: æ¨¡å—è·¯å¾„ï¼ˆå¯é€‰ï¼‰ã€‚å¦‚æœæä¾›ï¼Œåªåˆ†æè¯¥æ¨¡å—åŠå…¶ä¾èµ–ï¼›å¦åˆ™åˆ†ææ•´ä¸ªé¡¹ç›®\r\n *   - depth: ä¾èµ–æ·±åº¦ï¼ˆé»˜è®¤ï¼š3ï¼‰\r\n *   - includeTypeOnly: æ˜¯å¦åŒ…å«çº¯ç±»å‹å¯¼å…¥ï¼ˆé»˜è®¤ï¼šfalseï¼‰\r\n *\r\n * è¿”å›:\r\n *   - nodes: æ¨¡å—èŠ‚ç‚¹åˆ—è¡¨ï¼ŒåŒ…å«å¯¼å…¥/å¯¼å‡ºä¿¡æ¯\r\n *   - edges: ä¾èµ–è¾¹åˆ—è¡¨ï¼Œè¡¨ç¤ºæ¨¡å—é—´çš„å¯¼å…¥å…³ç³»\r\n *   - cycles: å¾ªç¯ä¾èµ–åˆ—è¡¨ï¼ˆå¦‚æœå­˜åœ¨ï¼‰\r\n *   - stats: ä¾èµ–ç»Ÿè®¡ä¿¡æ¯\r\n */\r\nrouter.get('/dependency-graph', async (req: Request, res: Response) => {\r\n  try {\r\n    const { module, depth = '3', includeTypeOnly = 'false' } = req.query;\r\n    const maxDepth = parseInt(depth as string) || 3;\r\n    const includeTypeOnlyImports = includeTypeOnly === 'true';\r\n\r\n    console.log('[Dependency Graph API] è¯·æ±‚å‚æ•°:', { module, maxDepth, includeTypeOnlyImports });\r\n\r\n    const projectRoot = process.cwd();\r\n    const srcPath = path.join(projectRoot, 'src');\r\n\r\n    // 1. æ‰«ææ‰€æœ‰ TypeScript/JavaScript æ–‡ä»¶\r\n    const allFiles: string[] = [];\r\n\r\n    const scanDir = (dir: string) => {\r\n      if (!fs.existsSync(dir)) return;\r\n      const entries = fs.readdirSync(dir, { withFileTypes: true });\r\n\r\n      for (const entry of entries) {\r\n        const fullPath = path.join(dir, entry.name);\r\n        if (entry.isDirectory()) {\r\n          // è·³è¿‡ä¸éœ€è¦çš„ç›®å½•\r\n          if (['node_modules', 'dist', '.git', '.lh', 'coverage'].includes(entry.name)) continue;\r\n          scanDir(fullPath);\r\n        } else if (entry.isFile()) {\r\n          const ext = path.extname(entry.name);\r\n          if (['.ts', '.tsx', '.js', '.jsx'].includes(ext)) {\r\n            allFiles.push(fullPath);\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    scanDir(srcPath);\r\n    console.log(`[Dependency Graph API] æ‰«æåˆ° ${allFiles.length} ä¸ªæ–‡ä»¶`);\r\n\r\n    if (allFiles.length === 0) {\r\n      return res.json({\r\n        success: true,\r\n        data: {\r\n          nodes: [],\r\n          edges: [],\r\n          cycles: [],\r\n          stats: {\r\n            totalEdges: 0,\r\n            internalDeps: 0,\r\n            typeOnlyDeps: 0,\r\n            dynamicDeps: 0,\r\n            mostDependent: [],\r\n            mostDepended: [],\r\n          },\r\n        },\r\n        message: 'æœªæ‰¾åˆ°ä»»ä½•æºæ–‡ä»¶',\r\n      });\r\n    }\r\n\r\n    // 2. è§£ææ‰€æœ‰æ–‡ä»¶çš„å¯¼å…¥/å¯¼å‡º\r\n    const { CodeMapAnalyzer } = await import('../../../map/analyzer.js');\r\n    const fileAnalyzer = new CodeMapAnalyzer(projectRoot);\r\n\r\n    const modules: ModuleNode[] = [];\r\n\r\n    // é™åˆ¶æ–‡ä»¶æ•°é‡ï¼ˆé¿å…å¤ªæ…¢ï¼‰ï¼Œä¼˜å…ˆåˆ†æ src ç›®å½•\r\n    const filesToAnalyze = allFiles.slice(0, 200);\r\n    console.log(`[Dependency Graph API] å°†åˆ†æ ${filesToAnalyze.length} ä¸ªæ–‡ä»¶`);\r\n\r\n    for (const file of filesToAnalyze) {\r\n      try {\r\n        const moduleNode = await fileAnalyzer.analyzeFile(file);\r\n        modules.push(moduleNode);\r\n      } catch (error) {\r\n        console.error(`[Dependency Graph API] è§£ææ–‡ä»¶å¤±è´¥: ${file}`, error);\r\n      }\r\n    }\r\n\r\n    console.log(`[Dependency Graph API] æˆåŠŸè§£æ ${modules.length} ä¸ªæ¨¡å—`);\r\n\r\n    // 3. ä½¿ç”¨ DependencyAnalyzer åˆ†æä¾èµ–å…³ç³»\r\n    const { DependencyAnalyzer } = await import('../../../map/dependency-analyzer.js');\r\n    const analyzer = new DependencyAnalyzer();\r\n\r\n    let dependencyGraph = analyzer.analyzeDependencies(modules);\r\n\r\n    // 4. å¦‚æœæŒ‡å®šäº†æ¨¡å—ï¼Œè¿‡æ»¤ä¾èµ–å›¾\r\n    let filteredModules = modules;\r\n    let filteredEdges = dependencyGraph.edges;\r\n\r\n    if (module && typeof module === 'string') {\r\n      console.log(`[Dependency Graph API] è¿‡æ»¤æ¨¡å—: ${module}`);\r\n\r\n      // è§„èŒƒåŒ–æ¨¡å—è·¯å¾„\r\n      const normalizedModulePath = module.replace(/\\\\/g, '/');\r\n\r\n      // æŸ¥æ‰¾ç›®æ ‡æ¨¡å—\r\n      const targetModules = modules.filter(m => {\r\n        const normalizedId = m.id.replace(/\\\\/g, '/');\r\n        return normalizedId.includes(normalizedModulePath) || normalizedModulePath.includes(normalizedId);\r\n      });\r\n\r\n      if (targetModules.length === 0) {\r\n        return res.status(404).json({\r\n          success: false,\r\n          error: `æœªæ‰¾åˆ°æ¨¡å—: ${module}`,\r\n        });\r\n      }\r\n\r\n      console.log(`[Dependency Graph API] æ‰¾åˆ° ${targetModules.length} ä¸ªåŒ¹é…çš„æ¨¡å—`);\r\n\r\n      // æ‰©å±•åˆ°ç›¸å…³æ¨¡å—ï¼ˆåŸºäº depthï¼‰\r\n      const targetModuleIds = new Set(targetModules.map(m => m.id));\r\n      const relatedModuleIds = new Set<string>(targetModuleIds);\r\n\r\n      const expandModules = (moduleIds: Set<string>, currentDepth: number) => {\r\n        if (currentDepth >= maxDepth) return;\r\n\r\n        const newModuleIds = new Set<string>();\r\n\r\n        // æŸ¥æ‰¾æ‰€æœ‰ç›¸å…³çš„ä¾èµ–\r\n        for (const edge of dependencyGraph.edges) {\r\n          if (moduleIds.has(edge.source)) {\r\n            newModuleIds.add(edge.target);\r\n          }\r\n          if (moduleIds.has(edge.target)) {\r\n            newModuleIds.add(edge.source);\r\n          }\r\n        }\r\n\r\n        newModuleIds.forEach(id => relatedModuleIds.add(id));\r\n\r\n        if (newModuleIds.size > 0) {\r\n          expandModules(newModuleIds, currentDepth + 1);\r\n        }\r\n      };\r\n\r\n      expandModules(targetModuleIds, 0);\r\n\r\n      // è¿‡æ»¤æ¨¡å—å’Œè¾¹\r\n      filteredModules = modules.filter(m => relatedModuleIds.has(m.id));\r\n      filteredEdges = dependencyGraph.edges.filter(e =>\r\n        relatedModuleIds.has(e.source) && relatedModuleIds.has(e.target)\r\n      );\r\n\r\n      console.log(`[Dependency Graph API] è¿‡æ»¤åæ¨¡å—æ•°: ${filteredModules.length}, è¾¹æ•°: ${filteredEdges.length}`);\r\n    }\r\n\r\n    // 5. è¿‡æ»¤çº¯ç±»å‹å¯¼å…¥ï¼ˆå¦‚æœéœ€è¦ï¼‰\r\n    if (!includeTypeOnlyImports) {\r\n      const beforeCount = filteredEdges.length;\r\n      filteredEdges = filteredEdges.filter(e => !e.isTypeOnly);\r\n      console.log(`[Dependency Graph API] æ’é™¤çº¯ç±»å‹å¯¼å…¥: ${beforeCount} -> ${filteredEdges.length}`);\r\n    }\r\n\r\n    // 6. æ£€æµ‹å¾ªç¯ä¾èµ–\r\n    const cycles = analyzer.detectCircularDependencies({ edges: filteredEdges });\r\n    console.log(`[Dependency Graph API] æ£€æµ‹åˆ° ${cycles.length} ä¸ªå¾ªç¯ä¾èµ–`);\r\n\r\n    // 7. è·å–ç»Ÿè®¡ä¿¡æ¯\r\n    const stats = analyzer.getDependencyStats({ edges: filteredEdges });\r\n\r\n    // 8. æ„å»ºè¿”å›æ•°æ®ï¼ˆç®€åŒ–ç‰ˆï¼‰\r\n    const nodes = filteredModules.map(m => ({\r\n      id: m.id,\r\n      name: m.name,\r\n      path: m.path,\r\n      language: m.language,\r\n      lines: m.lines,\r\n      imports: m.imports.map(imp => ({\r\n        source: imp.source,\r\n        symbols: imp.symbols,\r\n        isDefault: imp.isDefault,\r\n        isDynamic: imp.isDynamic,\r\n      })),\r\n      exports: m.exports.map(exp => ({\r\n        name: exp.name,\r\n        type: exp.type,\r\n      })),\r\n    }));\r\n\r\n    const edges = filteredEdges.map(e => ({\r\n      source: e.source,\r\n      target: e.target,\r\n      type: e.type,\r\n      symbols: e.symbols,\r\n      isTypeOnly: e.isTypeOnly,\r\n    }));\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        nodes,\r\n        edges,\r\n        cycles: cycles.length > 0 ? cycles : undefined,\r\n        stats,\r\n      },\r\n      metadata: {\r\n        totalModules: modules.length,\r\n        filteredModules: filteredModules.length,\r\n        totalEdges: dependencyGraph.edges.length,\r\n        filteredEdges: filteredEdges.length,\r\n        analysisTime: new Date().toISOString(),\r\n      },\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[Dependency Graph API] é”™è¯¯:', error);\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n// ============================================================================\r\n// æ•°æ®æµåˆ†æ API\r\n// ============================================================================\r\n\r\n/**\r\n * GET /api/blueprint/data-flow/:symbolId\r\n *\r\n * è·å–æ•°æ®æµåˆ†æç»“æœ\r\n *\r\n * è¿½è¸ªå±æ€§/å˜é‡çš„æ‰€æœ‰è¯»å†™ä½ç½®\r\n *\r\n * å‚æ•°:\r\n *   - symbolId: ç¬¦å·IDï¼Œæ ¼å¼ä¸º \"filePath::symbolName\" æˆ– \"filePath::className::propertyName\"\r\n *\r\n * è¿”å›:\r\n *   - symbolId: ç¬¦å·ID\r\n *   - symbolName: ç¬¦å·åç§°\r\n *   - reads: è¯»å–ä½ç½®åˆ—è¡¨\r\n *   - writes: å†™å…¥ä½ç½®åˆ—è¡¨\r\n *   - dataFlowGraph: æ•°æ®æµå›¾ï¼ˆå¯é€‰ï¼‰\r\n */\r\nrouter.get('/data-flow', async (req: Request, res: Response) => {\r\n  try {\r\n    const symbolId = req.query.symbolId as string;\r\n\r\n    if (!symbolId) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: 'ç¼ºå°‘å¿…éœ€çš„å‚æ•°: symbolId',\r\n      });\r\n    }\r\n\r\n    // è§£ç ç¬¦å· ID\r\n    const decodedId = decodeURIComponent(symbolId);\r\n\r\n    console.log('[Data Flow API] åˆ†æç¬¦å·:', decodedId);\r\n\r\n    // æ‰§è¡Œæ•°æ®æµåˆ†æ\r\n    const { DataFlowAnalyzer } = await import('./data-flow-analyzer.js');\r\n    const analyzer = new DataFlowAnalyzer();\r\n    const dataFlow = await analyzer.analyzeDataFlow(decodedId);\r\n\r\n    console.log('[Data Flow API] åˆ†æå®Œæˆ:', {\r\n      symbolName: dataFlow.symbolName,\r\n      reads: dataFlow.reads.length,\r\n      writes: dataFlow.writes.length,\r\n    });\r\n\r\n    res.json({\r\n      success: true,\r\n      data: dataFlow,\r\n    });\r\n  } catch (error) {\r\n    console.error('[Data Flow API] é”™è¯¯:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: (error as Error).message,\r\n    });\r\n  }\r\n});\r\n\r\n\r\n// ============================================================================\r\n// ç¬¦å·æµè§ˆ API (LSP)\r\n// ============================================================================\r\n\r\n// ç¬¦å·ç¼“å­˜ï¼ˆé¿å…æ¯æ¬¡éƒ½æ‰«ææ‰€æœ‰æ–‡ä»¶ï¼‰\r\nlet symbolsCache: {\r\n  data: Array<{\r\n    id: string;\r\n    name: string;\r\n    type: string;\r\n    moduleId: string;\r\n    signature?: string;\r\n    className?: string;\r\n  }>;\r\n  timestamp: number;\r\n} | null = null;\r\n\r\nconst SYMBOLS_CACHE_TTL = 10 * 60 * 1000; // 10åˆ†é’Ÿ\r\n\r\n/**\r\n * è·å–ç¬¦å·åˆ—è¡¨ï¼ˆæ”¯æŒè¿‡æ»¤ï¼‰\r\n * GET /api/blueprint/symbols?type=function&module=src/core&search=handler\r\n *\r\n * æŸ¥è¯¢å‚æ•°ï¼š\r\n * - type: ç¬¦å·ç±»å‹ (function/method/class/interface/type)\r\n * - module: æ¨¡å—è·¯å¾„ï¼ˆæ”¯æŒéƒ¨åˆ†åŒ¹é…ï¼‰\r\n * - search: æœç´¢è¯ï¼ˆåŒ¹é…ç¬¦å·åç§°ï¼‰\r\n */\r\n\r\n/**\r\n * è·å–æ–‡ä»¶å†…å®¹ API\r\n * GET /api/blueprint/file-content?path=xxx\r\n */\r\nrouter.get('/file-content', async (req: Request, res: Response) => {\r\n  try {\r\n    const filePath = req.query.path as string;\r\n\r\n    if (!filePath) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: 'ç¼ºå°‘å¿…éœ€çš„å‚æ•°: path',\r\n      });\r\n    }\r\n\r\n    const projectRoot = process.cwd();\r\n    let absolutePath: string;\r\n\r\n    // å¤„ç†ç›¸å¯¹è·¯å¾„å’Œç»å¯¹è·¯å¾„\r\n    if (path.isAbsolute(filePath)) {\r\n      absolutePath = filePath;\r\n    } else {\r\n      absolutePath = path.join(projectRoot, filePath);\r\n    }\r\n\r\n    if (!fs.existsSync(absolutePath)) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        error: `æ–‡ä»¶ä¸å­˜åœ¨: ${filePath}`,\r\n      });\r\n    }\r\n\r\n    const content = fs.readFileSync(absolutePath, 'utf-8');\r\n    const stats = fs.statSync(absolutePath);\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        path: filePath,\r\n        absolutePath,\r\n        content,\r\n        size: stats.size,\r\n        modified: stats.mtime.toISOString(),\r\n      },\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[File Content API] é”™è¯¯:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: error.message || 'è¯»å–æ–‡ä»¶å¤±è´¥',\r\n    });\r\n  }\r\n});\r\n\r\nrouter.get('/symbols', async (req: Request, res: Response) => {\r\n  try {\r\n    const { type, module, search } = req.query;\r\n\r\n    console.log('[Symbols API] æŸ¥è¯¢å‚æ•°:', { type, module, search });\r\n\r\n    // æ£€æŸ¥ç¼“å­˜\r\n    if (symbolsCache && Date.now() - symbolsCache.timestamp < SYMBOLS_CACHE_TTL) {\r\n      console.log('[Symbols API] ä½¿ç”¨ç¼“å­˜çš„ç¬¦å·åˆ—è¡¨');\r\n    } else {\r\n      console.log('[Symbols API] é‡æ–°æ‰«æç¬¦å·...');\r\n\r\n      const projectRoot = process.cwd();\r\n      const tsFiles: string[] = [];\r\n      const srcPath = path.join(projectRoot, 'src');\r\n\r\n      // æ‰«æ TypeScript æ–‡ä»¶\r\n      const scanDir = (dir: string) => {\r\n        if (!fs.existsSync(dir)) return;\r\n        const entries = fs.readdirSync(dir, { withFileTypes: true });\r\n\r\n        for (const entry of entries) {\r\n          const fullPath = path.join(dir, entry.name);\r\n          if (entry.isDirectory()) {\r\n            if (['node_modules', 'dist', '.git', '.lh'].includes(entry.name)) continue;\r\n            scanDir(fullPath);\r\n          } else if (entry.isFile()) {\r\n            const ext = path.extname(entry.name);\r\n            if (['.ts', '.tsx'].includes(ext)) {\r\n              tsFiles.push(fullPath);\r\n            }\r\n          }\r\n        }\r\n      };\r\n\r\n      scanDir(srcPath);\r\n      console.log(`[Symbols API] æ‰«æåˆ° ${tsFiles.length} ä¸ª TypeScript æ–‡ä»¶`);\r\n\r\n      // åˆå§‹åŒ– LSP åˆ†æå™¨ï¼ˆå¤ç”¨å…¨å±€å®ä¾‹ï¼‰\r\n      if (!lspAnalyzer) {\r\n        const { TypeScriptLSPAnalyzer } = await import('./lsp-analyzer.js');\r\n        lspAnalyzer = new TypeScriptLSPAnalyzer();\r\n        lspAnalyzer.initProgram(tsFiles, projectRoot);\r\n        console.log('[Symbols API] LSP åˆ†æå™¨å·²åˆå§‹åŒ–');\r\n      }\r\n\r\n      // æå–æ‰€æœ‰ç¬¦å·\r\n      const allSymbols: Array<{\r\n        id: string;\r\n        name: string;\r\n        type: string;\r\n        moduleId: string;\r\n        signature?: string;\r\n        className?: string;\r\n      }> = [];\r\n\r\n      for (const file of tsFiles) {\r\n        try {\r\n          const { functions, classes, interfaces, types } = lspAnalyzer.analyzeFile(file);\r\n          const relativePath = path.relative(projectRoot, file);\r\n\r\n          // æ·»åŠ å‡½æ•°\r\n          for (const func of functions) {\r\n            allSymbols.push({\r\n              id: func.id,\r\n              name: func.name,\r\n              type: 'function',\r\n              moduleId: relativePath,\r\n              signature: func.signature,\r\n            });\r\n          }\r\n\r\n          // æ·»åŠ ç±»å’Œç±»æ–¹æ³•\r\n          for (const cls of classes) {\r\n            // æ·»åŠ ç±»æœ¬èº«\r\n            const exportStr = cls.isExported ? 'export ' : '';\r\n            const abstractStr = cls.isAbstract ? 'abstract ' : '';\r\n            allSymbols.push({\r\n              id: cls.id,\r\n              name: cls.name,\r\n              type: 'class',\r\n              moduleId: relativePath,\r\n              signature: `${exportStr}${abstractStr}class ${cls.name}`,\r\n            });\r\n\r\n            // æ·»åŠ ç±»æ–¹æ³•\r\n            for (const method of cls.methods) {\r\n              allSymbols.push({\r\n                id: method.id,\r\n                name: method.name,\r\n                type: method.name === 'constructor' ? 'constructor' : 'method',\r\n                moduleId: relativePath,\r\n                className: cls.name,\r\n                signature: method.signature,\r\n              });\r\n            }\r\n          }\r\n\r\n          // æ·»åŠ æ¥å£\r\n          for (const iface of interfaces) {\r\n            const exportStr = iface.isExported ? 'export ' : '';\r\n            allSymbols.push({\r\n              id: iface.id,\r\n              name: iface.name,\r\n              type: 'interface',\r\n              moduleId: relativePath,\r\n              signature: `${exportStr}interface ${iface.name}`,\r\n            });\r\n          }\r\n\r\n          // æ·»åŠ ç±»å‹åˆ«å\r\n          for (const typeNode of types) {\r\n            const exportStr = typeNode.isExported ? 'export ' : '';\r\n            allSymbols.push({\r\n              id: typeNode.id,\r\n              name: typeNode.name,\r\n              type: 'type',\r\n              moduleId: relativePath,\r\n              signature: `${exportStr}type ${typeNode.name}`,\r\n            });\r\n          }\r\n        } catch (error) {\r\n          console.error(`[Symbols API] åˆ†ææ–‡ä»¶å¤±è´¥: ${file}`, error);\r\n        }\r\n      }\r\n\r\n      // æ›´æ–°ç¼“å­˜\r\n      symbolsCache = {\r\n        data: allSymbols,\r\n        timestamp: Date.now(),\r\n      };\r\n\r\n      console.log(`[Symbols API] æå–åˆ° ${allSymbols.length} ä¸ªç¬¦å·`);\r\n    }\r\n\r\n    // åº”ç”¨è¿‡æ»¤\r\n    let filteredSymbols = symbolsCache.data;\r\n\r\n    // è¿‡æ»¤ï¼šæŒ‰ç±»å‹\r\n    if (type && typeof type === 'string') {\r\n      filteredSymbols = filteredSymbols.filter(s => s.type === type);\r\n    }\r\n\r\n    // è¿‡æ»¤ï¼šæŒ‰æ¨¡å—\r\n    if (module && typeof module === 'string') {\r\n      const normalizedModule = (module as string).replace(/\\\\/g, '/');\r\n      filteredSymbols = filteredSymbols.filter(s =>\r\n        s.moduleId.replace(/\\\\/g, '/').includes(normalizedModule)\r\n      );\r\n    }\r\n\r\n    // è¿‡æ»¤ï¼šæŒ‰æœç´¢è¯\r\n    if (search && typeof search === 'string') {\r\n      const searchLower = (search as string).toLowerCase();\r\n      filteredSymbols = filteredSymbols.filter(s =>\r\n        s.name.toLowerCase().includes(searchLower) ||\r\n        (s.className && s.className.toLowerCase().includes(searchLower))\r\n      );\r\n    }\r\n\r\n    console.log(`[Symbols API] è¿‡æ»¤åå‰©ä½™ ${filteredSymbols.length} ä¸ªç¬¦å·`);\r\n\r\n    res.json({\r\n      success: true,\r\n      data: filteredSymbols,\r\n      count: filteredSymbols.length,\r\n      cached: symbolsCache !== null,\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[Symbols API] é”™è¯¯:', error);\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * è·å–ç¬¦å·è¯¦æƒ…\r\n * GET /api/blueprint/symbol/:id/detail\r\n *\r\n * ç¬¦å· ID æ ¼å¼:\r\n * - å‡½æ•°/ç±»/æ¥å£/ç±»å‹: \"file.ts::symbolName\"\r\n * - ç±»æ–¹æ³•: \"file.ts::ClassName::methodName\"\r\n */\r\nrouter.get('/symbol-detail', async (req: Request, res: Response) => {\r\n  try {\r\n    const id = req.query.id as string;\r\n\r\n    if (!id) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: 'ç¼ºå°‘å¿…éœ€çš„å‚æ•°: id',\r\n      });\r\n    }\r\n\r\n    console.log(`[Symbol Detail API] æŸ¥è¯¢ç¬¦å·: ${id}`);\r\n\r\n    // è§£æç¬¦å· ID\r\n    // ID æ ¼å¼: \"file.ts::symbolName\" æˆ– \"file.ts::ClassName::methodName\"\r\n    const parts = id.split('::');\r\n    if (parts.length < 2) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: `æ— æ•ˆçš„ç¬¦å· ID æ ¼å¼: ${id}`,\r\n        hint: 'ID æ ¼å¼åº”ä¸º \"file.ts::symbolName\" æˆ– \"file.ts::ClassName::methodName\"',\r\n      });\r\n    }\r\n\r\n    const filePath = parts[0];\r\n    const symbolName = parts[parts.length - 1];\r\n\r\n    console.log(`[Symbol Detail API] æ–‡ä»¶: ${filePath}, ç¬¦å·: ${symbolName}`);\r\n\r\n    // æ„å»ºç»å¯¹è·¯å¾„ï¼ˆå¤„ç†ç›¸å¯¹è·¯å¾„å’Œç»å¯¹è·¯å¾„ä¸¤ç§æƒ…å†µï¼‰\r\n    const projectRoot = process.cwd();\r\n    let absolutePath: string;\r\n\r\n    // æ£€æŸ¥æ˜¯å¦ä¸ºç»å¯¹è·¯å¾„\r\n    if (path.isAbsolute(filePath)) {\r\n      absolutePath = filePath;\r\n    } else {\r\n      absolutePath = path.join(projectRoot, filePath);\r\n    }\r\n\r\n    if (!fs.existsSync(absolutePath)) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        error: `æ–‡ä»¶ä¸å­˜åœ¨: ${filePath}`,\r\n      });\r\n    }\r\n\r\n    // åˆå§‹åŒ– LSP åˆ†æå™¨ï¼ˆå¤ç”¨å…¨å±€å®ä¾‹ï¼‰\r\n    if (!lspAnalyzer) {\r\n      const tsFiles: string[] = [];\r\n      const srcPath = path.join(projectRoot, 'src');\r\n\r\n      const scanDir = (dir: string) => {\r\n        if (!fs.existsSync(dir)) return;\r\n        const entries = fs.readdirSync(dir, { withFileTypes: true });\r\n\r\n        for (const entry of entries) {\r\n          const fullPath = path.join(dir, entry.name);\r\n          if (entry.isDirectory()) {\r\n            if (['node_modules', 'dist', '.git', '.lh'].includes(entry.name)) continue;\r\n            scanDir(fullPath);\r\n          } else if (entry.isFile()) {\r\n            const ext = path.extname(entry.name);\r\n            if (['.ts', '.tsx'].includes(ext)) {\r\n              tsFiles.push(fullPath);\r\n            }\r\n          }\r\n        }\r\n      };\r\n\r\n      scanDir(srcPath);\r\n\r\n      const { TypeScriptLSPAnalyzer } = await import('./lsp-analyzer.js');\r\n      lspAnalyzer = new TypeScriptLSPAnalyzer();\r\n      lspAnalyzer.initProgram(tsFiles, projectRoot);\r\n      console.log('[Symbol Detail API] LSP åˆ†æå™¨å·²åˆå§‹åŒ–');\r\n    }\r\n\r\n    // åˆ†ææ–‡ä»¶\r\n    const { functions, classes, interfaces, types } = lspAnalyzer.analyzeFile(absolutePath);\r\n\r\n    console.log(`[Symbol Detail API] åˆ†æç»“æœ - å‡½æ•°: ${functions.length}, ç±»: ${classes.length}, æ¥å£: ${interfaces.length}, ç±»å‹: ${types.length}`);\r\n\r\n    // æŸ¥æ‰¾ç¬¦å·\r\n    let detail: any = null;\r\n    let symbolType = 'unknown';\r\n\r\n    // åœ¨ functions ä¸­æŸ¥æ‰¾\r\n    const func = functions.find(f => f.name === symbolName);\r\n    if (func) {\r\n      detail = func;\r\n      symbolType = 'function';\r\n    }\r\n\r\n    // åœ¨ classes ä¸­æŸ¥æ‰¾\r\n    if (!detail) {\r\n      const cls = classes.find(c => c.name === symbolName);\r\n      if (cls) {\r\n        detail = cls;\r\n        symbolType = 'class';\r\n      } else {\r\n        // æŸ¥æ‰¾ç±»çš„æ–¹æ³•\r\n        for (const cls of classes) {\r\n          const method = cls.methods.find(m => m.name === symbolName);\r\n          if (method) {\r\n            detail = { ...method, className: cls.name };\r\n            symbolType = 'method';\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // åœ¨ interfaces ä¸­æŸ¥æ‰¾\r\n    if (!detail) {\r\n      const iface = interfaces.find(i => i.name === symbolName);\r\n      if (iface) {\r\n        detail = iface;\r\n        symbolType = 'interface';\r\n      }\r\n    }\r\n\r\n    // åœ¨ types ä¸­æŸ¥æ‰¾\r\n    if (!detail) {\r\n      const typeNode = types.find(t => t.name === symbolName);\r\n      if (typeNode) {\r\n        detail = typeNode;\r\n        symbolType = 'type';\r\n      }\r\n    }\r\n\r\n    if (!detail) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        error: `ç¬¦å· \"${symbolName}\" æœªåœ¨æ–‡ä»¶ \"${filePath}\" ä¸­æ‰¾åˆ°`,\r\n        hint: `å¯ç”¨ç¬¦å·: ${[\r\n          ...functions.map(f => f.name),\r\n          ...classes.map(c => c.name),\r\n          ...interfaces.map(i => i.name),\r\n          ...types.map(t => t.name),\r\n        ].join(', ')}`,\r\n      });\r\n    }\r\n\r\n    // è·å–ç¬¦å·åˆ†ç±»ä¿¡æ¯\r\n    const classification = classifySymbol(symbolType);\r\n\r\n    console.log(`[Symbol Detail API] æ‰¾åˆ°ç¬¦å·: ${symbolName} (${symbolType})`);\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        ...detail,\r\n        symbolType,\r\n        classification,\r\n        availableViews: classification.supportedViews,\r\n      },\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[Symbol Detail API] é”™è¯¯:', error);\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * è·å–å…¥å£ç‚¹çš„è°ƒç”¨è·¯å¾„è¿½è¸ª\r\n * ç”¨äºä»£ç åœ°å›¾çš„æ•°æ®æµå‘å¯è§†åŒ–\r\n */\r\nrouter.get('/call-paths', async (req: Request, res: Response) => {\r\n  try {\r\n    const { entryPoint, maxDepth = '5' } = req.query;\r\n    const depth = parseInt(maxDepth as string, 10) || 5;\r\n\r\n    console.log('[Call Paths API] è¯·æ±‚å‚æ•°:', { entryPoint, maxDepth: depth });\r\n\r\n    const projectRoot = process.cwd();\r\n\r\n    // 1. æ‰«æTypeScriptæ–‡ä»¶\r\n    const tsFiles: string[] = [];\r\n    const srcPath = path.join(projectRoot, 'src');\r\n\r\n    const scanDir = (dir: string) => {\r\n      if (!fs.existsSync(dir)) return;\r\n      const entries = fs.readdirSync(dir, { withFileTypes: true });\r\n\r\n      for (const ent of entries) {\r\n        const fullPath = path.join(dir, ent.name);\r\n        if (ent.isDirectory()) {\r\n          if (['node_modules', 'dist', '.git', '.lh'].includes(ent.name)) continue;\r\n          scanDir(fullPath);\r\n        } else if (ent.isFile()) {\r\n          const ext = path.extname(ent.name);\r\n          if (['.ts', '.tsx'].includes(ext)) {\r\n            tsFiles.push(fullPath);\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    scanDir(srcPath);\r\n    console.log(`[Call Paths API] æ‰«æåˆ° ${tsFiles.length} ä¸ªTypeScriptæ–‡ä»¶`);\r\n\r\n    // 2. æ£€æµ‹å…¥å£ç‚¹\r\n    const { detectEntryPoints } = await import('./project-map-generator.js');\r\n    const entryPoints = await detectEntryPoints(tsFiles);\r\n\r\n    // å¦‚æœæ²¡æœ‰æŒ‡å®šå…¥å£ç‚¹ï¼Œè¿”å›æ‰€æœ‰å…¥å£ç‚¹åˆ—è¡¨\r\n    if (!entryPoint) {\r\n      return res.json({\r\n        success: true,\r\n        data: {\r\n          entryPoints,\r\n          message: 'è¯·é€‰æ‹©ä¸€ä¸ªå…¥å£ç‚¹',\r\n        },\r\n      });\r\n    }\r\n\r\n    // 3. æ‰¾åˆ°æŒ‡å®šçš„å…¥å£ç‚¹\r\n    const entry = entryPoints.find(\r\n      (e: any) => e.id === entryPoint || e.moduleId === entryPoint\r\n    );\r\n\r\n    if (!entry) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        error: `å…¥å£ç‚¹ \"${entryPoint}\" æœªæ‰¾åˆ°`,\r\n      });\r\n    }\r\n\r\n    console.log('[Call Paths API] å…¥å£ç‚¹:', entry);\r\n\r\n    // 4. åˆå§‹åŒ–LSPåˆ†æå™¨\r\n    if (!lspAnalyzer) {\r\n      const { TypeScriptLSPAnalyzer } = await import('./lsp-analyzer.js');\r\n      lspAnalyzer = new TypeScriptLSPAnalyzer();\r\n      lspAnalyzer.initProgram(tsFiles, projectRoot);\r\n      console.log('[Call Paths API] LSPåˆ†æå™¨å·²åˆå§‹åŒ–');\r\n    }\r\n\r\n    // 5. æ„å»ºè°ƒç”¨å›¾ï¼ˆå¤ç”¨ /call-graph çš„é€»è¾‘ï¼‰\r\n    const allNodes: CallGraphNode[] = [];\r\n    const allEdges: CallGraphEdge[] = [];\r\n    const symbolMap = new Map<string, CallGraphNode>();\r\n\r\n    // é™åˆ¶åˆ†æçš„æ–‡ä»¶æ•°é‡ï¼ˆé¿å…å¤ªæ…¢ï¼‰\r\n    const filesToAnalyze = tsFiles.slice(0, 100);\r\n    console.log(`[Call Paths API] å°†åˆ†æ ${filesToAnalyze.length} ä¸ªæ–‡ä»¶`);\r\n\r\n    for (const file of filesToAnalyze) {\r\n      try {\r\n        const { functions, classes } = lspAnalyzer.analyzeFile(file);\r\n        const relativePath = path.relative(projectRoot, file);\r\n\r\n        // æ·»åŠ å‡½æ•°èŠ‚ç‚¹\r\n        for (const func of functions) {\r\n          const node: CallGraphNode = {\r\n            id: func.id,\r\n            name: func.name,\r\n            type: 'function',\r\n            moduleId: relativePath,\r\n            signature: func.signature,\r\n          };\r\n          allNodes.push(node);\r\n          symbolMap.set(func.name, node);\r\n          symbolMap.set(func.id, node);\r\n        }\r\n\r\n        // æ·»åŠ ç±»æ–¹æ³•èŠ‚ç‚¹\r\n        for (const cls of classes) {\r\n          for (const method of cls.methods) {\r\n            const node: CallGraphNode = {\r\n              id: method.id,\r\n              name: method.name,\r\n              type: method.name === 'constructor' ? 'constructor' : 'method',\r\n              moduleId: relativePath,\r\n              className: cls.name,\r\n              signature: method.signature,\r\n            };\r\n            allNodes.push(node);\r\n            symbolMap.set(`${cls.name}.${method.name}`, node);\r\n            symbolMap.set(method.id, node);\r\n          }\r\n        }\r\n\r\n        // æå–è°ƒç”¨å…³ç³»ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼Œåªæå–ç›´æ¥è°ƒç”¨ï¼‰\r\n        for (const func of functions) {\r\n          if (func.calls) {\r\n            for (const call of func.calls) {\r\n              const targetNode = symbolMap.get(call);\r\n              if (targetNode) {\r\n                allEdges.push({\r\n                  source: func.id,\r\n                  target: targetNode.id,\r\n                  type: 'direct',\r\n                  count: 1,\r\n                  locations: [],\r\n                });\r\n              }\r\n            }\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.error(`[Call Paths API] åˆ†ææ–‡ä»¶å¤±è´¥: ${file}`, error);\r\n      }\r\n    }\r\n\r\n    console.log(`[Call Paths API] è°ƒç”¨å›¾: ${allNodes.length} èŠ‚ç‚¹, ${allEdges.length} è¾¹`);\r\n\r\n    // 6. ä»å…¥å£ç‚¹å¼€å§‹è¿½è¸ªè°ƒç”¨è·¯å¾„\r\n    // æ‰¾åˆ°å…¥å£ç‚¹å¯¹åº”çš„èŠ‚ç‚¹\r\n    const entryNodes = allNodes.filter(n => {\r\n      // ä½¿ç”¨ moduleId åŒ¹é…å…¥å£ç‚¹ï¼ˆmoduleId æ˜¯ç›¸å¯¹è·¯å¾„ï¼‰\r\n      return n.moduleId === entry.moduleId || n.moduleId.includes(entry.moduleId);\r\n    });\r\n\r\n    console.log(`[Call Paths API] æ‰¾åˆ° ${entryNodes.length} ä¸ªå…¥å£èŠ‚ç‚¹`);\r\n\r\n    // 7. BFS è¿½è¸ªæ‰€æœ‰å¯è¾¾èŠ‚ç‚¹\r\n    const filePathMap = new Map<string, { depth: number; callCount: number; paths: string[][] }>();\r\n    const visited = new Set<string>();\r\n    const queue: Array<{ nodeId: string; depth: number; path: string[] }> = [];\r\n\r\n    // åˆå§‹åŒ–é˜Ÿåˆ—\r\n    for (const node of entryNodes) {\r\n      queue.push({ nodeId: node.id, depth: 0, path: [node.moduleId] });\r\n      visited.add(node.id);\r\n\r\n      filePathMap.set(node.moduleId, { depth: 0, callCount: 1, paths: [[node.moduleId]] });\r\n    }\r\n\r\n    // BFS éå†\r\n    while (queue.length > 0) {\r\n      const { nodeId, depth: currentDepth, path: currentPath } = queue.shift()!;\r\n\r\n      if (currentDepth >= depth) continue;\r\n\r\n      // æ‰¾åˆ°æ‰€æœ‰å‡ºè¾¹\r\n      const outEdges = allEdges.filter(e => e.source === nodeId);\r\n\r\n      for (const edge of outEdges) {\r\n        const targetNode = allNodes.find(n => n.id === edge.target);\r\n        if (!targetNode) continue;\r\n\r\n        const targetModuleId = targetNode.moduleId;\r\n        const newPath = [...currentPath, targetModuleId];\r\n\r\n        // æ›´æ–°æ–‡ä»¶è·¯å¾„æ˜ å°„\r\n        if (!filePathMap.has(targetModuleId)) {\r\n          filePathMap.set(targetModuleId, { depth: currentDepth + 1, callCount: 0, paths: [] });\r\n        }\r\n\r\n        const fileInfo = filePathMap.get(targetModuleId)!;\r\n        fileInfo.callCount++;\r\n        fileInfo.paths.push(newPath);\r\n\r\n        // æ›´æ–°æ·±åº¦ï¼ˆä¿ç•™æœ€çŸ­è·¯å¾„æ·±åº¦ï¼‰\r\n        if (currentDepth + 1 < fileInfo.depth) {\r\n          fileInfo.depth = currentDepth + 1;\r\n        }\r\n\r\n        // ç»§ç»­éå†\r\n        if (!visited.has(edge.target)) {\r\n          visited.add(edge.target);\r\n          queue.push({ nodeId: edge.target, depth: currentDepth + 1, path: newPath });\r\n        }\r\n      }\r\n    }\r\n\r\n    // 8. æ„å»ºè¿”å›æ•°æ®\r\n    const paths = Array.from(filePathMap.entries()).map(([filePath, info]) => ({\r\n      file: filePath,\r\n      depth: info.depth,\r\n      callCount: info.callCount,\r\n      paths: info.paths.slice(0, 5), // æœ€å¤šè¿”å›5æ¡è·¯å¾„ç¤ºä¾‹\r\n    }));\r\n\r\n    // æŒ‰æ·±åº¦å’Œè°ƒç”¨æ¬¡æ•°æ’åº\r\n    paths.sort((a, b) => {\r\n      if (a.depth !== b.depth) return a.depth - b.depth;\r\n      return b.callCount - a.callCount;\r\n    });\r\n\r\n    console.log(`[Call Paths API] è¿½è¸ªåˆ° ${paths.length} ä¸ªæ–‡ä»¶`);\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        entryPoint: {\r\n          id: entry.id,\r\n          name: entry.name,\r\n          moduleId: entry.moduleId,\r\n        },\r\n        paths,\r\n        stats: {\r\n          totalFiles: paths.length,\r\n          maxDepth: Math.max(...paths.map(p => p.depth), 0),\r\n          totalCalls: paths.reduce((sum, p) => sum + p.callCount, 0),\r\n        },\r\n      },\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[Call Paths API] é”™è¯¯:', error);\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n// ============================================================================\r\n// æ´‹è‘±æ¶æ„å¯¼èˆªå™¨ API (Onion Navigator)\r\n// ============================================================================\r\n\r\nimport {\r\n  analyzeProjectIntent,\r\n  analyzeBusinessDomains,\r\n  analyzeKeyProcesses,\r\n  analyzeImplementation,\r\n  generateAIAnnotation,\r\n} from './onion-analyzer.js';\r\nimport { OnionLayer } from '../../shared/onion-types.js';\r\n\r\n/**\r\n * è·å–æŒ‡å®šå±‚çº§çš„æ´‹è‘±æ•°æ®\r\n * GET /api/blueprint/onion/layer/:layer\r\n *\r\n * è·¯å¾„å‚æ•°:\r\n * - layer: 1-4 (PROJECT_INTENT | BUSINESS_DOMAIN | KEY_PROCESS | IMPLEMENTATION)\r\n *\r\n * æŸ¥è¯¢å‚æ•°:\r\n * - context: JSON å­—ç¬¦ä¸²ï¼ŒåŒ…å« fromLayer å’Œ nodeId\r\n * - forceRefresh: boolean\r\n * - filePath: ç¬¬å››å±‚éœ€è¦çš„æ–‡ä»¶è·¯å¾„\r\n * - symbolId: ç¬¬å››å±‚å¯é€‰çš„ç¬¦å·ID\r\n * - enableAI: boolean - æ˜¯å¦å¯ç”¨ AI åˆ†æç”Ÿæˆå…³é”®ç‚¹ï¼ˆé»˜è®¤ trueï¼‰\r\n */\r\nrouter.get('/onion/layer/:layer', async (req: Request, res: Response) => {\r\n  try {\r\n    const layer = parseInt(req.params.layer, 10) as OnionLayer;\r\n    const contextStr = req.query.context as string;\r\n    const forceRefresh = req.query.forceRefresh === 'true';\r\n    const filePath = req.query.filePath as string;\r\n    const symbolId = req.query.symbolId as string;\r\n    const nodeId = req.query.nodeId as string; // ç›´æ¥è·å– nodeId å‚æ•°\r\n    const fromLayer = req.query.fromLayer as string;\r\n    const enableAI = req.query.enableAI !== 'false'; // é»˜è®¤å¯ç”¨ AI\r\n\r\n    if (layer < 1 || layer > 4) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: 'æ— æ•ˆçš„å±‚çº§ï¼Œå¿…é¡»æ˜¯ 1-4',\r\n      });\r\n    }\r\n\r\n    const projectRoot = process.cwd();\r\n    const startTime = Date.now();\r\n\r\n    let data: any;\r\n    let context: any;\r\n\r\n    // ä¼˜å…ˆä½¿ç”¨ç›´æ¥ä¼ é€’çš„ nodeId å’Œ fromLayer å‚æ•°\r\n    if (nodeId || fromLayer) {\r\n      context = { nodeId, fromLayer };\r\n    } else if (contextStr) {\r\n      // å…¼å®¹æ—§çš„ context JSON æ ¼å¼\r\n      try {\r\n        context = JSON.parse(contextStr);\r\n      } catch (e) {\r\n        console.warn('[Onion API] æ— æ³•è§£æ context:', contextStr);\r\n      }\r\n    }\r\n\r\n    console.log(`[Onion API] è¯·æ±‚å±‚çº§ ${layer}ï¼ŒnodeId: ${nodeId || context?.nodeId || 'æ— '}`);\r\n\r\n\r\n    switch (layer) {\r\n      case OnionLayer.PROJECT_INTENT:\r\n        data = await analyzeProjectIntent(projectRoot);\r\n        break;\r\n\r\n      case OnionLayer.BUSINESS_DOMAIN:\r\n        data = await analyzeBusinessDomains(projectRoot);\r\n        break;\r\n\r\n      case OnionLayer.KEY_PROCESS:\r\n        data = await analyzeKeyProcesses(projectRoot, context?.nodeId, forceRefresh);\r\n        break;\r\n\r\n      case OnionLayer.IMPLEMENTATION:\r\n        if (!filePath) {\r\n          return res.status(400).json({\r\n            success: false,\r\n            error: 'ç¬¬å››å±‚éœ€è¦æä¾› filePath å‚æ•°',\r\n          });\r\n        }\r\n        data = await analyzeImplementation(projectRoot, filePath, symbolId);\r\n        break;\r\n    }\r\n\r\n    // å¦‚æœå¯ç”¨ AI åˆ†æï¼Œä¸” annotation.keyPoints åŒ…å«å ä½ç¬¦ï¼Œåˆ™è§¦å‘ AI åˆ†æ\r\n    if (enableAI && data?.annotation) {\r\n      const keyPoints = data.annotation.keyPoints || [];\r\n      const hasPlaceholder = keyPoints.some((kp: string) =>\r\n        kp.includes('å¾… AI åˆ†æ') || kp.includes('åˆ†æä¸­')\r\n      );\r\n\r\n      if (hasPlaceholder) {\r\n        console.log(`[Onion API] æ£€æµ‹åˆ°å ä½ç¬¦ï¼Œè§¦å‘ AI åˆ†æ: layer=${layer}`);\r\n\r\n        try {\r\n          const targetType = layer === OnionLayer.PROJECT_INTENT ? 'project'\r\n            : layer === OnionLayer.BUSINESS_DOMAIN ? 'module'\r\n            : layer === OnionLayer.KEY_PROCESS ? 'process'\r\n            : 'file';\r\n\r\n          const aiAnnotation = await generateAIAnnotation(\r\n            targetType,\r\n            data.annotation.targetId || 'project',\r\n            { projectRoot }\r\n          );\r\n\r\n          // ç”¨ AI åˆ†æç»“æœæ›´æ–° annotation\r\n          data.annotation = {\r\n            ...data.annotation,\r\n            summary: aiAnnotation.summary,\r\n            description: aiAnnotation.description,\r\n            keyPoints: aiAnnotation.keyPoints,\r\n            confidence: aiAnnotation.confidence,\r\n            analyzedAt: aiAnnotation.analyzedAt,\r\n          };\r\n\r\n          console.log(`[Onion API] AI åˆ†æå®Œæˆï¼Œå…³é”®ç‚¹: ${aiAnnotation.keyPoints.length} ä¸ª`);\r\n        } catch (aiError: any) {\r\n          console.error('[Onion API] AI åˆ†æå¤±è´¥ï¼Œä¿æŒåŸæœ‰æ•°æ®:', aiError.message);\r\n          // AI åˆ†æå¤±è´¥ä¸å½±å“è¿”å›æ•°æ®ï¼Œä¿æŒåŸæœ‰å ä½ç¬¦\r\n        }\r\n      }\r\n    }\r\n\r\n    const analysisTime = Date.now() - startTime;\r\n\r\n    res.json({\r\n      success: true,\r\n      layer,\r\n      data,\r\n      analysisTime,\r\n      fromCache: false, // TODO: ä»åˆ†æå™¨è¿”å›ç¼“å­˜çŠ¶æ€\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[Onion API] å±‚çº§æ•°æ®è·å–é”™è¯¯:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: error.message,\r\n    });\r\n  }\r\n});\r\n\r\n/**\r\n * è§¦å‘ AI åˆ†æç”Ÿæˆè¯­ä¹‰æ ‡æ³¨\r\n * POST /api/blueprint/onion/analyze\r\n *\r\n * è¯·æ±‚ä½“:\r\n * {\r\n *   targetType: 'project' | 'module' | 'file' | 'symbol' | 'process',\r\n *   targetId: string,\r\n *   context?: { projectName, relatedModules }\r\n * }\r\n */\r\nrouter.post('/onion/analyze', async (req: Request, res: Response) => {\r\n  try {\r\n    const { targetType, targetId, context } = req.body;\r\n\r\n    if (!targetType || !targetId) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: 'éœ€è¦æä¾› targetType å’Œ targetId',\r\n      });\r\n    }\r\n\r\n    const annotation = await generateAIAnnotation(targetType, targetId, context);\r\n\r\n    res.json({\r\n      success: true,\r\n      annotation,\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[Onion API] AI åˆ†æé”™è¯¯:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: error.message,\r\n    });\r\n  }\r\n});\r\n\r\n/**\r\n * è·å–ç‰¹å®šæµç¨‹çš„è¯¦ç»†æ­¥éª¤\r\n * GET /api/blueprint/onion/process-flow/:processId\r\n */\r\nrouter.get('/onion/process-flow/:processId', async (req: Request, res: Response) => {\r\n  try {\r\n    const { processId } = req.params;\r\n    const projectRoot = process.cwd();\r\n\r\n    // è·å–æ‰€æœ‰æµç¨‹æ•°æ®\r\n    const processData = await analyzeKeyProcesses(projectRoot);\r\n\r\n    // æŸ¥æ‰¾æŒ‡å®šæµç¨‹\r\n    const targetProcess = processData.processes.find(p => p.id === processId);\r\n\r\n    if (!targetProcess) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        error: 'æµç¨‹æœªæ‰¾åˆ°',\r\n      });\r\n    }\r\n\r\n    res.json({\r\n      success: true,\r\n      data: targetProcess,\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[Onion API] æµç¨‹è¯¦æƒ…è·å–é”™è¯¯:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: error.message,\r\n    });\r\n  }\r\n});\r\n\r\n/**\r\n * ç”¨æˆ·ä¿®æ”¹è¯­ä¹‰æ ‡æ³¨\r\n * PUT /api/blueprint/onion/annotation/:annotationId\r\n *\r\n * è¯·æ±‚ä½“:\r\n * {\r\n *   summary?: string,\r\n *   description?: string,\r\n *   keyPoints?: string[]\r\n * }\r\n */\r\nrouter.put('/onion/annotation/:annotationId', async (req: Request, res: Response) => {\r\n  try {\r\n    const { annotationId } = req.params;\r\n    const { summary, description, keyPoints } = req.body;\r\n\r\n    // TODO: å®ç°æ ‡æ³¨æ›´æ–°å’ŒæŒä¹…åŒ–\r\n    // ç›®å‰è¿”å›æ¨¡æ‹ŸæˆåŠŸ\r\n\r\n    res.json({\r\n      success: true,\r\n      message: 'æ ‡æ³¨å·²æ›´æ–°',\r\n      annotationId,\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[Onion API] æ ‡æ³¨æ›´æ–°é”™è¯¯:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: error.message,\r\n    });\r\n  }\r\n});\r\n\r\n// ============================================================================\r\n// ç¬¦å·è¯­ä¹‰åˆ†æ API\r\n// ============================================================================\r\n\r\n/**\r\n * ç¬¦å·åˆ†æç¼“å­˜\r\n * key: filePath:symbolName:line\r\n * åŸºäºæ–‡ä»¶ä¿®æ”¹æ—¶é—´åˆ¤æ–­ç¼“å­˜æ˜¯å¦æœ‰æ•ˆ\r\n */\r\nconst symbolAnalysisCache = new Map<string, {\r\n  data: any;\r\n  fileMtime: number; // æ–‡ä»¶ä¿®æ”¹æ—¶é—´\r\n}>();\r\n\r\n/**\r\n * åˆ†æä»£ç ç¬¦å·ï¼ˆå‡½æ•°ã€ç±»ã€æ–¹æ³•ç­‰ï¼‰\r\n * è¿”å›è¯­ä¹‰æè¿°ã€è°ƒç”¨é“¾ã€å‚æ•°è¯´æ˜ç­‰ä¿¡æ¯\r\n */\r\nrouter.post('/analyze-symbol', async (req: Request, res: Response) => {\r\n  try {\r\n    const { filePath, symbolName, symbolKind, lineNumber, detail } = req.body;\r\n\r\n    if (!filePath || !symbolName) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: 'ç¼ºå°‘å¿…è¦å‚æ•°: filePath, symbolName',\r\n      });\r\n    }\r\n\r\n    const absolutePath = path.resolve(process.cwd(), filePath);\r\n\r\n    // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨\r\n    if (!fs.existsSync(absolutePath)) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        error: `æ–‡ä»¶ä¸å­˜åœ¨: ${filePath}`,\r\n      });\r\n    }\r\n\r\n    // è·å–æ–‡ä»¶ä¿®æ”¹æ—¶é—´\r\n    const stats = fs.statSync(absolutePath);\r\n    const currentMtime = stats.mtimeMs;\r\n\r\n    // æ£€æŸ¥ç¼“å­˜ï¼ˆåŸºäºæ–‡ä»¶ä¿®æ”¹æ—¶é—´ï¼‰\r\n    const cacheKey = `${filePath}:${symbolName}:${lineNumber || 0}`;\r\n    const cached = symbolAnalysisCache.get(cacheKey);\r\n    if (cached && cached.fileMtime === currentMtime) {\r\n      console.log(`[Analyze Symbol] ä½¿ç”¨ç¼“å­˜ (æ–‡ä»¶æœªå˜åŒ–): ${symbolName} @ ${filePath}`);\r\n      return res.json({\r\n        success: true,\r\n        data: { ...cached.data, fromCache: true },\r\n      });\r\n    }\r\n\r\n    // å¦‚æœæ–‡ä»¶å·²ä¿®æ”¹ï¼Œæ¸…é™¤æ—§ç¼“å­˜\r\n    if (cached) {\r\n      console.log(`[Analyze Symbol] æ–‡ä»¶å·²ä¿®æ”¹ï¼Œæ¸…é™¤æ—§ç¼“å­˜: ${symbolName} @ ${filePath}`);\r\n    }\r\n\r\n    const totalStart = Date.now();\r\n    console.log(`[Analyze Symbol] å¼€å§‹åˆ†æç¬¦å·: ${symbolName} (${symbolKind}) @ ${filePath}:${lineNumber}`);\r\n\r\n    // è¯»å–æ–‡ä»¶å†…å®¹\r\n    let t1 = Date.now();\r\n    const fileContent = fs.readFileSync(absolutePath, 'utf-8');\r\n    const lines = fileContent.split('\\n');\r\n    console.log(`[Analyze Symbol] è¯»å–æ–‡ä»¶è€—æ—¶: ${Date.now() - t1}ms`);\r\n\r\n    // æå–ç¬¦å·ä¸Šä¸‹æ–‡ï¼ˆç¬¦å·å®šä¹‰å‰åçš„ä»£ç ï¼Œå‡å°‘ä¸Šä¸‹æ–‡åŠ é€Ÿ AI åˆ†æï¼‰\r\n    const targetLine = lineNumber ? lineNumber - 1 : 0;\r\n    const contextStart = Math.max(0, targetLine - 3);\r\n    const contextEnd = Math.min(lines.length, targetLine + 50); // ä» 50 å‡åˆ° 20 è¡Œ\r\n    const symbolContext = lines.slice(contextStart, contextEnd).join('\\n');\r\n\r\n    // åˆ†ææ–‡ä»¶å†…è°ƒç”¨å…³ç³»\r\n    t1 = Date.now();\r\n    const internalCalls = analyzeInternalCalls(fileContent, symbolName, symbolKind);\r\n    console.log(`[Analyze Symbol] analyzeInternalCalls è€—æ—¶: ${Date.now() - t1}ms`);\r\n\r\n    // åˆ†æè·¨æ–‡ä»¶è°ƒç”¨å…³ç³»\r\n    t1 = Date.now();\r\n    const externalReferences = analyzeExternalReferences(filePath, symbolName);\r\n    console.log(`[Analyze Symbol] analyzeExternalReferences è€—æ—¶: ${Date.now() - t1}ms, æ‰¾åˆ° ${externalReferences.length} ä¸ªå¼•ç”¨`);\r\n\r\n    // è·å– AI å®¢æˆ·ç«¯ - ä½¿ç”¨ Haiku æ¨¡å‹åŠ é€Ÿç®€å•åˆ†æ\r\n    const { ClaudeClient } = await import('../../../core/client.js');\r\n    const client = new ClaudeClient({ model: 'haiku' });\r\n\r\n    // æ„å»ºåˆ†ææç¤º\r\n    const prompt = `è¯·åˆ†æä»¥ä¸‹ä»£ç ç¬¦å·å¹¶ç”Ÿæˆè¯­ä¹‰åˆ†ææŠ¥å‘Šã€‚\r\n\r\n## ç¬¦å·ä¿¡æ¯\r\n- åç§°: ${symbolName}\r\n- ç±»å‹: ${symbolKind}\r\n- æ–‡ä»¶: ${filePath}\r\n- è¡Œå·: ${lineNumber || 'æœªçŸ¥'}\r\n${detail ? `- ç±»å‹ç­¾å: ${detail}` : ''}\r\n\r\n## ç¬¦å·ä»£ç ä¸Šä¸‹æ–‡\r\n\\`\\`\\`\r\n${symbolContext}\r\n\\`\\`\\`\r\n\r\n## æ–‡ä»¶å†…è°ƒç”¨å…³ç³»\r\n- è¢«è°ƒç”¨ä½ç½®: ${internalCalls.calledBy.length > 0 ? internalCalls.calledBy.map(c => `ç¬¬${c.line}è¡Œ ${c.caller}`).join(', ') : 'æ— '}\r\n- è°ƒç”¨çš„ç¬¦å·: ${internalCalls.calls.length > 0 ? internalCalls.calls.join(', ') : 'æ— '}\r\n\r\n## è·¨æ–‡ä»¶å¼•ç”¨\r\n${externalReferences.length > 0 ? externalReferences.map(r => `- ${r.file}: ${r.imports.join(', ')}`).join('\\n') : 'æ— å¤–éƒ¨å¼•ç”¨'}\r\n\r\nè¯·è¿”å›ä»¥ä¸‹ JSON æ ¼å¼çš„åˆ†æç»“æœï¼ˆåªè¿”å› JSONï¼Œä¸è¦å…¶ä»–å†…å®¹ï¼‰ï¼š\r\n{\r\n  \"semanticDescription\": \"è¿™ä¸ª${symbolKind === 'function' || symbolKind === 'method' ? 'å‡½æ•°/æ–¹æ³•' : symbolKind === 'class' ? 'ç±»' : 'ç¬¦å·'}çš„æ ¸å¿ƒåŠŸèƒ½æ˜¯ä»€ä¹ˆï¼Œç”¨é€šä¿—æ˜“æ‡‚çš„è¯­è¨€æè¿°ï¼Œè®©æ–°æ‰‹ä¹Ÿèƒ½ç†è§£\",\r\n  \"purpose\": \"è¿™ä¸ªç¬¦å·å­˜åœ¨çš„ç›®çš„å’Œè§£å†³çš„é—®é¢˜\",\r\n  \"parameters\": [{\"name\": \"å‚æ•°å\", \"type\": \"ç±»å‹\", \"description\": \"å‚æ•°ä½œç”¨è¯´æ˜\"}],\r\n  \"returnValue\": {\"type\": \"è¿”å›ç±»å‹\", \"description\": \"è¿”å›å€¼è¯´æ˜\"},\r\n  \"usageExample\": \"ä¸€ä¸ªç®€çŸ­çš„ä½¿ç”¨ç¤ºä¾‹ä»£ç \",\r\n  \"relatedConcepts\": [\"ç›¸å…³çš„ç¼–ç¨‹æ¦‚å¿µæˆ–è®¾è®¡æ¨¡å¼\"],\r\n  \"complexity\": \"low|medium|high\",\r\n  \"tips\": [\"ç»™æ–°æ‰‹çš„ä½¿ç”¨æç¤º\"]\r\n}`;\r\n\r\n    // è°ƒç”¨ AI åˆ†æ\r\n    t1 = Date.now();\r\n    console.log(`[Analyze Symbol] å¼€å§‹è°ƒç”¨ AI...`);\r\n    const response = await client.createMessage(\r\n      [{ role: 'user', content: prompt }],\r\n      undefined,\r\n      'ä½ æ˜¯ä¸€ä¸ªä»£ç æ•™è‚²ä¸“å®¶ï¼Œæ“…é•¿ç”¨é€šä¿—æ˜“æ‡‚çš„è¯­è¨€è§£é‡Šå¤æ‚çš„ä»£ç ã€‚åˆ†æä»£ç ç¬¦å·å¹¶è¿”å›ç»“æ„åŒ–çš„ JSON ç»“æœã€‚åªè¿”å› JSONï¼Œä¸è¦å…¶ä»–å†…å®¹ã€‚'\r\n    );\r\n    console.log(`[Analyze Symbol] AI è°ƒç”¨è€—æ—¶: ${Date.now() - t1}ms`);\r\n\r\n    // æå–å“åº”æ–‡æœ¬\r\n    let analysisText = '';\r\n    for (const block of response.content) {\r\n      if (block.type === 'text') {\r\n        analysisText += block.text;\r\n      }\r\n    }\r\n\r\n    // è§£æ JSON\r\n    let analysis: Record<string, any>;\r\n    try {\r\n      analysis = JSON.parse(analysisText.trim());\r\n    } catch {\r\n      const jsonMatch = analysisText.match(/```json\\s*([\\s\\S]*?)\\s*```/);\r\n      if (jsonMatch) {\r\n        analysis = JSON.parse(jsonMatch[1]);\r\n      } else {\r\n        const bareJsonMatch = analysisText.match(/\\{[\\s\\S]*\\}/);\r\n        if (bareJsonMatch) {\r\n          analysis = JSON.parse(bareJsonMatch[0]);\r\n        } else {\r\n          throw new Error(`æ— æ³•è§£æ AI è¿”å›çš„ JSON`);\r\n        }\r\n      }\r\n    }\r\n\r\n    // ç»„è£…å®Œæ•´ç»“æœ\r\n    const result = {\r\n      symbolName,\r\n      symbolKind,\r\n      filePath,\r\n      lineNumber,\r\n      detail,\r\n      ...analysis,\r\n      internalCalls,\r\n      externalReferences,\r\n      analyzedAt: new Date().toISOString(),\r\n    };\r\n\r\n    // ä¿å­˜åˆ°ç¼“å­˜\r\n    symbolAnalysisCache.set(cacheKey, {\r\n      data: result,\r\n      fileMtime: currentMtime, // ä½¿ç”¨æ–‡ä»¶ä¿®æ”¹æ—¶é—´ä½œä¸ºç¼“å­˜ä¾æ®\r\n    });\r\n\r\n    console.log(`[Analyze Symbol] åˆ†æå®Œæˆ: ${symbolName}, æ€»è€—æ—¶: ${Date.now() - totalStart}ms`);\r\n\r\n    res.json({\r\n      success: true,\r\n      data: { ...result, fromCache: false },\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[Analyze Symbol Error]', error);\r\n    res.status(500).json({ success: false, error: error.message });\r\n  }\r\n});\r\n\r\n/**\r\n * åˆ†ææ–‡ä»¶å†…è°ƒç”¨å…³ç³»\r\n */\r\nfunction analyzeInternalCalls(fileContent: string, symbolName: string, symbolKind: string): {\r\n  calledBy: Array<{ line: number; caller: string }>;\r\n  calls: string[];\r\n} {\r\n  const lines = fileContent.split('\\n');\r\n  const calledBy: Array<{ line: number; caller: string }> = [];\r\n  const calls: string[] = [];\r\n\r\n  // ç®€å•çš„æ­£åˆ™åŒ¹é…æ¥æ‰¾è°ƒç”¨å…³ç³»\r\n  const callPattern = new RegExp(`\\\\b${symbolName}\\\\s*\\\\(`, 'g');\r\n\r\n  // æ‰¾åˆ°å½“å‰ç¬¦å·è¢«è°ƒç”¨çš„ä½ç½®\r\n  let currentFunction = '';\r\n  for (let i = 0; i < lines.length; i++) {\r\n    const line = lines[i];\r\n\r\n    // æ£€æµ‹å‡½æ•°/æ–¹æ³•å®šä¹‰ï¼ˆç®€åŒ–ç‰ˆï¼‰\r\n    const funcMatch = line.match(/(?:function|const|let|var)\\s+(\\w+)|(\\w+)\\s*[=:]\\s*(?:async\\s*)?\\(|(\\w+)\\s*\\(/);\r\n    if (funcMatch) {\r\n      currentFunction = funcMatch[1] || funcMatch[2] || funcMatch[3] || '';\r\n    }\r\n\r\n    // æ£€æµ‹å¯¹ç›®æ ‡ç¬¦å·çš„è°ƒç”¨\r\n    if (callPattern.test(line) && currentFunction !== symbolName) {\r\n      calledBy.push({ line: i + 1, caller: currentFunction || 'é¡¶å±‚ä»£ç ' });\r\n    }\r\n    callPattern.lastIndex = 0; // é‡ç½®æ­£åˆ™\r\n  }\r\n\r\n  // å¦‚æœæ˜¯å‡½æ•°/æ–¹æ³•ï¼Œåˆ†æå®ƒè°ƒç”¨äº†å“ªäº›å…¶ä»–ç¬¦å·\r\n  if (symbolKind === 'function' || symbolKind === 'method') {\r\n    // ç®€å•æå–å‡½æ•°ä½“ä¸­çš„è°ƒç”¨\r\n    const funcCallPattern = /(\\w+)\\s*\\(/g;\r\n    let match;\r\n    while ((match = funcCallPattern.exec(fileContent)) !== null) {\r\n      const calledFunc = match[1];\r\n      // æ’é™¤å¸¸è§çš„å…³é”®å­—å’Œè‡ªèº«\r\n      if (!['if', 'for', 'while', 'switch', 'catch', 'function', 'return', symbolName].includes(calledFunc)) {\r\n        if (!calls.includes(calledFunc)) {\r\n          calls.push(calledFunc);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return { calledBy: calledBy.slice(0, 10), calls: calls.slice(0, 10) };\r\n}\r\n\r\n/**\r\n * åˆ†æè·¨æ–‡ä»¶å¼•ç”¨\r\n */\r\nfunction analyzeExternalReferences(filePath: string, symbolName: string): Array<{ file: string; imports: string[] }> {\r\n  const references: Array<{ file: string; imports: string[] }> = [];\r\n\r\n  try {\r\n    // è·å– src ç›®å½•ä¸‹çš„æ‰€æœ‰ ts/tsx/js/jsx æ–‡ä»¶\r\n    const srcDir = path.resolve(process.cwd(), 'src');\r\n    if (!fs.existsSync(srcDir)) {\r\n      return references;\r\n    }\r\n\r\n    const walkDir = (dir: string, files: string[] = []): string[] => {\r\n      const entries = fs.readdirSync(dir, { withFileTypes: true });\r\n      for (const entry of entries) {\r\n        if (entry.name.startsWith('.') || entry.name === 'node_modules') continue;\r\n        const fullPath = path.join(dir, entry.name);\r\n        if (entry.isDirectory()) {\r\n          walkDir(fullPath, files);\r\n        } else if (/\\.(ts|tsx|js|jsx)$/.test(entry.name)) {\r\n          files.push(fullPath);\r\n        }\r\n      }\r\n      return files;\r\n    };\r\n\r\n    const files = walkDir(srcDir).slice(0, 200); // é™åˆ¶æ‰«ææ–‡ä»¶æ•°é‡\r\n    const targetFileName = path.basename(filePath, path.extname(filePath));\r\n\r\n    for (const file of files) {\r\n      if (file === path.resolve(process.cwd(), filePath)) continue;\r\n\r\n      try {\r\n        const content = fs.readFileSync(file, 'utf-8');\r\n\r\n        // æ£€æŸ¥æ˜¯å¦ import äº†ç›®æ ‡æ–‡ä»¶\r\n        const importPattern = new RegExp(`import\\\\s+.*from\\\\s+['\"]\\\\..*${targetFileName}['\"]`, 'g');\r\n        if (importPattern.test(content)) {\r\n          // æ£€æŸ¥æ˜¯å¦ä½¿ç”¨äº†ç›®æ ‡ç¬¦å·\r\n          const usePattern = new RegExp(`\\\\b${symbolName}\\\\b`, 'g');\r\n          if (usePattern.test(content)) {\r\n            const relativePath = path.relative(process.cwd(), file);\r\n            references.push({\r\n              file: relativePath,\r\n              imports: [symbolName],\r\n            });\r\n          }\r\n        }\r\n      } catch {\r\n        // å¿½ç•¥è¯»å–é”™è¯¯\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.error('[Analyze External References]', error);\r\n  }\r\n\r\n  return references.slice(0, 5); // æœ€å¤šè¿”å› 5 ä¸ªå¼•ç”¨\r\n}\r\n\r\nexport default router;\r\n"
        }
    ]
}