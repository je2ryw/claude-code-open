import React, { useMemo, useRef, useCallback, useEffect } from 'react';
import { VariableSizeList } from 'react-window';
import type { TreeNode, NodeType } from './index';
import styles from './TreeView.module.css';

interface VirtualizedTreeViewProps<T extends TreeNode> {
  data: T[];
  dataType: NodeType;
  onSelect?: (node: T) => void;
  selectedId?: string;
  renderNode?: (node: T) => React.ReactNode;
  height?: number;  // å®¹å™¨é«˜åº¦
  baseItemHeight?: number;  // åŸºç¡€é¡¹é«˜åº¦
  expandedIds: Set<string>;  // å¤–éƒ¨ä¼ å…¥çš„å±•å¼€çŠ¶æ€
  onToggleExpand: (id: string) => void;  // å±•å¼€/æŠ˜å å›è°ƒ
}

// æ‰å¹³åŒ–èŠ‚ç‚¹ç»“æ„
interface FlatNode<T extends TreeNode> {
  node: T;
  level: number;
  hasChildren: boolean;
  isExpanded: boolean;
}

export function VirtualizedTreeView<T extends TreeNode>({
  data,
  dataType,
  onSelect,
  selectedId,
  renderNode,
  height = 600,
  baseItemHeight = 32,
  expandedIds,
  onToggleExpand
}: VirtualizedTreeViewProps<T>) {
  const listRef = useRef<VariableSizeList>(null);
  const rowHeights = useRef<{ [key: number]: number }>({});

  // æ‰å¹³åŒ–æ ‘å½¢ç»“æ„
  const flattenedNodes = useMemo(() => {
    const result: FlatNode<T>[] = [];

    const flatten = (nodes: T[], level: number = 0) => {
      for (const node of nodes) {
        const hasChildren = Boolean(node.children && node.children.length > 0);
        const isExpanded = expandedIds.has(node.id);

        result.push({
          node,
          level,
          hasChildren,
          isExpanded
        });

        if (hasChildren && isExpanded) {
          flatten(node.children as T[], level + 1);
        }
      }
    };

    flatten(data);
    return result;
  }, [data, expandedIds]);

  // è®¡ç®—è¡Œé«˜ï¼ˆæ ¹æ®èŠ‚ç‚¹å†…å®¹åŠ¨æ€è°ƒæ•´ï¼‰
  const getItemSize = useCallback((index: number) => {
    // å¦‚æœæœ‰ç¼“å­˜çš„é«˜åº¦ï¼Œä½¿ç”¨ç¼“å­˜
    if (rowHeights.current[index]) {
      return rowHeights.current[index];
    }

    const flatNode = flattenedNodes[index];
    if (!flatNode) {
      return baseItemHeight;
    }

    // æ ¹æ®èŠ‚ç‚¹ç±»å‹å’Œå†…å®¹ä¼°ç®—é«˜åº¦
    let estimatedHeight = baseItemHeight;

    // å¦‚æœæ˜¯ç¬¦å·èŠ‚ç‚¹ä¸”æœ‰ç­¾åï¼Œå¢åŠ é«˜åº¦
    if (dataType === 'symbol' && (flatNode.node as any).signature) {
      estimatedHeight += 20;
    }

    rowHeights.current[index] = estimatedHeight;
    return estimatedHeight;
  }, [flattenedNodes, baseItemHeight, dataType]);

  // å½“æ‰å¹³åŒ–èŠ‚ç‚¹å˜åŒ–æ—¶ï¼Œé‡ç½®é«˜åº¦ç¼“å­˜
  useEffect(() => {
    rowHeights.current = {};
    listRef.current?.resetAfterIndex(0);
  }, [flattenedNodes]);

  // æ¸²æŸ“å•ä¸ªè¡Œ
  const Row = useCallback(({ index, style }: { index: number; style: React.CSSProperties }) => {
    const flatNode = flattenedNodes[index];
    if (!flatNode) {
      return null;
    }

    const { node, level, hasChildren, isExpanded } = flatNode;
    const isSelected = node.id === selectedId;

    return (
      <div
        style={{
          ...style,
          paddingLeft: `${level * 20}px`
        }}
        className={`${styles.treeNode} ${isSelected ? styles.selected : ''}`}
        onClick={() => onSelect?.(node)}
      >
        {/* å±•å¼€/æŠ˜å æŒ‰é’® */}
        <span
          className={`${styles.expandIcon} ${!hasChildren ? styles.noChildren : ''}`}
          onClick={(e) => {
            e.stopPropagation();
            if (hasChildren) {
              onToggleExpand(node.id);
            }
          }}
        >
          {hasChildren ? (isExpanded ? 'â–¼' : 'â–¶') : ''}
        </span>

        {/* èŠ‚ç‚¹å†…å®¹ */}
        {renderNode ? (
          renderNode(node)
        ) : (
          <DefaultNodeRenderer node={node} dataType={dataType} />
        )}
      </div>
    );
  }, [flattenedNodes, selectedId, onSelect, renderNode, dataType, onToggleExpand]);

  return (
    <div className={styles.virtualList}>
      <VariableSizeList
        ref={listRef}
        height={height}
        itemCount={flattenedNodes.length}
        itemSize={getItemSize}
        width="100%"
        overscanCount={5}  // é¢„æ¸²æŸ“5ä¸ªå…ƒç´ ï¼Œæå‡æ»šåŠ¨ä½“éªŒ
      >
        {Row}
      </VariableSizeList>
    </div>
  );
}

// é»˜è®¤èŠ‚ç‚¹æ¸²æŸ“å™¨ï¼ˆä¸ TreeView å…±ç”¨é€»è¾‘ï¼‰
function DefaultNodeRenderer({ node, dataType }: { node: TreeNode; dataType: NodeType }) {
  const icon = getNodeIcon(node, dataType);

  return (
    <div className={styles.nodeContent}>
      <span className={styles.nodeIcon}>{icon}</span>
      <span className={styles.nodeName}>{node.name}</span>
    </div>
  );
}

function getNodeIcon(node: TreeNode, dataType: NodeType): string {
  if (dataType === 'file') {
    return node.children && node.children.length > 0 ? 'ğŸ“' : 'ğŸ“„';
  }

  if (dataType === 'symbol') {
    const type = (node as any).type || 'unknown';
    const iconMap: Record<string, string> = {
      'function': 'ğŸ”¹',
      'method': 'âš¡',
      'class': 'ğŸ”¸',
      'interface': 'ğŸ“',
      'type': 'ğŸ“‹',
      'property': 'ğŸ”¹',
      'variable': 'ğŸ“¦',
      'const': 'ğŸ”’',
      'module': 'ğŸ“¦',
    };
    return iconMap[type] || 'â“';
  }

  if (dataType === 'task') {
    const status = (node as any).status;
    if (status === 'completed' || status === 'passed') return 'âœ…';
    if (status === 'in_progress' || status === 'coding' || status === 'testing') return 'â³';
    if (status === 'failed' || status === 'test_failed') return 'âŒ';
    return 'â¬œ';
  }

  return 'ğŸ“„';
}
