<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>è“å›¾ç³»ç»Ÿä»ªè¡¨æ¿ | Claude Code</title>
  <style>
    :root {
      --bg-primary: #1a1b26;
      --bg-secondary: #24283b;
      --bg-tertiary: #414868;
      --text-primary: #c0caf5;
      --text-secondary: #a9b1d6;
      --accent-blue: #7aa2f7;
      --accent-green: #9ece6a;
      --accent-red: #f7768e;
      --accent-yellow: #e0af68;
      --accent-purple: #bb9af7;
      --border-color: #414868;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'SF Mono', 'Consolas', 'Monaco', monospace;
      background: var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
    }

    .container {
      max-width: 1600px;
      margin: 0 auto;
      padding: 20px;
    }

    /* å¤´éƒ¨ */
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px 0;
      border-bottom: 1px solid var(--border-color);
      margin-bottom: 20px;
    }

    .header h1 {
      font-size: 24px;
      color: var(--accent-blue);
    }

    .header-actions {
      display: flex;
      gap: 10px;
    }

    .btn {
      padding: 8px 16px;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      font-size: 14px;
      font-family: inherit;
      transition: all 0.2s;
    }

    .btn-primary {
      background: var(--accent-blue);
      color: var(--bg-primary);
    }

    .btn-success {
      background: var(--accent-green);
      color: var(--bg-primary);
    }

    .btn-danger {
      background: var(--accent-red);
      color: var(--bg-primary);
    }

    .btn:hover {
      opacity: 0.8;
    }

    /* ç»Ÿè®¡å¡ç‰‡ */
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }

    .stat-card {
      background: var(--bg-secondary);
      padding: 20px;
      border-radius: 8px;
      border: 1px solid var(--border-color);
    }

    .stat-card h3 {
      font-size: 12px;
      color: var(--text-secondary);
      margin-bottom: 8px;
      text-transform: uppercase;
    }

    .stat-card .value {
      font-size: 32px;
      font-weight: bold;
    }

    .stat-card .value.blue { color: var(--accent-blue); }
    .stat-card .value.green { color: var(--accent-green); }
    .stat-card .value.red { color: var(--accent-red); }
    .stat-card .value.yellow { color: var(--accent-yellow); }
    .stat-card .value.purple { color: var(--accent-purple); }

    /* ä¸»å†…å®¹åŒº */
    .main-grid {
      display: grid;
      grid-template-columns: 350px 1fr 300px;
      gap: 20px;
    }

    @media (max-width: 1200px) {
      .main-grid {
        grid-template-columns: 1fr;
      }
    }

    /* é¢æ¿ */
    .panel {
      background: var(--bg-secondary);
      border-radius: 8px;
      border: 1px solid var(--border-color);
      overflow: hidden;
    }

    .panel-header {
      padding: 15px 20px;
      background: var(--bg-tertiary);
      border-bottom: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .panel-header h2 {
      font-size: 14px;
      font-weight: 600;
    }

    .panel-body {
      padding: 15px 20px;
      max-height: 600px;
      overflow-y: auto;
    }

    /* ä»»åŠ¡æ ‘ */
    .task-tree {
      font-size: 13px;
    }

    .tree-node {
      margin-left: 20px;
      padding: 5px 0;
    }

    .tree-node.root {
      margin-left: 0;
    }

    .node-content {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .node-content:hover {
      background: var(--bg-tertiary);
    }

    .node-icon {
      width: 20px;
      text-align: center;
    }

    .node-name {
      flex: 1;
    }

    .node-status {
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 11px;
      text-transform: uppercase;
    }

    .status-pending { background: var(--bg-tertiary); color: var(--text-secondary); }
    .status-coding { background: var(--accent-blue); color: var(--bg-primary); }
    .status-testing { background: var(--accent-yellow); color: var(--bg-primary); }
    .status-passed { background: var(--accent-green); color: var(--bg-primary); }
    .status-failed { background: var(--accent-red); color: var(--bg-primary); }

    /* æ—¶é—´çº¿ */
    .timeline {
      position: relative;
    }

    .timeline::before {
      content: '';
      position: absolute;
      left: 10px;
      top: 0;
      bottom: 0;
      width: 2px;
      background: var(--border-color);
    }

    .timeline-item {
      position: relative;
      padding-left: 35px;
      padding-bottom: 15px;
    }

    .timeline-item::before {
      content: '';
      position: absolute;
      left: 5px;
      top: 5px;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: var(--accent-blue);
      border: 2px solid var(--bg-secondary);
    }

    .timeline-item.checkpoint::before {
      background: var(--accent-purple);
    }

    .timeline-item.error::before {
      background: var(--accent-red);
    }

    .timeline-item.success::before {
      background: var(--accent-green);
    }

    .timeline-time {
      font-size: 11px;
      color: var(--text-secondary);
      margin-bottom: 4px;
    }

    .timeline-content {
      font-size: 13px;
    }

    /* Worker åˆ—è¡¨ */
    .worker-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .worker-card {
      background: var(--bg-tertiary);
      padding: 12px;
      border-radius: 6px;
    }

    .worker-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .worker-id {
      font-size: 12px;
      color: var(--accent-purple);
    }

    .worker-status {
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 3px;
    }

    .worker-task {
      font-size: 13px;
      margin-bottom: 8px;
    }

    .worker-progress {
      height: 4px;
      background: var(--bg-primary);
      border-radius: 2px;
      overflow: hidden;
    }

    .worker-progress-bar {
      height: 100%;
      background: var(--accent-green);
      transition: width 0.3s;
    }

    /* TDD å¾ªç¯æŒ‡ç¤ºå™¨ */
    .tdd-cycle {
      display: flex;
      justify-content: space-around;
      padding: 20px;
      background: var(--bg-tertiary);
      border-radius: 8px;
      margin-bottom: 15px;
    }

    .tdd-phase {
      display: flex;
      flex-direction: column;
      align-items: center;
      opacity: 0.5;
    }

    .tdd-phase.active {
      opacity: 1;
    }

    .tdd-phase-icon {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      margin-bottom: 8px;
      background: var(--bg-secondary);
    }

    .tdd-phase.active .tdd-phase-icon {
      background: var(--accent-blue);
    }

    .tdd-phase.completed .tdd-phase-icon {
      background: var(--accent-green);
    }

    .tdd-phase-name {
      font-size: 11px;
      text-align: center;
    }

    /* æ£€æŸ¥ç‚¹åˆ—è¡¨ */
    .checkpoint-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .checkpoint-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px;
      background: var(--bg-tertiary);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .checkpoint-item:hover {
      background: var(--border-color);
    }

    .checkpoint-icon {
      font-size: 18px;
    }

    .checkpoint-info {
      flex: 1;
    }

    .checkpoint-name {
      font-size: 13px;
      margin-bottom: 2px;
    }

    .checkpoint-time {
      font-size: 11px;
      color: var(--text-secondary);
    }

    .checkpoint-action {
      padding: 4px 8px;
      font-size: 11px;
      background: var(--accent-purple);
      color: var(--bg-primary);
      border-radius: 4px;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .checkpoint-item:hover .checkpoint-action {
      opacity: 1;
    }

    /* åŠ è½½åŠ¨ç”» */
    .loading {
      display: flex;
      justify-content: center;
      padding: 40px;
    }

    .spinner {
      width: 30px;
      height: 30px;
      border: 3px solid var(--border-color);
      border-top-color: var(--accent-blue);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* ç©ºçŠ¶æ€ */
    .empty-state {
      text-align: center;
      padding: 40px;
      color: var(--text-secondary);
    }

    .empty-state-icon {
      font-size: 48px;
      margin-bottom: 16px;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- å¤´éƒ¨ -->
    <div class="header">
      <div style="display: flex; align-items: center; gap: 15px;">
        <h1>ğŸ è“å›¾ç³»ç»Ÿä»ªè¡¨æ¿</h1>
        <div class="ws-status">
          <div class="ws-indicator"></div>
          <span id="wsStatusText">æœªè¿æ¥</span>
        </div>
      </div>
      <div class="header-actions">
        <button class="btn" onclick="showBlueprints()">ğŸ“˜ è“å›¾ç®¡ç†</button>
        <button class="btn btn-primary" onclick="refreshData()">ğŸ”„ åˆ·æ–°</button>
        <button class="btn btn-success" id="startBtn" onclick="toggleExecution()">â–¶ï¸ å¼€å§‹æ‰§è¡Œ</button>
        <button class="btn btn-danger" onclick="createCheckpoint()">ğŸ“Œ åˆ›å»ºæ£€æŸ¥ç‚¹</button>
      </div>
    </div>

    <!-- ç»Ÿè®¡å¡ç‰‡ -->
    <div class="stats-grid">
      <div class="stat-card">
        <h3>æ€»ä»»åŠ¡æ•°</h3>
        <div class="value blue" id="totalTasks">--</div>
      </div>
      <div class="stat-card">
        <h3>å·²å®Œæˆ</h3>
        <div class="value green" id="passedTasks">--</div>
      </div>
      <div class="stat-card">
        <h3>æ‰§è¡Œä¸­</h3>
        <div class="value yellow" id="runningTasks">--</div>
      </div>
      <div class="stat-card">
        <h3>å¤±è´¥</h3>
        <div class="value red" id="failedTasks">--</div>
      </div>
      <div class="stat-card">
        <h3>è¿›åº¦</h3>
        <div class="value purple" id="progress">--%</div>
      </div>
      <div class="stat-card">
        <h3>æ´»è·ƒ Worker</h3>
        <div class="value blue" id="activeWorkers">--</div>
      </div>
    </div>

    <!-- ä¸»å†…å®¹åŒº -->
    <div class="main-grid">
      <!-- å·¦ä¾§ï¼šä»»åŠ¡æ ‘ -->
      <div class="panel">
        <div class="panel-header">
          <h2>ğŸŒ³ ä»»åŠ¡æ ‘</h2>
          <span id="treeDepth">æ·±åº¦: --</span>
        </div>
        <div class="panel-body">
          <div class="search-box">
            <span class="search-icon">ğŸ”</span>
            <input type="text" class="search-input" id="taskSearch" placeholder="æœç´¢ä»»åŠ¡..." oninput="filterTasks(this.value)">
          </div>
          <div class="tree-actions" style="display: flex; gap: 8px; margin-bottom: 10px;">
            <button class="btn" style="font-size: 12px; padding: 4px 8px;" onclick="expandAllTasks()">ğŸ“‚ å…¨éƒ¨å±•å¼€</button>
            <button class="btn" style="font-size: 12px; padding: 4px 8px;" onclick="collapseAllTasks()">ğŸ“ å…¨éƒ¨æŠ˜å </button>
          </div>
          <div id="taskTree" class="task-tree">
            <div class="loading"><div class="spinner"></div></div>
          </div>
        </div>
      </div>

      <!-- ä¸­é—´ï¼šä¸»é¢æ¿ -->
      <div>
        <!-- TDD å¾ªç¯çŠ¶æ€ -->
        <div class="panel" style="margin-bottom: 20px;">
          <div class="panel-header">
            <h2>ğŸ”„ TDD å¾ªç¯çŠ¶æ€</h2>
          </div>
          <div class="panel-body">
            <div class="tdd-cycle">
              <div class="tdd-phase" id="phase-write_test">
                <div class="tdd-phase-icon">âœï¸</div>
                <div class="tdd-phase-name">ç¼–å†™æµ‹è¯•</div>
              </div>
              <div class="tdd-phase" id="phase-run_test_red">
                <div class="tdd-phase-icon">ğŸ”´</div>
                <div class="tdd-phase-name">çº¢ç¯</div>
              </div>
              <div class="tdd-phase" id="phase-write_code">
                <div class="tdd-phase-icon">ğŸ’»</div>
                <div class="tdd-phase-name">ç¼–å†™ä»£ç </div>
              </div>
              <div class="tdd-phase" id="phase-run_test_green">
                <div class="tdd-phase-icon">ğŸŸ¢</div>
                <div class="tdd-phase-name">ç»¿ç¯</div>
              </div>
              <div class="tdd-phase" id="phase-refactor">
                <div class="tdd-phase-icon">ğŸ”§</div>
                <div class="tdd-phase-name">é‡æ„</div>
              </div>
            </div>
          </div>
        </div>

        <!-- Worker åˆ—è¡¨ -->
        <div class="panel">
          <div class="panel-header">
            <h2>ğŸ Worker èœœèœ‚ä»¬</h2>
            <span id="workerCount">0 / 5</span>
          </div>
          <div class="panel-body">
            <div id="workerList" class="worker-list">
              <div class="empty-state">
                <div class="empty-state-icon">ğŸ</div>
                <div>æš‚æ— æ´»è·ƒçš„ Worker</div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- å³ä¾§ï¼šæ—¶é—´çº¿å’Œæ£€æŸ¥ç‚¹ -->
      <div>
        <!-- æ—¶é—´çº¿ -->
        <div class="panel" style="margin-bottom: 20px;">
          <div class="panel-header">
            <h2>ğŸ“œ æ—¶é—´çº¿</h2>
          </div>
          <div class="panel-body" style="max-height: 300px;">
            <div id="timeline" class="timeline">
              <div class="loading"><div class="spinner"></div></div>
            </div>
          </div>
        </div>

        <!-- æ£€æŸ¥ç‚¹ -->
        <div class="panel">
          <div class="panel-header">
            <h2>â±ï¸ æ—¶å…‰å€’æµ</h2>
          </div>
          <div class="panel-body">
            <div id="checkpointList" class="checkpoint-list">
              <div class="empty-state">
                <div class="empty-state-icon">ğŸ“Œ</div>
                <div>æš‚æ— æ£€æŸ¥ç‚¹</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Toast é€šçŸ¥å®¹å™¨ -->
  <div id="toastContainer" class="toast-container"></div>

  <!-- ä»»åŠ¡è¯¦æƒ…æ¨¡æ€æ¡† -->
  <div id="taskModal" class="modal" style="display: none;">
    <div class="modal-overlay" onclick="closeModal('taskModal')"></div>
    <div class="modal-content">
      <div class="modal-header">
        <h2>ğŸ“‹ ä»»åŠ¡è¯¦æƒ…</h2>
        <button class="modal-close" onclick="closeModal('taskModal')">Ã—</button>
      </div>
      <div class="modal-body" id="taskModalBody">
        <!-- åŠ¨æ€å†…å®¹ -->
      </div>
      <div class="modal-footer">
        <button class="btn btn-primary" onclick="startTaskTDD()">ğŸš€ å¯åŠ¨ TDD</button>
        <button class="btn" onclick="closeModal('taskModal')">å…³é—­</button>
      </div>
    </div>
  </div>

  <!-- æ£€æŸ¥ç‚¹è¯¦æƒ…/å›æ»šé¢„è§ˆæ¨¡æ€æ¡† -->
  <div id="checkpointModal" class="modal" style="display: none;">
    <div class="modal-overlay" onclick="closeModal('checkpointModal')"></div>
    <div class="modal-content">
      <div class="modal-header">
        <h2>â±ï¸ æ£€æŸ¥ç‚¹è¯¦æƒ…</h2>
        <button class="modal-close" onclick="closeModal('checkpointModal')">Ã—</button>
      </div>
      <div class="modal-body" id="checkpointModalBody">
        <!-- åŠ¨æ€å†…å®¹ -->
      </div>
      <div class="modal-footer">
        <button class="btn btn-danger" id="rollbackBtn" onclick="confirmRollback()">âª ç¡®è®¤å›æ»š</button>
        <button class="btn" onclick="closeModal('checkpointModal')">å…³é—­</button>
      </div>
    </div>
  </div>

  <!-- è“å›¾é€‰æ‹©æ¨¡æ€æ¡† -->
  <div id="blueprintModal" class="modal" style="display: none;">
    <div class="modal-overlay" onclick="closeModal('blueprintModal')"></div>
    <div class="modal-content modal-large">
      <div class="modal-header">
        <h2>ğŸ“˜ è“å›¾ç®¡ç†</h2>
        <button class="modal-close" onclick="closeModal('blueprintModal')">Ã—</button>
      </div>
      <div class="modal-body" id="blueprintModalBody">
        <div class="blueprint-actions" style="margin-bottom: 20px;">
          <button class="btn btn-primary" onclick="analyzeCodebase()">ğŸ” ä¸€é”®åˆ†æä»£ç åº“</button>
          <button class="btn btn-success" onclick="showCreateBlueprint()">â• åˆ›å»ºæ–°è“å›¾</button>
        </div>
        <div id="blueprintList" class="blueprint-list">
          <div class="loading"><div class="spinner"></div></div>
        </div>
      </div>
    </div>
  </div>

  <!-- åˆ›å»ºæ£€æŸ¥ç‚¹æ¨¡æ€æ¡† -->
  <div id="createCheckpointModal" class="modal" style="display: none;">
    <div class="modal-overlay" onclick="closeModal('createCheckpointModal')"></div>
    <div class="modal-content modal-small">
      <div class="modal-header">
        <h2>ğŸ“Œ åˆ›å»ºæ£€æŸ¥ç‚¹</h2>
        <button class="modal-close" onclick="closeModal('createCheckpointModal')">Ã—</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label>æ£€æŸ¥ç‚¹åç§°</label>
          <input type="text" id="checkpointName" class="form-input" placeholder="ä¾‹å¦‚: å®Œæˆç”¨æˆ·è®¤è¯æ¨¡å—">
        </div>
        <div class="form-group">
          <label>æè¿°ï¼ˆå¯é€‰ï¼‰</label>
          <textarea id="checkpointDesc" class="form-textarea" placeholder="æè¿°æ­¤æ£€æŸ¥ç‚¹çš„çŠ¶æ€..."></textarea>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-success" onclick="submitCheckpoint()">âœ… åˆ›å»º</button>
        <button class="btn" onclick="closeModal('createCheckpointModal')">å–æ¶ˆ</button>
      </div>
    </div>
  </div>

  <style>
    /* æ¨¡æ€æ¡†æ ·å¼ */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .modal-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
    }

    .modal-content {
      position: relative;
      background: var(--bg-secondary);
      border-radius: 12px;
      border: 1px solid var(--border-color);
      width: 90%;
      max-width: 600px;
      max-height: 80vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      animation: modalSlideIn 0.2s ease-out;
    }

    .modal-content.modal-large {
      max-width: 900px;
    }

    .modal-content.modal-small {
      max-width: 400px;
    }

    @keyframes modalSlideIn {
      from {
        opacity: 0;
        transform: translateY(-20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 20px;
      background: var(--bg-tertiary);
      border-bottom: 1px solid var(--border-color);
    }

    .modal-header h2 {
      font-size: 16px;
      margin: 0;
    }

    .modal-close {
      background: none;
      border: none;
      color: var(--text-secondary);
      font-size: 24px;
      cursor: pointer;
      padding: 0;
      line-height: 1;
    }

    .modal-close:hover {
      color: var(--text-primary);
    }

    .modal-body {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
    }

    .modal-footer {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      padding: 15px 20px;
      border-top: 1px solid var(--border-color);
    }

    /* Toast é€šçŸ¥æ ·å¼ */
    .toast-container {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 2000;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .toast {
      padding: 12px 20px;
      border-radius: 8px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      color: var(--text-primary);
      font-size: 14px;
      animation: toastSlideIn 0.3s ease-out;
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 250px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    .toast.success {
      border-color: var(--accent-green);
    }

    .toast.error {
      border-color: var(--accent-red);
    }

    .toast.info {
      border-color: var(--accent-blue);
    }

    .toast.warning {
      border-color: var(--accent-yellow);
    }

    @keyframes toastSlideIn {
      from {
        opacity: 0;
        transform: translateX(100%);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    /* è¡¨å•æ ·å¼ */
    .form-group {
      margin-bottom: 15px;
    }

    .form-group label {
      display: block;
      margin-bottom: 6px;
      font-size: 13px;
      color: var(--text-secondary);
    }

    .form-input, .form-textarea {
      width: 100%;
      padding: 10px 12px;
      border-radius: 6px;
      border: 1px solid var(--border-color);
      background: var(--bg-tertiary);
      color: var(--text-primary);
      font-family: inherit;
      font-size: 14px;
    }

    .form-input:focus, .form-textarea:focus {
      outline: none;
      border-color: var(--accent-blue);
    }

    .form-textarea {
      min-height: 80px;
      resize: vertical;
    }

    /* è“å›¾åˆ—è¡¨æ ·å¼ */
    .blueprint-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .blueprint-card {
      background: var(--bg-tertiary);
      border-radius: 8px;
      padding: 15px;
      cursor: pointer;
      transition: all 0.2s;
      border: 1px solid transparent;
    }

    .blueprint-card:hover {
      border-color: var(--accent-blue);
    }

    .blueprint-card.selected {
      border-color: var(--accent-green);
      background: rgba(158, 206, 106, 0.1);
    }

    .blueprint-card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .blueprint-card-title {
      font-size: 15px;
      font-weight: 600;
    }

    .blueprint-card-status {
      font-size: 11px;
      padding: 2px 8px;
      border-radius: 4px;
      text-transform: uppercase;
    }

    .blueprint-card-desc {
      font-size: 13px;
      color: var(--text-secondary);
      margin-bottom: 10px;
    }

    .blueprint-card-meta {
      display: flex;
      gap: 15px;
      font-size: 12px;
      color: var(--text-secondary);
    }

    /* ä»»åŠ¡è¯¦æƒ…æ ·å¼ */
    .task-detail-section {
      margin-bottom: 20px;
    }

    .task-detail-section h3 {
      font-size: 13px;
      color: var(--accent-blue);
      margin-bottom: 10px;
      text-transform: uppercase;
    }

    .task-detail-content {
      background: var(--bg-tertiary);
      padding: 12px;
      border-radius: 6px;
      font-size: 13px;
    }

    .task-detail-row {
      display: flex;
      justify-content: space-between;
      padding: 6px 0;
      border-bottom: 1px solid var(--border-color);
    }

    .task-detail-row:last-child {
      border-bottom: none;
    }

    .task-detail-label {
      color: var(--text-secondary);
    }

    /* å›æ»šé¢„è§ˆæ ·å¼ */
    .rollback-preview {
      background: var(--bg-tertiary);
      border-radius: 8px;
      padding: 15px;
    }

    .rollback-warning {
      color: var(--accent-yellow);
      margin-bottom: 15px;
      padding: 10px;
      background: rgba(224, 175, 104, 0.1);
      border-radius: 6px;
    }

    .rollback-tasks {
      max-height: 200px;
      overflow-y: auto;
    }

    .rollback-task-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 0;
      font-size: 13px;
    }

    /* æœç´¢æ¡†æ ·å¼ */
    .search-box {
      position: relative;
      margin-bottom: 10px;
    }

    .search-input {
      width: 100%;
      padding: 8px 12px 8px 32px;
      border-radius: 6px;
      border: 1px solid var(--border-color);
      background: var(--bg-tertiary);
      color: var(--text-primary);
      font-size: 13px;
    }

    .search-input:focus {
      outline: none;
      border-color: var(--accent-blue);
    }

    .search-icon {
      position: absolute;
      left: 10px;
      top: 50%;
      transform: translateY(-50%);
      color: var(--text-secondary);
    }

    /* æŠ˜å æŒ‰é’®æ ·å¼ */
    .collapse-btn {
      cursor: pointer;
      user-select: none;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      color: var(--text-secondary);
      transition: transform 0.2s;
    }

    .collapse-btn.collapsed {
      transform: rotate(-90deg);
    }

    .tree-children {
      overflow: hidden;
      transition: max-height 0.3s ease-out;
    }

    .tree-children.collapsed {
      max-height: 0 !important;
    }

    /* ä»»åŠ¡é€‰ä¸­çŠ¶æ€ */
    .node-content.selected {
      background: var(--bg-tertiary);
      border: 1px solid var(--accent-blue);
    }

    /* å³é”®èœå• */
    .context-menu {
      position: fixed;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 6px 0;
      min-width: 150px;
      z-index: 3000;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    .context-menu-item {
      padding: 8px 15px;
      font-size: 13px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .context-menu-item:hover {
      background: var(--bg-tertiary);
    }

    .context-menu-divider {
      height: 1px;
      background: var(--border-color);
      margin: 6px 0;
    }

    /* è¿›åº¦æ¡åŠ¨ç”» */
    .progress-animated {
      background: linear-gradient(
        90deg,
        var(--accent-green) 0%,
        var(--accent-blue) 50%,
        var(--accent-green) 100%
      );
      background-size: 200% 100%;
      animation: progressShimmer 2s infinite;
    }

    @keyframes progressShimmer {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }

    /* WebSocket è¿æ¥çŠ¶æ€ */
    .ws-status {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: var(--text-secondary);
    }

    .ws-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--accent-red);
    }

    .ws-indicator.connected {
      background: var(--accent-green);
    }
  </style>

  <script>
    // API åŸºç¡€è·¯å¾„
    const API_BASE = '/api/blueprint';

    // çŠ¶æ€
    let isRunning = false;
    let currentTreeId = null;
    let currentBlueprintId = null;
    let selectedTaskId = null;
    let selectedCheckpointId = null;
    let taskDataCache = {};
    let collapsedNodes = new Set();
    let ws = null;

    // ========================================================================
    // åˆå§‹åŒ–
    // ========================================================================
    document.addEventListener('DOMContentLoaded', () => {
      refreshData();
      loadCheckpoints();
      initWebSocket();

      // è½®è¯¢ä½œä¸º WebSocket çš„åå¤‡
      setInterval(() => {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          refreshData();
        }
      }, 5000);

      // ç‚¹å‡»ç©ºç™½å¤„å…³é—­å³é”®èœå•
      document.addEventListener('click', () => {
        const menu = document.getElementById('contextMenu');
        if (menu) menu.remove();
      });

      // é”®ç›˜å¿«æ·é”®
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          closeAllModals();
        }
      });
    });

    // ========================================================================
    // WebSocket å®æ—¶æ›´æ–°
    // ========================================================================
    function initWebSocket() {
      const wsUrl = `ws://${window.location.host}/ws/blueprint`;

      try {
        ws = new WebSocket(wsUrl);

        ws.onopen = () => {
          updateWsStatus(true);
          showToast('å®æ—¶è¿æ¥å·²å»ºç«‹', 'success');
        };

        ws.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            handleWsMessage(data);
          } catch (e) {
            console.error('è§£æ WebSocket æ¶ˆæ¯å¤±è´¥:', e);
          }
        };

        ws.onclose = () => {
          updateWsStatus(false);
          // å°è¯•é‡è¿
          setTimeout(initWebSocket, 3000);
        };

        ws.onerror = (error) => {
          console.error('WebSocket é”™è¯¯:', error);
          updateWsStatus(false);
        };
      } catch (e) {
        console.error('WebSocket åˆå§‹åŒ–å¤±è´¥:', e);
      }
    }

    function updateWsStatus(connected) {
      const indicator = document.querySelector('.ws-indicator');
      const statusText = document.getElementById('wsStatusText');
      if (indicator) {
        indicator.classList.toggle('connected', connected);
      }
      if (statusText) {
        statusText.textContent = connected ? 'å·²è¿æ¥' : 'æœªè¿æ¥';
      }
    }

    function handleWsMessage(data) {
      switch (data.type) {
        case 'task_update':
          updateTaskInTree(data.task);
          break;
        case 'worker_update':
          updateWorkerCard(data.worker);
          break;
        case 'tdd_phase':
          updateTDDPhase(data.phase);
          break;
        case 'checkpoint_created':
          loadCheckpoints();
          showToast(`æ£€æŸ¥ç‚¹ "${data.name}" å·²åˆ›å»º`, 'success');
          break;
        case 'timeline_event':
          addTimelineEvent(data.event);
          break;
        case 'stats_update':
          updateStats(data.stats);
          break;
      }
    }

    // ========================================================================
    // Toast é€šçŸ¥ç³»ç»Ÿ
    // ========================================================================
    function showToast(message, type = 'info', duration = 3000) {
      const container = document.getElementById('toastContainer');
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;

      const icons = {
        success: 'âœ…',
        error: 'âŒ',
        warning: 'âš ï¸',
        info: 'â„¹ï¸'
      };

      toast.innerHTML = `
        <span>${icons[type] || icons.info}</span>
        <span>${message}</span>
      `;

      container.appendChild(toast);

      setTimeout(() => {
        toast.style.opacity = '0';
        toast.style.transform = 'translateX(100%)';
        setTimeout(() => toast.remove(), 300);
      }, duration);
    }

    // ========================================================================
    // æ¨¡æ€æ¡†ç®¡ç†
    // ========================================================================
    function openModal(modalId) {
      document.getElementById(modalId).style.display = 'flex';
    }

    function closeModal(modalId) {
      document.getElementById(modalId).style.display = 'none';
    }

    function closeAllModals() {
      document.querySelectorAll('.modal').forEach(m => m.style.display = 'none');
    }

    // ========================================================================
    // æ•°æ®åˆ·æ–°
    // ========================================================================
    async function refreshData() {
      try {
        const response = await fetch(`${API_BASE}/coordinator/dashboard`);
        const result = await response.json();

        if (result.success && result.data) {
          updateDashboard(result.data);
        }
      } catch (error) {
        console.error('åˆ·æ–°æ•°æ®å¤±è´¥:', error);
      }
    }

    function updateDashboard(data) {
      // æ›´æ–°ç»Ÿè®¡
      if (data.stats) {
        updateStats(data.stats);
      }

      // æ›´æ–° Worker æ•°é‡
      const workers = data.workers || [];
      const activeWorkers = workers.filter(w => w.status !== 'idle').length;
      document.getElementById('activeWorkers').textContent = activeWorkers;
      document.getElementById('workerCount').textContent = `${activeWorkers} / 5`;

      // æ›´æ–°ä»»åŠ¡æ ‘
      if (data.taskTree) {
        currentTreeId = data.taskTree.id;
        renderTaskTree(data.taskTree.root);
      }

      // ç¼“å­˜ä»»åŠ¡æ•°æ®
      if (data.taskTree) {
        cacheTaskData(data.taskTree.root);
      }

      // æ›´æ–° Worker åˆ—è¡¨
      renderWorkerList(workers);

      // æ›´æ–°æ—¶é—´çº¿
      if (data.timeline) {
        renderTimeline(data.timeline);
      }

      // æ›´æ–°æ‰§è¡ŒçŠ¶æ€
      isRunning = data.queen?.status === 'coordinating';
      updateStartButton();
    }

    function updateStats(stats) {
      document.getElementById('totalTasks').textContent = stats.totalTasks || 0;
      document.getElementById('passedTasks').textContent = stats.passedTasks || 0;
      document.getElementById('runningTasks').textContent = stats.runningTasks || 0;
      document.getElementById('failedTasks').textContent = stats.failedTasks || 0;
      document.getElementById('progress').textContent = (stats.progressPercentage || 0).toFixed(1) + '%';
      document.getElementById('treeDepth').textContent = `æ·±åº¦: ${stats.maxDepth || 0}`;
    }

    function cacheTaskData(node) {
      taskDataCache[node.id] = node;
      if (node.children) {
        node.children.forEach(child => cacheTaskData(child));
      }
    }

    // ========================================================================
    // ä»»åŠ¡æ ‘æ¸²æŸ“ï¼ˆå¸¦æŠ˜å åŠŸèƒ½ï¼‰
    // ========================================================================
    function renderTaskTree(node, container = null, depth = 0) {
      if (!container) {
        container = document.getElementById('taskTree');
        container.innerHTML = '';
      }

      const nodeEl = document.createElement('div');
      nodeEl.className = `tree-node ${depth === 0 ? 'root' : ''}`;
      nodeEl.dataset.taskId = node.id;

      const statusClass = `status-${node.status}`;
      const icon = getStatusIcon(node.status);
      const hasChildren = node.children && node.children.length > 0;
      const isCollapsed = collapsedNodes.has(node.id);

      nodeEl.innerHTML = `
        <div class="node-content ${selectedTaskId === node.id ? 'selected' : ''}"
             onclick="selectTask('${node.id}')"
             oncontextmenu="showTaskContextMenu(event, '${node.id}')">
          ${hasChildren ? `<span class="collapse-btn ${isCollapsed ? 'collapsed' : ''}" onclick="toggleCollapse(event, '${node.id}')">â–¼</span>` : '<span style="width: 16px;"></span>'}
          <span class="node-icon">${icon}</span>
          <span class="node-name">${node.name}</span>
          <span class="node-status ${statusClass}">${node.status}</span>
        </div>
      `;

      container.appendChild(nodeEl);

      // é€’å½’æ¸²æŸ“å­èŠ‚ç‚¹
      if (hasChildren) {
        const childContainer = document.createElement('div');
        childContainer.className = `tree-children ${isCollapsed ? 'collapsed' : ''}`;
        childContainer.style.marginLeft = '20px';
        if (!isCollapsed) {
          childContainer.style.maxHeight = 'none';
        }
        for (const child of node.children) {
          renderTaskTree(child, childContainer, depth + 1);
        }
        nodeEl.appendChild(childContainer);
      }
    }

    function toggleCollapse(event, nodeId) {
      event.stopPropagation();

      if (collapsedNodes.has(nodeId)) {
        collapsedNodes.delete(nodeId);
      } else {
        collapsedNodes.add(nodeId);
      }

      const nodeEl = document.querySelector(`[data-task-id="${nodeId}"]`);
      if (nodeEl) {
        const btn = nodeEl.querySelector('.collapse-btn');
        const children = nodeEl.querySelector('.tree-children');

        if (btn) btn.classList.toggle('collapsed');
        if (children) children.classList.toggle('collapsed');
      }
    }

    function getStatusIcon(status) {
      const icons = {
        pending: 'â³',
        blocked: 'ğŸš«',
        test_writing: 'âœï¸',
        coding: 'ğŸ’»',
        testing: 'ğŸ§ª',
        test_failed: 'âŒ',
        passed: 'âœ…',
        review: 'ğŸ‘€',
        approved: 'âœ…',
        rejected: 'âŒ',
        cancelled: 'ğŸš«',
      };
      return icons[status] || 'â“';
    }

    function updateTaskInTree(task) {
      taskDataCache[task.id] = task;
      const nodeEl = document.querySelector(`[data-task-id="${task.id}"]`);
      if (nodeEl) {
        const statusEl = nodeEl.querySelector('.node-status');
        const iconEl = nodeEl.querySelector('.node-icon');
        if (statusEl) {
          statusEl.className = `node-status status-${task.status}`;
          statusEl.textContent = task.status;
        }
        if (iconEl) {
          iconEl.textContent = getStatusIcon(task.status);
        }
      }
    }

    // ========================================================================
    // ä»»åŠ¡è¯¦æƒ…
    // ========================================================================
    function selectTask(taskId) {
      selectedTaskId = taskId;

      // æ›´æ–°é€‰ä¸­çŠ¶æ€
      document.querySelectorAll('.node-content').forEach(el => el.classList.remove('selected'));
      const nodeEl = document.querySelector(`[data-task-id="${taskId}"] > .node-content`);
      if (nodeEl) nodeEl.classList.add('selected');

      // æ˜¾ç¤ºä»»åŠ¡è¯¦æƒ…
      showTaskDetails(taskId);
    }

    async function showTaskDetails(taskId) {
      const task = taskDataCache[taskId];
      if (!task) {
        showToast('æ— æ³•åŠ è½½ä»»åŠ¡è¯¦æƒ…', 'error');
        return;
      }

      const body = document.getElementById('taskModalBody');
      body.innerHTML = `
        <div class="task-detail-section">
          <h3>åŸºæœ¬ä¿¡æ¯</h3>
          <div class="task-detail-content">
            <div class="task-detail-row">
              <span class="task-detail-label">ä»»åŠ¡åç§°</span>
              <span>${task.name}</span>
            </div>
            <div class="task-detail-row">
              <span class="task-detail-label">çŠ¶æ€</span>
              <span class="node-status status-${task.status}">${task.status}</span>
            </div>
            <div class="task-detail-row">
              <span class="task-detail-label">ä¼˜å…ˆçº§</span>
              <span>${task.priority || 'normal'}</span>
            </div>
            <div class="task-detail-row">
              <span class="task-detail-label">æ·±åº¦</span>
              <span>${task.depth}</span>
            </div>
            <div class="task-detail-row">
              <span class="task-detail-label">å­ä»»åŠ¡æ•°</span>
              <span>${task.children?.length || 0}</span>
            </div>
          </div>
        </div>

        <div class="task-detail-section">
          <h3>æè¿°</h3>
          <div class="task-detail-content">
            ${task.description || 'æ— æè¿°'}
          </div>
        </div>

        ${task.testSpec ? `
        <div class="task-detail-section">
          <h3>æµ‹è¯•è§„æ ¼</h3>
          <div class="task-detail-content">
            <pre style="white-space: pre-wrap; margin: 0;">${typeof task.testSpec === 'string' ? task.testSpec : JSON.stringify(task.testSpec, null, 2)}</pre>
          </div>
        </div>
        ` : ''}

        ${task.dependencies?.length > 0 ? `
        <div class="task-detail-section">
          <h3>ä¾èµ–ä»»åŠ¡</h3>
          <div class="task-detail-content">
            ${task.dependencies.map(d => `<div>â€¢ ${d}</div>`).join('')}
          </div>
        </div>
        ` : ''}
      `;

      openModal('taskModal');
    }

    async function startTaskTDD() {
      if (!selectedTaskId || !currentTreeId) {
        showToast('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªä»»åŠ¡', 'warning');
        return;
      }

      try {
        const response = await fetch(`${API_BASE}/tdd/start`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ treeId: currentTreeId, taskId: selectedTaskId }),
        });
        const result = await response.json();

        if (result.success) {
          showToast('TDD å¾ªç¯å·²å¯åŠ¨', 'success');
          closeModal('taskModal');
          refreshData();
        } else {
          showToast(result.error || 'å¯åŠ¨å¤±è´¥', 'error');
        }
      } catch (error) {
        showToast('å¯åŠ¨ TDD å¾ªç¯å¤±è´¥', 'error');
      }
    }

    // ========================================================================
    // å³é”®èœå•
    // ========================================================================
    function showTaskContextMenu(event, taskId) {
      event.preventDefault();
      event.stopPropagation();

      // ç§»é™¤å·²å­˜åœ¨çš„èœå•
      const existingMenu = document.getElementById('contextMenu');
      if (existingMenu) existingMenu.remove();

      const task = taskDataCache[taskId];
      const menu = document.createElement('div');
      menu.id = 'contextMenu';
      menu.className = 'context-menu';
      menu.style.left = `${event.pageX}px`;
      menu.style.top = `${event.pageY}px`;

      menu.innerHTML = `
        <div class="context-menu-item" onclick="selectTask('${taskId}'); showTaskDetails('${taskId}')">
          ğŸ“‹ æŸ¥çœ‹è¯¦æƒ…
        </div>
        <div class="context-menu-item" onclick="startTaskTDDDirect('${taskId}')">
          ğŸš€ å¯åŠ¨ TDD
        </div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" onclick="expandAll('${taskId}')">
          ğŸ“‚ å±•å¼€æ‰€æœ‰
        </div>
        <div class="context-menu-item" onclick="collapseAll('${taskId}')">
          ğŸ“ æŠ˜å æ‰€æœ‰
        </div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" onclick="createCheckpointForTask('${taskId}')">
          ğŸ“Œ åˆ›å»ºæ£€æŸ¥ç‚¹
        </div>
      `;

      document.body.appendChild(menu);
    }

    async function startTaskTDDDirect(taskId) {
      if (!currentTreeId) return;

      try {
        const response = await fetch(`${API_BASE}/tdd/start`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ treeId: currentTreeId, taskId }),
        });
        const result = await response.json();

        if (result.success) {
          showToast('TDD å¾ªç¯å·²å¯åŠ¨', 'success');
          refreshData();
        } else {
          showToast(result.error || 'å¯åŠ¨å¤±è´¥', 'error');
        }
      } catch (error) {
        showToast('å¯åŠ¨ TDD å¾ªç¯å¤±è´¥', 'error');
      }
    }

    function expandAll(nodeId) {
      const nodeEl = document.querySelector(`[data-task-id="${nodeId}"]`);
      if (!nodeEl) return;

      nodeEl.querySelectorAll('.tree-children').forEach(el => {
        el.classList.remove('collapsed');
        collapsedNodes.delete(el.parentElement.dataset.taskId);
      });
      nodeEl.querySelectorAll('.collapse-btn').forEach(el => {
        el.classList.remove('collapsed');
      });
    }

    function collapseAll(nodeId) {
      const nodeEl = document.querySelector(`[data-task-id="${nodeId}"]`);
      if (!nodeEl) return;

      nodeEl.querySelectorAll('.tree-children').forEach(el => {
        el.classList.add('collapsed');
        collapsedNodes.add(el.parentElement.dataset.taskId);
      });
      nodeEl.querySelectorAll('.collapse-btn').forEach(el => {
        el.classList.add('collapsed');
      });
    }

    // å…¨éƒ¨å±•å¼€
    function expandAllTasks() {
      const container = document.getElementById('taskTree');
      container.querySelectorAll('.tree-children').forEach(el => {
        el.classList.remove('collapsed');
        el.style.maxHeight = 'none';
      });
      container.querySelectorAll('.collapse-btn').forEach(el => {
        el.classList.remove('collapsed');
      });
      collapsedNodes.clear();
      showToast('å·²å±•å¼€æ‰€æœ‰ä»»åŠ¡', 'info');
    }

    // å…¨éƒ¨æŠ˜å 
    function collapseAllTasks() {
      const container = document.getElementById('taskTree');
      container.querySelectorAll('.tree-children').forEach(el => {
        el.classList.add('collapsed');
        const parentId = el.parentElement?.dataset?.taskId;
        if (parentId) collapsedNodes.add(parentId);
      });
      container.querySelectorAll('.collapse-btn').forEach(el => {
        el.classList.add('collapsed');
      });
      showToast('å·²æŠ˜å æ‰€æœ‰ä»»åŠ¡', 'info');
    }

    // æœç´¢è¿‡æ»¤ä»»åŠ¡
    let searchTimeout = null;
    function filterTasks(query) {
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(() => {
        const normalizedQuery = query.toLowerCase().trim();
        const container = document.getElementById('taskTree');
        const allNodes = container.querySelectorAll('.tree-node');

        if (!normalizedQuery) {
          // æ¸…é™¤æœç´¢ï¼Œæ¢å¤æ‰€æœ‰èŠ‚ç‚¹
          allNodes.forEach(node => {
            node.style.display = '';
            const content = node.querySelector('.node-content');
            if (content) content.style.background = '';
          });
          return;
        }

        // æ”¶é›†åŒ¹é…çš„èŠ‚ç‚¹ID
        const matchedIds = new Set();
        const parentIds = new Set();

        // é¦–å…ˆæ‰¾å‡ºæ‰€æœ‰åŒ¹é…çš„ä»»åŠ¡
        Object.values(taskDataCache).forEach(task => {
          if (task.name.toLowerCase().includes(normalizedQuery) ||
              (task.description && task.description.toLowerCase().includes(normalizedQuery))) {
            matchedIds.add(task.id);
            // æ”¶é›†æ‰€æœ‰ç¥–å…ˆèŠ‚ç‚¹
            let parentId = task.parentId;
            while (parentId) {
              parentIds.add(parentId);
              const parent = taskDataCache[parentId];
              parentId = parent?.parentId;
            }
          }
        });

        // æ˜¾ç¤º/éšè—èŠ‚ç‚¹
        allNodes.forEach(node => {
          const taskId = node.dataset.taskId;
          const isMatched = matchedIds.has(taskId);
          const isParent = parentIds.has(taskId);
          const content = node.querySelector('.node-content');

          if (isMatched || isParent) {
            node.style.display = '';
            // é«˜äº®åŒ¹é…çš„èŠ‚ç‚¹
            if (content) {
              content.style.background = isMatched ? 'rgba(122, 162, 247, 0.2)' : '';
            }
            // å±•å¼€çˆ¶èŠ‚ç‚¹
            if (isParent) {
              const children = node.querySelector('.tree-children');
              const btn = node.querySelector('.collapse-btn');
              if (children) {
                children.classList.remove('collapsed');
                children.style.maxHeight = 'none';
              }
              if (btn) btn.classList.remove('collapsed');
              collapsedNodes.delete(taskId);
            }
          } else {
            node.style.display = 'none';
            if (content) content.style.background = '';
          }
        });

        showToast(`æ‰¾åˆ° ${matchedIds.size} ä¸ªåŒ¹é…ä»»åŠ¡`, 'info');
      }, 300);
    }

    // ========================================================================
    // Worker åˆ—è¡¨
    // ========================================================================
    function renderWorkerList(workers) {
      const container = document.getElementById('workerList');

      if (!workers || workers.length === 0) {
        container.innerHTML = `
          <div class="empty-state">
            <div class="empty-state-icon">ğŸ</div>
            <div>æš‚æ— æ´»è·ƒçš„ Worker</div>
          </div>
        `;
        return;
      }

      container.innerHTML = workers.map(worker => {
        const progress = worker.tddCycle ?
          ((worker.tddCycle.iteration / worker.tddCycle.maxIterations) * 100) : 0;
        const isActive = worker.status !== 'idle';

        return `
          <div class="worker-card" data-worker-id="${worker.id}">
            <div class="worker-header">
              <span class="worker-id">${worker.id.substring(0, 8)}...</span>
              <span class="worker-status status-${worker.status}">${worker.status}</span>
            </div>
            <div class="worker-task">${worker.taskId ? 'ä»»åŠ¡: ' + worker.taskId.substring(0, 8) + '...' : 'ç©ºé—²'}</div>
            <div class="worker-progress">
              <div class="worker-progress-bar ${isActive ? 'progress-animated' : ''}" style="width: ${progress}%"></div>
            </div>
          </div>
        `;
      }).join('');

      // æ›´æ–° TDD é˜¶æ®µé«˜äº®
      const activeWorker = workers.find(w => w.status !== 'idle');
      if (activeWorker && activeWorker.tddCycle) {
        updateTDDPhase(activeWorker.tddCycle.phase);
      }
    }

    function updateWorkerCard(worker) {
      const card = document.querySelector(`[data-worker-id="${worker.id}"]`);
      if (!card) {
        refreshData();
        return;
      }

      const statusEl = card.querySelector('.worker-status');
      const taskEl = card.querySelector('.worker-task');
      const progressBar = card.querySelector('.worker-progress-bar');

      if (statusEl) {
        statusEl.className = `worker-status status-${worker.status}`;
        statusEl.textContent = worker.status;
      }

      if (taskEl) {
        taskEl.textContent = worker.taskId ? 'ä»»åŠ¡: ' + worker.taskId.substring(0, 8) + '...' : 'ç©ºé—²';
      }

      if (progressBar && worker.tddCycle) {
        const progress = (worker.tddCycle.iteration / worker.tddCycle.maxIterations) * 100;
        progressBar.style.width = `${progress}%`;
      }
    }

    function updateTDDPhase(phase) {
      const phases = ['write_test', 'run_test_red', 'write_code', 'run_test_green', 'refactor'];
      phases.forEach(p => {
        const el = document.getElementById(`phase-${p}`);
        if (el) {
          el.classList.remove('active', 'completed');
          if (p === phase) {
            el.classList.add('active');
          } else if (phases.indexOf(p) < phases.indexOf(phase)) {
            el.classList.add('completed');
          }
        }
      });
    }

    // ========================================================================
    // æ—¶é—´çº¿
    // ========================================================================
    function renderTimeline(events) {
      const container = document.getElementById('timeline');

      if (!events || events.length === 0) {
        container.innerHTML = `
          <div class="empty-state">
            <div class="empty-state-icon">ğŸ“œ</div>
            <div>æš‚æ— äº‹ä»¶</div>
          </div>
        `;
        return;
      }

      const recentEvents = events.slice(-20).reverse();

      container.innerHTML = recentEvents.map(event => {
        const typeClass = event.type.includes('fail') ? 'error' :
                         event.type.includes('complete') || event.type.includes('pass') ? 'success' :
                         event.type.includes('checkpoint') ? 'checkpoint' : '';

        const time = new Date(event.timestamp).toLocaleTimeString();

        return `
          <div class="timeline-item ${typeClass}">
            <div class="timeline-time">${time}</div>
            <div class="timeline-content">${event.description}</div>
          </div>
        `;
      }).join('');
    }

    function addTimelineEvent(event) {
      const container = document.getElementById('timeline');
      const emptyState = container.querySelector('.empty-state');
      if (emptyState) emptyState.remove();

      const typeClass = event.type.includes('fail') ? 'error' :
                       event.type.includes('complete') || event.type.includes('pass') ? 'success' :
                       event.type.includes('checkpoint') ? 'checkpoint' : '';

      const time = new Date(event.timestamp).toLocaleTimeString();

      const eventEl = document.createElement('div');
      eventEl.className = `timeline-item ${typeClass}`;
      eventEl.innerHTML = `
        <div class="timeline-time">${time}</div>
        <div class="timeline-content">${event.description}</div>
      `;

      container.insertBefore(eventEl, container.firstChild);

      // é™åˆ¶æ˜¾ç¤ºæ•°é‡
      while (container.children.length > 20) {
        container.removeChild(container.lastChild);
      }
    }

    // ========================================================================
    // æ£€æŸ¥ç‚¹ç®¡ç†
    // ========================================================================
    async function loadCheckpoints() {
      if (!currentTreeId) return;

      try {
        const response = await fetch(`${API_BASE}/time-travel/${currentTreeId}/checkpoints`);
        const result = await response.json();

        if (result.success) {
          renderCheckpointList(result.data);
        }
      } catch (error) {
        console.error('åŠ è½½æ£€æŸ¥ç‚¹å¤±è´¥:', error);
      }
    }

    function renderCheckpointList(checkpoints) {
      const container = document.getElementById('checkpointList');

      if (!checkpoints || checkpoints.length === 0) {
        container.innerHTML = `
          <div class="empty-state">
            <div class="empty-state-icon">ğŸ“Œ</div>
            <div>æš‚æ— æ£€æŸ¥ç‚¹</div>
          </div>
        `;
        return;
      }

      container.innerHTML = checkpoints.map(cp => `
        <div class="checkpoint-item" onclick="showCheckpointDetails('${cp.id}')">
          <span class="checkpoint-icon">${cp.type === 'manual' ? 'ğŸ“Œ' : 'ğŸ”„'}</span>
          <div class="checkpoint-info">
            <div class="checkpoint-name">${cp.name}</div>
            <div class="checkpoint-time">${new Date(cp.timestamp).toLocaleString()}</div>
          </div>
          <span class="checkpoint-action">é¢„è§ˆ</span>
        </div>
      `).join('');
    }

    async function showCheckpointDetails(checkpointId) {
      if (!currentTreeId) return;

      selectedCheckpointId = checkpointId;

      try {
        // è·å–æ£€æŸ¥ç‚¹è¯¦æƒ…å’Œå›æ»šé¢„è§ˆ
        const [detailsRes, previewRes] = await Promise.all([
          fetch(`${API_BASE}/time-travel/${currentTreeId}/checkpoints/${checkpointId}`),
          fetch(`${API_BASE}/time-travel/${currentTreeId}/preview/${checkpointId}`)
        ]);

        const details = await detailsRes.json();
        const preview = await previewRes.json();

        if (!details.success) {
          showToast('åŠ è½½æ£€æŸ¥ç‚¹è¯¦æƒ…å¤±è´¥', 'error');
          return;
        }

        const cp = details.data;
        const rollbackInfo = preview.success ? preview.data : null;

        const body = document.getElementById('checkpointModalBody');
        body.innerHTML = `
          <div class="task-detail-section">
            <h3>æ£€æŸ¥ç‚¹ä¿¡æ¯</h3>
            <div class="task-detail-content">
              <div class="task-detail-row">
                <span class="task-detail-label">åç§°</span>
                <span>${cp.name}</span>
              </div>
              <div class="task-detail-row">
                <span class="task-detail-label">ç±»å‹</span>
                <span>${cp.type === 'manual' ? 'æ‰‹åŠ¨' : 'è‡ªåŠ¨'}</span>
              </div>
              <div class="task-detail-row">
                <span class="task-detail-label">åˆ›å»ºæ—¶é—´</span>
                <span>${new Date(cp.timestamp).toLocaleString()}</span>
              </div>
              ${cp.description ? `
              <div class="task-detail-row">
                <span class="task-detail-label">æè¿°</span>
                <span>${cp.description}</span>
              </div>
              ` : ''}
            </div>
          </div>

          ${rollbackInfo ? `
          <div class="task-detail-section">
            <h3>å›æ»šé¢„è§ˆ</h3>
            <div class="rollback-preview">
              <div class="rollback-warning">
                âš ï¸ å›æ»šå°†æ’¤é”€ä»¥ä¸‹ ${rollbackInfo.affectedTasks?.length || 0} ä¸ªä»»åŠ¡çš„æ›´æ”¹
              </div>
              <div class="rollback-tasks">
                ${(rollbackInfo.affectedTasks || []).map(t => `
                  <div class="rollback-task-item">
                    <span>${getStatusIcon(t.status)}</span>
                    <span>${t.name}</span>
                  </div>
                `).join('')}
              </div>
            </div>
          </div>
          ` : ''}
        `;

        openModal('checkpointModal');
      } catch (error) {
        showToast('åŠ è½½æ£€æŸ¥ç‚¹è¯¦æƒ…å¤±è´¥', 'error');
      }
    }

    async function confirmRollback() {
      if (!currentTreeId || !selectedCheckpointId) return;

      try {
        const response = await fetch(`${API_BASE}/time-travel/${currentTreeId}/rollback/${selectedCheckpointId}`, {
          method: 'POST',
        });
        const result = await response.json();

        if (result.success) {
          showToast('å›æ»šæˆåŠŸ!', 'success');
          closeModal('checkpointModal');
          refreshData();
          loadCheckpoints();
        } else {
          showToast(result.error || 'å›æ»šå¤±è´¥', 'error');
        }
      } catch (error) {
        showToast('å›æ»šå¤±è´¥', 'error');
      }
    }

    function createCheckpoint() {
      if (!currentTreeId) {
        showToast('è¯·å…ˆåŠ è½½ä»»åŠ¡æ ‘', 'warning');
        return;
      }
      openModal('createCheckpointModal');
    }

    function createCheckpointForTask(taskId) {
      if (!currentTreeId) return;
      document.getElementById('checkpointName').value = `ä»»åŠ¡ ${taskId.substring(0, 8)} æ£€æŸ¥ç‚¹`;
      openModal('createCheckpointModal');
    }

    async function submitCheckpoint() {
      const name = document.getElementById('checkpointName').value.trim();
      const description = document.getElementById('checkpointDesc').value.trim();

      if (!name) {
        showToast('è¯·è¾“å…¥æ£€æŸ¥ç‚¹åç§°', 'warning');
        return;
      }

      try {
        const response = await fetch(`${API_BASE}/time-travel/${currentTreeId}/checkpoints`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name, description }),
        });
        const result = await response.json();

        if (result.success) {
          showToast('æ£€æŸ¥ç‚¹åˆ›å»ºæˆåŠŸ!', 'success');
          closeModal('createCheckpointModal');
          document.getElementById('checkpointName').value = '';
          document.getElementById('checkpointDesc').value = '';
          loadCheckpoints();
        } else {
          showToast(result.error || 'åˆ›å»ºå¤±è´¥', 'error');
        }
      } catch (error) {
        showToast('åˆ›å»ºæ£€æŸ¥ç‚¹å¤±è´¥', 'error');
      }
    }

    // ========================================================================
    // è“å›¾ç®¡ç†
    // ========================================================================
    function showBlueprints() {
      openModal('blueprintModal');
      loadBlueprints();
    }

    async function loadBlueprints() {
      try {
        const response = await fetch(`${API_BASE}/blueprints`);
        const result = await response.json();

        if (result.success) {
          renderBlueprintList(result.data);
        }
      } catch (error) {
        showToast('åŠ è½½è“å›¾åˆ—è¡¨å¤±è´¥', 'error');
      }
    }

    function renderBlueprintList(blueprints) {
      const container = document.getElementById('blueprintList');

      if (!blueprints || blueprints.length === 0) {
        container.innerHTML = `
          <div class="empty-state">
            <div class="empty-state-icon">ğŸ“˜</div>
            <div>æš‚æ— è“å›¾ï¼Œç‚¹å‡»ä¸Šæ–¹æŒ‰é’®åˆ›å»º</div>
          </div>
        `;
        return;
      }

      const statusColors = {
        draft: 'var(--text-secondary)',
        review: 'var(--accent-yellow)',
        approved: 'var(--accent-green)',
        rejected: 'var(--accent-red)',
      };

      container.innerHTML = blueprints.map(bp => `
        <div class="blueprint-card ${currentBlueprintId === bp.id ? 'selected' : ''}"
             onclick="selectBlueprint('${bp.id}')">
          <div class="blueprint-card-header">
            <span class="blueprint-card-title">${bp.name}</span>
            <span class="blueprint-card-status" style="background: ${statusColors[bp.status] || statusColors.draft}; color: var(--bg-primary);">
              ${bp.status}
            </span>
          </div>
          <div class="blueprint-card-desc">${bp.description || 'æ— æè¿°'}</div>
          <div class="blueprint-card-meta">
            <span>ğŸ“¦ ${bp.moduleCount} æ¨¡å—</span>
            <span>ğŸ”„ ${bp.processCount} æµç¨‹</span>
            <span>v${bp.version}</span>
          </div>
        </div>
      `).join('');
    }

    async function selectBlueprint(blueprintId) {
      currentBlueprintId = blueprintId;

      try {
        // åˆå§‹åŒ–èœ‚ç‹
        const response = await fetch(`${API_BASE}/coordinator/queen`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ blueprintId }),
        });
        const result = await response.json();

        if (result.success) {
          showToast('è“å›¾å·²åŠ è½½', 'success');
          closeModal('blueprintModal');
          refreshData();
        } else {
          showToast(result.error || 'åŠ è½½è“å›¾å¤±è´¥', 'error');
        }
      } catch (error) {
        showToast('åŠ è½½è“å›¾å¤±è´¥', 'error');
      }
    }

    async function analyzeCodebase() {
      showToast('å¼€å§‹åˆ†æä»£ç åº“...', 'info');

      try {
        // è°ƒç”¨ blueprint/analyze APIï¼ˆéœ€è¦åœ¨åç«¯æ·»åŠ ï¼‰
        const response = await fetch(`${API_BASE}/analyze`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ rootDir: '.' }),
        });
        const result = await response.json();

        if (result.success) {
          showToast('ä»£ç åº“åˆ†æå®Œæˆ!', 'success');
          loadBlueprints();
        } else {
          showToast(result.error || 'åˆ†æå¤±è´¥', 'error');
        }
      } catch (error) {
        showToast('åˆ†æä»£ç åº“å¤±è´¥', 'error');
      }
    }

    function showCreateBlueprint() {
      // ç®€å•å®ç°ï¼šä½¿ç”¨ prompt
      const name = prompt('è¯·è¾“å…¥è“å›¾åç§°:');
      if (!name) return;

      const description = prompt('è¯·è¾“å…¥è“å›¾æè¿°:');
      createNewBlueprint(name, description || '');
    }

    async function createNewBlueprint(name, description) {
      try {
        const response = await fetch(`${API_BASE}/blueprints`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name, description }),
        });
        const result = await response.json();

        if (result.success) {
          showToast('è“å›¾åˆ›å»ºæˆåŠŸ!', 'success');
          loadBlueprints();
        } else {
          showToast(result.error || 'åˆ›å»ºå¤±è´¥', 'error');
        }
      } catch (error) {
        showToast('åˆ›å»ºè“å›¾å¤±è´¥', 'error');
      }
    }

    // ========================================================================
    // æ‰§è¡Œæ§åˆ¶
    // ========================================================================
    async function toggleExecution() {
      try {
        if (isRunning) {
          await fetch(`${API_BASE}/coordinator/stop`, { method: 'POST' });
          showToast('æ‰§è¡Œå·²æš‚åœ', 'info');
        } else {
          await fetch(`${API_BASE}/coordinator/start`, { method: 'POST' });
          showToast('å¼€å§‹æ‰§è¡Œä»»åŠ¡', 'success');
        }
        isRunning = !isRunning;
        updateStartButton();
        refreshData();
      } catch (error) {
        showToast('æ“ä½œå¤±è´¥', 'error');
      }
    }

    function updateStartButton() {
      const btn = document.getElementById('startBtn');
      if (isRunning) {
        btn.textContent = 'â¸ï¸ æš‚åœæ‰§è¡Œ';
        btn.classList.remove('btn-success');
        btn.classList.add('btn-danger');
      } else {
        btn.textContent = 'â–¶ï¸ å¼€å§‹æ‰§è¡Œ';
        btn.classList.remove('btn-danger');
        btn.classList.add('btn-success');
      }
    }
  </script>
</body>
</html>
