# 数据流分析功能

## 功能概述

数据流分析功能帮助开发者理解代码中变量和属性的使用情况，通过追踪读写位置来分析数据的流向。

## 核心特性

### 1. 读写位置追踪

**功能**: 精确定位符号的所有读取和写入位置

**支持的操作**:
- ✅ 赋值 (`x = value`)
- ✅ 自增自减 (`x++`, `--x`)
- ✅ 复合赋值 (`x += 1`, `x *= 2`)
- ✅ 变量声明 (`const x = value`)
- ✅ 属性初始化 (`class C { prop = value; }`)
- ✅ 解构赋值 (`const { x } = obj`)
- ✅ 函数参数 (`function f(x) {}`)

**提供信息**:
- 文件路径
- 行号和列号
- 代码上下文（完整代码行）

### 2. 数据流图可视化

**功能**: 以图的形式展示数据流动

**图结构**:
```
写入节点 → 中心节点(符号) → 读取节点
```

**节点类型**:
- `center`: 符号本身（中心节点）
- `write`: 写入操作节点
- `read`: 读取操作节点

**用途**:
- 快速理解符号的使用模式
- 识别数据流的瓶颈
- 发现未使用的写入或读取

### 3. 统计分析

**提供指标**:
- 写入次数: 符号被修改的总次数
- 读取次数: 符号被引用的总次数
- 读写比: 读取次数 / 写入次数

**价值**:
- 高读写比 → 可能是重要的配置或缓存
- 低读写比 → 可能存在冗余写入
- 零读取 → 死代码（未使用的变量）
- 零写入 → 只读常量

## 使用场景

### 场景 1: 调试变量修改

**问题**: "这个变量在哪里被修改了？"

**解决方案**:
1. 在 ProjectNavigator 中选择该符号
2. 查看"写入位置"列表
3. 检查每个写入的代码上下文

**示例**:
```typescript
// 找到 userCount 的所有修改位置
符号: userCount
写入位置 (3):
  - 3:3: private userCount: number = 0;
  - 6:5: this.userCount++;
  - 16:5: this.userCount = 0;
```

### 场景 2: 分析变量使用

**问题**: "这个属性在哪里被使用？"

**解决方案**:
1. 查看"读取位置"列表
2. 分析使用模式
3. 识别关键使用场景

**示例**:
```typescript
// 找到 userCount 的所有使用位置
符号: userCount
读取位置 (5):
  - 8:28: console.log(`Users: ${this.userCount}`);
  - 10:12: if (this.userCount > 0) { ... }
  - 12:12: return this.userCount;
  - 14:20: this.userCount--;
  - 18:15: this.userCount++;
```

### 场景 3: 重构准备

**问题**: "重命名这个变量会影响哪些地方？"

**解决方案**:
1. 查看数据流图
2. 统计读写总数
3. 评估重构影响范围

**示例**:
```typescript
// 评估重命名 counter 的影响
符号: counter
写入次数: 8
读取次数: 23
读写比: 2.9
总影响位置: 31 处
```

### 场景 4: 代码审查

**问题**: "这段代码的数据流是否合理？"

**解决方案**:
1. 检查读写比
2. 查看数据流图
3. 发现异常模式

**异常模式**:
- 只写不读 → 死代码
- 只读不写 → 可能缺少初始化
- 过多写入 → 可能存在性能问题
- 读写交替频繁 → 可能需要优化

### 场景 5: 性能优化

**问题**: "哪些变量被频繁访问？"

**解决方案**:
1. 对比多个符号的读取次数
2. 识别热点变量
3. 考虑缓存或优化策略

## UI 界面说明

### DataSymbolView 组件

**展示内容**:

1. **基本信息**
   - 符号名称
   - 符号类型
   - 定义位置

2. **写入位置列表**
   - 按行号排序
   - 显示完整代码行
   - 可点击跳转（未来功能）

3. **读取位置列表**
   - 按行号排序
   - 显示完整代码行
   - 可点击跳转（未来功能）

4. **数据流统计**
   - 写入次数（统计卡片）
   - 读取次数（统计卡片）
   - 读写比（统计卡片）

**交互功能**:
- 悬停高亮代码片段
- 加载状态提示
- 错误提示

## 技术实现

### 分析引擎

**基础**: TypeScript Compiler API

**流程**:
1. 解析源代码为 AST
2. 遍历 AST 节点
3. 识别符号引用
4. 区分读写操作
5. 收集位置信息
6. 构建数据流图

### API 设计

**端点**: `GET /api/blueprint/data-flow/:symbolId`

**参数**:
- `symbolId`: 格式为 `filePath::symbolName` 或 `filePath::className::propertyName`

**响应**: JSON 格式的数据流结果

### 性能优化

**优化策略**:
- 只遍历相关作用域（类内部/全局）
- 跳过类型上下文和导入语句
- 延迟加载数据流图
- 代码片段按需提取

## 最佳实践

### 1. 符号命名建议

根据数据流分析结果优化命名：

```typescript
// ❌ 不好: 高读写比但名称模糊
let data = 0;  // 读写比: 15.3

// ✅ 好: 名称清晰反映用途
let activeUserCount = 0;  // 读写比: 15.3
```

### 2. 识别死代码

```typescript
// 零读取 = 死代码
private unusedField: string;  // 读取: 0, 写入: 1

// 可以安全删除
```

### 3. 发现性能问题

```typescript
// 高频写入可能影响性能
private cache: Map<string, any>;  // 写入: 1532, 读取: 45

// 考虑批量更新或使用更高效的数据结构
```

### 4. 保证数据一致性

```typescript
// 多处修改需要审查
private state: AppState;  // 写入: 12 处

// 考虑使用状态管理库或单一修改入口
```

## 限制和注意事项

### 当前限制

1. **单文件分析**
   - 只分析当前文件内的引用
   - 不追踪跨文件的导入/导出

2. **动态属性访问**
   - 无法分析 `obj[dynamicKey]`
   - 无法追踪计算属性名

3. **间接引用**
   - 别名和解构后的引用可能丢失
   - 闭包捕获的变量可能不完整

4. **运行时行为**
   - 只分析静态代码
   - 无法考虑条件分支执行情况

### 最佳实践

1. **结合代码审查**: 数据流分析是辅助工具，不能替代人工审查
2. **关注趋势**: 比单次分析更重要的是观察数据流的变化趋势
3. **交叉验证**: 结合调用图、依赖图等工具综合分析
4. **定期检查**: 定期分析核心符号的数据流，及早发现问题

## 未来规划

### 短期目标

- [ ] 点击位置跳转到源代码
- [ ] 数据流图交互式可视化
- [ ] 导出分析报告（JSON/CSV）
- [ ] 批量符号分析

### 中期目标

- [ ] 跨文件引用追踪
- [ ] 调用链集成（符号通过函数传递）
- [ ] 时间序列分析（代码变更历史）
- [ ] 智能建议（基于数据流模式）

### 长期目标

- [ ] 实时数据流监控
- [ ] AI 辅助优化建议
- [ ] 影响范围预测
- [ ] 自动化重构工具

## 相关文档

- [API 文档](../api/data-flow-api.md)
- [实现文档](../implementation/data-flow-analyzer.md)
- [测试指南](../../tests/data-flow-analyzer.test.ts)

## 常见问题

### Q: 为什么某些引用没有被识别？

**A**: 可能原因：
1. 在类型注解中使用（被排除）
2. 动态属性访问（无法静态分析）
3. 跨文件引用（当前不支持）

### Q: 数据流图太复杂怎么办？

**A**: 建议：
1. 关注写入节点（通常较少）
2. 使用过滤器（未来功能）
3. 分析局部数据流

### Q: 如何优化高读写比的符号？

**A**: 策略：
1. 考虑缓存结果
2. 减少不必要的读取
3. 批量处理写入

### Q: 零读取的符号可以直接删除吗？

**A**: 需要确认：
1. 是否被动态访问（`obj[key]`）
2. 是否在其他文件中使用
3. 是否是 API 契约的一部分

## 总结

数据流分析是理解和优化代码的强大工具。通过追踪符号的读写位置，开发者可以：

- 🔍 快速定位问题代码
- 🧹 清理死代码和冗余逻辑
- ⚡ 发现性能优化机会
- 🔧 安全地重构代码
- 📊 量化代码复杂度

合理使用数据流分析功能，可以显著提升代码质量和开发效率。
